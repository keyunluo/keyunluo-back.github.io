<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Coder On The Road"><title>Java中的IO流(1) | 流光</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java中的IO流(1)</h1><a id="logo" href="/.">流光</a><p class="description">他跑啊跑啊，只为追上那个曾经被寄予厚望的自己</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/guestbook/"><i class="fa fa-comments"> 留言</i></a><a href="/resource/share"><i class="fa fa-download"> 资源</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-4-5"><div class="content_container"><div class="post"><h1 class="post-title">Java中的IO流(1)</h1><div class="post-meta">Aug 6, 2016<span> | </span><span class="category"><a href="/categories/Programming/">Programming</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/08/06/2016-08-06-java-io-1.html" href="/2016/08/06/2016-08-06-java-io-1.html#comments" class="ds-thread-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#流的分类"><span class="toc-number">1.</span> <span class="toc-text">流的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InputStream和Reader"><span class="toc-number">2.</span> <span class="toc-text">InputStream和Reader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OutputStream和Writer"><span class="toc-number">3.</span> <span class="toc-text">OutputStream和Writer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#主要方法"><span class="toc-number">3.1.</span> <span class="toc-text">主要方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例子"><span class="toc-number">3.2.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理流"><span class="toc-number">4.</span> <span class="toc-text">处理流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#输入-输出流体系"><span class="toc-number">5.</span> <span class="toc-text">输入/输出流体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#转换流"><span class="toc-number">6.</span> <span class="toc-text">转换流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#推回输入流"><span class="toc-number">7.</span> <span class="toc-text">推回输入流</span></a></li></ol></div></div><div class="post-content"><blockquote>
<p><strong>本节内容：</strong>Java中的IO流是实现输入输出的基础，在Java中把不同的输入/输出源(键盘、文件、网络连接等)抽象表述为“流(stream)”,通过流的方式Java可以使用相同的方式来访问不同的输入/输出源。stream是从起源(source)到接受(sink)的有序数据。</p>
</blockquote>
<a id="more"></a>
<h2 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h2><ol>
<li><p>输入流和输出流 (按流的流向来分)</p>
<p> 输入流：InputStream和Reader作为基类</p>
<p> 输出流：OutputStream和Writer作为基类</p>
</li>
<li><p>字节流和字符流 (操作的数据大小)</p>
<p> 字节流：8位字节，由InputStream和OutputStream作为基类</p>
<p> 字符流：16位字符，主要由Reader和Writer作为基类</p>
</li>
<li><p>节点流和处理流 (流的角色)</p>
<p> 节点流：可以从/向一个特定的IO设备(磁盘、网络)读写数据的流，也被称为低级流</p>
<p> 处理流：对一个已经存在的流进行连接或封装，通过封装后的流来实现数据的读写功能，也被称为高级流</p>
</li>
<li><p>处理流的功能</p>
<ul>
<li>性能的提高：以增加缓冲的方式来提高输入/输出的效率</li>
<li>操作的便捷：一次性输入/输出大批量的内容</li>
<li>屏蔽了设备无关性：代码书写更加简洁</li>
</ul>
</li>
</ol>
<h2 id="InputStream和Reader"><a href="#InputStream和Reader" class="headerlink" title="InputStream和Reader"></a>InputStream和Reader</h2><p>InputStream和Reader是所有输入流的抽象基类,本身不能创建实例，但它们分别有一个用于读取文件的输入流:FileInputStream和FileReader，它们都是节点流——会和指定文件关联。</p>
<ul>
<li><p>InputStream
主要包含下面三个方法：</p>
<ul>
<li><strong>int read()</strong>:从输入流中读取单个字节，返回所读取的字节数据(字节数据可以直接转换成int类型)</li>
<li><strong>int read(byte[] b)</strong>:从输入流中最多读取b.length个字节的数据，并将其存储在字节数组b中，返回实际读取的字节数</li>
<li><strong>int read(byte[] b,int off ,int len)</strong>:从输入流中最多读取len个字节的数据，并将其存储在数组b中，放入数组b中时，并不是从数组起点开始，而是从off位置开始，返回实际读取的字节数</li>
</ul>
</li>
<li><p>Reader
主要包含下面三个方法：</p>
<ul>
<li><strong>int read()</strong>:从输入流中读取单个字符，返回所读取的字符数据(字符数据可以直接转换成int类型)</li>
<li><strong>int read(char[] cbuf)</strong>:从输入流中最多读取cbuf.length个字符的数据，并将其存储在字符数组cbuf中，返回实际读取的字符数</li>
<li><strong>int read(char[] cbuf,int off ,int len)</strong>:从输入流中最多读取len个字符的数据，并将其存储在字符数组cbuf中，放入数组cbuf中时，并不是从数组起点开始，而是从off位置开始，返回实际读取的字符数</li>
</ul>
</li>
<li><p>一个简单的例子-FileInputStream：读取源文件本身</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInput</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">// 创建字节输入流</span></span><br><span class="line">        FileInputStream fin = <span class="keyword">new</span> FileInputStream(<span class="string">"FileInput.java"</span>);</span><br><span class="line">        <span class="comment">// 创建一个长度为1024的缓冲</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 用于保存实际读取的字节数</span></span><br><span class="line">        <span class="keyword">int</span> hasRead = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 使用循环来重复读取</span></span><br><span class="line">        <span class="keyword">while</span> ((hasRead = fin.read(buf)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 读取字节，将字节数组转换成字符串输入</span></span><br><span class="line">            System.out.print(<span class="keyword">new</span> String(buf,<span class="number">0</span>,hasRead));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭文件输入流，放在finally块里面更加安全</span></span><br><span class="line">        fin.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序最后使用了fin.close()来关闭该文件输入流，与JDBC编程一样，程序打开的文件IO资源不属于内存里的资源，垃圾回收机制无法回收该资源。Java7改写了所有的IO资源类，它们都实现了AutoCloseable接口，因此都可以通过自动关闭资源的try语句来关闭这些IO流。</p>
<ul>
<li>一个简单的例子-FileReader：读取源文件本身</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReaderInput</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 创建字符输入流</span></span><br><span class="line">        FileReader fre = <span class="keyword">new</span> FileReader(<span class="string">"FileReaderInput.java"</span>);</span><br><span class="line">        <span class="comment">// 创建一个长度为32的缓冲</span></span><br><span class="line">        <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="comment">// 用于保存实际读取的字符数</span></span><br><span class="line">        <span class="keyword">int</span> hasRead = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 使用循环来重复读取</span></span><br><span class="line">        <span class="keyword">while</span> ((hasRead = fre.read(buf)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 读取字符，将字符数组转换成字符串输入</span></span><br><span class="line">            System.out.print(<span class="keyword">new</span> String(buf,<span class="number">0</span>,hasRead));</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>输入流移动记录指针</p>
<ul>
<li>void mark(int readAheadLimit):在记录指针当前位置记录一个标记(mark)</li>
<li>boolean markSupported():判断此输入流是否支持mark()操作</li>
<li>void reset():将此流的记录指针重新定位到上一次记录标记(mark)的位置</li>
<li>long skip(long n):记录指针向前移动n个字节/字符</li>
</ul>
</li>
</ul>
<h2 id="OutputStream和Writer"><a href="#OutputStream和Writer" class="headerlink" title="OutputStream和Writer"></a>OutputStream和Writer</h2><h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><p>OutputStream和Writer也非常类似，两个流都提供了如下三个方法：</p>
<ul>
<li>void write(int c):将指定的字节/字符输出到输出流中，其中c既可以表示字节，也可以表示字符</li>
<li>void write(byte[]/char[] buf):将字节数组/字符数组中的数据输出到指定输出流中</li>
<li>void write(byte[]/char[] buf,int off,int len):将字节数组/字符数组从off位置开始，长度为len的字节/字符输出到输出流中</li>
</ul>
<p>因为字符流直接以字符作为操作单位，所以Writer可以用字符串来代替字符数组，即以String对象作为参数，Writer里还包含如下两个方法：</p>
<ul>
<li>void write(String str):将str字符串里包含的字符输出到指定输出流中</li>
<li>void write(String str,int off,int len):将str字符串里从off位置开始，长度为len的字符输出到指定输出流中</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>从FileInputStream输入，使用FileOutputStream输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputOutput</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 创建字节输入流</span></span><br><span class="line">        FileInputStream fin = <span class="keyword">new</span> FileInputStream(<span class="string">"FileInputOutput.java"</span>);</span><br><span class="line">        <span class="comment">// 创建字符输出流</span></span><br><span class="line">        FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(<span class="string">"FileInputOutput-new.txt"</span>);</span><br><span class="line">        <span class="comment">// 创建一个长度为32的缓冲</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="comment">// 用于保存实际读取的字符数</span></span><br><span class="line">        <span class="keyword">int</span> hasRead = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 使用循环来重复读取</span></span><br><span class="line">        <span class="keyword">while</span> ((hasRead = fin.read(buf)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 读取字符，将字符数组转换成字符串输入</span></span><br><span class="line">            fout.write(buf,<span class="number">0</span>,hasRead);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h2><p>使用处理流的典型思路是，使用处理流来包装节点流，程序通过处理流来执行输入/输出功能，让节点流与底层的IO设备交互。</p>
<p>例如，使用PrintStream处理流来包装OutputStream，使用处理流后在输出时更加方便：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintStreamTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(<span class="string">"test.txt"</span>);</span><br><span class="line">            PrintStream ps = <span class="keyword">new</span> PrintStream(fout))&#123;</span><br><span class="line">            <span class="comment">// 使用PrintStream执行输出</span></span><br><span class="line">            ps.println(<span class="string">"普通字符串"</span>);</span><br><span class="line">            <span class="comment">// 直接使用PrintStream输出对象</span></span><br><span class="line">            ps.println(<span class="keyword">new</span> PrintStreamTest());</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输入-输出流体系"><a href="#输入-输出流体系" class="headerlink" title="输入/输出流体系"></a>输入/输出流体系</h2><p>Java的输入/输出流体系提供了将近40个类，这些类的常用分类如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">字节输入流</th>
<th style="text-align:left">字节输出流</th>
<th style="text-align:left">字符输入流</th>
<th style="text-align:left">字符输出流</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">节点流抽象基类</td>
<td style="text-align:left">InputStream</td>
<td style="text-align:left">OutputStream</td>
<td style="text-align:left">Reader</td>
<td style="text-align:left">Writer</td>
</tr>
<tr>
<td style="text-align:left">访问文件</td>
<td style="text-align:left">FileInputStream</td>
<td style="text-align:left">FileOutputStream</td>
<td style="text-align:left">FileReader</td>
<td style="text-align:left">FileWriter</td>
</tr>
<tr>
<td style="text-align:left">访问数组</td>
<td style="text-align:left">ByteArrayInputStream</td>
<td style="text-align:left">ByteArrayOutputStream</td>
<td style="text-align:left">CharArrayReader</td>
<td style="text-align:left">CharArrayWriter</td>
</tr>
<tr>
<td style="text-align:left">访问管道</td>
<td style="text-align:left">PipedInputStream</td>
<td style="text-align:left">PipedOutputStream</td>
<td style="text-align:left">PipedReader</td>
<td style="text-align:left">PipedWriter</td>
</tr>
<tr>
<td style="text-align:left">访问字符串</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">StringReader</td>
<td style="text-align:left">StringWriter</td>
</tr>
<tr>
<td style="text-align:left">缓冲流</td>
<td style="text-align:left">BufferedInputStream</td>
<td style="text-align:left">BufferedOutputStream</td>
<td style="text-align:left">BufferedReader</td>
<td style="text-align:left">BufferedWriter</td>
</tr>
<tr>
<td style="text-align:left">转换流</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">InputStreamReader</td>
<td style="text-align:left">OutputStreamWriter</td>
</tr>
<tr>
<td style="text-align:left">对象流</td>
<td style="text-align:left">ObjectInputStream</td>
<td style="text-align:left">ObjectOutputStream</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">处理流抽象基类</td>
<td style="text-align:left">FilterInputStream</td>
<td style="text-align:left">FilterOutputStream</td>
<td style="text-align:left">FilterReader</td>
<td style="text-align:left">FilterWriter</td>
</tr>
<tr>
<td style="text-align:left">打印流</td>
<td style="text-align:left"></td>
<td style="text-align:left">PrintStream</td>
<td style="text-align:left"></td>
<td style="text-align:left">PrintWriter</td>
</tr>
<tr>
<td style="text-align:left">推回输入流</td>
<td style="text-align:left">PushbackInputStream</td>
<td style="text-align:left"></td>
<td style="text-align:left">PushbackReader</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">特殊流</td>
<td style="text-align:left">DataInputStream</td>
<td style="text-align:left">DataOutputStream</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>转换流实现将字节流转换为字符流，其中InputStreamReader将字节输入流转换成字符输入流，OutputStreamWriter将字节输出流转换成字符输出流。</p>
<p>例子：Java使用System.in代表标准输入，即键盘输入，但这个标准输入流是InputStream类的实例，考虑到键盘输入内容都是文本内容，所以可以使用InputStreamReader将其转换为字符输入流，将普通的Reader包装成BufferedReader，利用BufferedReader的readLine()方法可以一次读取一行内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIn</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            <span class="comment">// 将System.in对象转换为Reader对象</span></span><br><span class="line">            InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">            <span class="comment">// 将普通的Reader包装成BufferedReader</span></span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(reader))&#123;</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 采用循环的方式逐行读取</span></span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) !=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 如果读取的是“exit”，则程序退出</span></span><br><span class="line">                <span class="keyword">if</span> (line.equals(<span class="string">"exit"</span>))&#123;</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 打印读取的内容</span></span><br><span class="line">                System.out.println(<span class="string">"输入内容为："</span>+line);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="推回输入流"><a href="#推回输入流" class="headerlink" title="推回输入流"></a>推回输入流</h2><p>在输入/输出流体系中，有两个流与众不同，就是PushbackInputStream和PushbackReader，它们都提供了如下三个方法：</p>
<ul>
<li>void unread(byte[]/char[] buf)：将一个字节/字符数组内容推回到推回缓冲区里面，从而允许重复读取刚刚读取的内容。</li>
<li>void unread(byte[]/char[] buf , int off ,int len):将一个字节/字符数组里从off开始，长度为len字节/字符的内容推回到推回缓冲区里，从而允许重复读取刚刚读取的内容。</li>
<li>void unread(int b):将一个字节/字符内容推回到推回缓冲区里面，从而允许重复读取刚刚读取的内容。</li>
</ul>
<p>当程序差创建一个推回输入流时，需要指定推回缓冲区的大小，默认的推回缓冲区大小是1，如果程序中的退回到退回缓冲区的内容超过了退回缓冲区的大小，将会引发Pushback buffer overflow的IOException异常。</p>
<p>例子：程序试图找出程序中的”new PushbackReader”字符串，当找到该字符串时，程序只打印目标字符串之前的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PushBackStream</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            <span class="comment">// 创键一个PushbackReader对象，指定推回缓冲区的大小为64</span></span><br><span class="line">            PushbackReader pr = <span class="keyword">new</span> PushbackReader(<span class="keyword">new</span> FileReader(<span class="string">"PushBackStream.java"</span>),<span class="number">64</span>))&#123;</span><br><span class="line">            <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">32</span>];</span><br><span class="line">            <span class="comment">// 用以保存上次读取的字符串内容</span></span><br><span class="line">            String lastContent = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">int</span> hasRead = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((hasRead = pr.read(buf)) &gt;<span class="number">0</span>)&#123;</span><br><span class="line">                String content = <span class="keyword">new</span> String(buf,<span class="number">0</span>,hasRead);</span><br><span class="line">                <span class="keyword">int</span> targetIndex = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 将上次读取的字符串和本次读取的字符串拼接起来</span></span><br><span class="line">                <span class="comment">// 查看是否包含目标字符串，如果包含目标字符串</span></span><br><span class="line">                <span class="keyword">if</span> ((targetIndex = (lastContent + content).indexOf(<span class="string">"new PushbackReader"</span>)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 将本次内容和上次内容一起推回缓冲区</span></span><br><span class="line">                    pr.unread((lastContent+content).toCharArray());</span><br><span class="line">                    <span class="comment">// 重新定义一个长度为targetIndex的char数组</span></span><br><span class="line">                    <span class="keyword">if</span> (targetIndex &gt; <span class="number">32</span>) buf = <span class="keyword">new</span> <span class="keyword">char</span>[targetIndex];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//再次读取指定长度的内容(就是目标字符串之前的内容)</span></span><br><span class="line">                    pr.read(buf, <span class="number">0</span> ,targetIndex);</span><br><span class="line">                    <span class="comment">//打印读取的内容</span></span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(buf , <span class="number">0</span> ,targetIndex));</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 打印上次读取的内容</span></span><br><span class="line">                    System.out.println(lastContent);</span><br><span class="line">                    <span class="comment">// 将本次内容设置为上次内容</span></span><br><span class="line">                    lastContent = content;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a data-url="http://keyunluo.github.io/2016/08/06/2016-08-06-java-io-1.html" data-id="cix7fk710002q58gl15ejx2a0" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Java/">Java</a></div><div class="post-nav"><a href="/2016/08/07/2016-08-07-java-io-2.html" class="pre">Java中的IO流(2)</a><a href="/2016/08/06/2016-08-06-hadoop-io-1.html" class="next">Hadoop源码学习(5)——Hadoop-Common-IO</a></div><div data-thread-key="2016/08/06/2016-08-06-java-io-1.html" data-title="Java中的IO流(1)" data-url="http://keyunluo.github.io/2016/08/06/2016-08-06-java-io-1.html" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/08/06/2016-08-06-java-io-1.html" data-title="Java中的IO流(1)" data-url="http://keyunluo.github.io/2016/08/06/2016-08-06-java-io-1.html" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-5"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AdvancedAlgorithms/">AdvancedAlgorithms</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/AlgorithmApplication/">AlgorithmApplication</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/BigData/">BigData</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DataBase/">DataBase</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DistributedSystem/">DistributedSystem</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/FileAndStorage/">FileAndStorage</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MachineLearning/">MachineLearning</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/">Programming</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SourceCodeLearning/">SourceCodeLearning</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Latex/" style="font-size: 15px;">Latex</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/二次排序/" style="font-size: 15px;">二次排序</a> <a href="/tags/VPN/" style="font-size: 15px;">VPN</a> <a href="/tags/Oracle/" style="font-size: 15px;">Oracle</a> <a href="/tags/DataBase/" style="font-size: 15px;">DataBase</a> <a href="/tags/sqoop/" style="font-size: 15px;">sqoop</a> <a href="/tags/elasticsearch/" style="font-size: 15px;">elasticsearch</a> <a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/生活/" style="font-size: 15px;">生活</a> <a href="/tags/毕业/" style="font-size: 15px;">毕业</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Markdown/" style="font-size: 15px;">Markdown</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/UML/" style="font-size: 15px;">UML</a> <a href="/tags/PlantUML/" style="font-size: 15px;">PlantUML</a> <a href="/tags/机器学习/" style="font-size: 15px;">机器学习</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/CentOS/" style="font-size: 15px;">CentOS</a> <a href="/tags/Cloudera/" style="font-size: 15px;">Cloudera</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/数据压缩/" style="font-size: 15px;">数据压缩</a> <a href="/tags/OpenCV/" style="font-size: 15px;">OpenCV</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/存储引擎/" style="font-size: 15px;">存储引擎</a> <a href="/tags/LSM树/" style="font-size: 15px;">LSM树</a> <a href="/tags/分布式系统/" style="font-size: 15px;">分布式系统</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/12/27/2016-12-27-data-mining.html">数据挖掘——试卷分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/23/2016-12-23-distributed-system-1.html">分布式系统——课程总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/22/2016-12-22-data-mining.html">数据挖掘——课程总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/16/2016-11-16-skiplist1.html">SkipList 跳跃表(1) ——基本介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/16/2016-11-16-lsm1.html">LSM Tree (1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/15/2016-11-15-hash.html">Hash存储引擎</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/03/2016-11-03-advanced-algorithm-assignment2.html">高级算法--作业2</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/2016-10-13-advanced-algorithm-assignment1.html">高级算法--作业1</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/06/2016-10-06-advanced-algorithm-3.html">高级算法(3)--Min-Cut-Max-Flow(2)-近似算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/05/2016-10-05-advanced-algorithm-2.html">高级算法(2)--Min-Cut-Max-Flow(1)-确定性算法</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 外部链接</i></div><ul></ul><a href="http://keyunluo.github.io/algorithm" title="个人算法练习" target="_blank">个人算法练习</a></div><div class="widget"><div class="widget-title"><i class="fa fa-bar-chart"> 访客</i></div><a href="http://info.flagcounter.com/uNxw"><img src="http://s07.flagcounter.com/count2/uNxw/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_10/viewers_3/labels_0/pageviews_0/flags_0/percent_0/" alt="" border="0"></a></div></div></div><div class="pure-u-1 pure-u-md-4-5"><div id="footer">© <a href="/." rel="nofollow">流光.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=1.0.0"><script>var duoshuoQuery = {short_name:'streamers'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-76470846-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?945b21807344d0260f24455bbd82dfea";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>