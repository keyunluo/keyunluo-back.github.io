<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Coder On The Road"><title>Hadoop源码学习(14)——压缩(2) | 流光</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Hadoop源码学习(14)——压缩(2)</h1><a id="logo" href="/.">流光</a><p class="description">他跑啊跑啊，只为追上那个曾经被寄予厚望的自己</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/guestbook/"><i class="fa fa-comments"> 留言</i></a><a href="/resource/share"><i class="fa fa-download"> 资源</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-4-5"><div class="content_container"><div class="post"><h1 class="post-title">Hadoop源码学习(14)——压缩(2)</h1><div class="post-meta">Aug 15, 2016<span> | </span><span class="category"><a href="/categories/SourceCodeLearning/">SourceCodeLearning</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/08/15/2016-08-15-hadoop-io-10.html" href="/2016/08/15/2016-08-15-hadoop-io-10.html#comments" class="ds-thread-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java本地化方法"><span class="toc-number">1.</span> <span class="toc-text">Java本地化方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CodecPool"><span class="toc-number">2.</span> <span class="toc-text">CodecPool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#支持Snappy压缩"><span class="toc-number">3.</span> <span class="toc-text">支持Snappy压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setInput"><span class="toc-number">3.1.</span> <span class="toc-text">setInput</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#needsInput"><span class="toc-number">3.2.</span> <span class="toc-text">needsInput</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#compress"><span class="toc-number">3.3.</span> <span class="toc-text">compress</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finished-和finish"><span class="toc-number">3.4.</span> <span class="toc-text">finished()和finish</span></a></li></ol></li></ol></div></div><div class="post-content"><blockquote>
<p><strong>本节内容：</strong>数据压缩往往是计算密集型操作，考虑到性能，建议使用本地库(Native Library)来压缩和解压缩。Snappy在Google的生产环境中经过了PB级数据压缩的考验，具有优良的性能，以Snappy为例，学习在Hadoop提供的压缩框架下集成新的压缩算法。</p>
</blockquote>
<a id="more"></a>
<h2 id="Java本地化方法"><a href="#Java本地化方法" class="headerlink" title="Java本地化方法"></a>Java本地化方法</h2><p>Hadoop的DEFLATE、gzip和Snappy都支持算法的本地化实现，默认情况下，Hadoop会在它运行的平台上查找本地库。</p>
<table>
<thead>
<tr>
<th style="text-align:left">压缩类型</th>
<th style="text-align:left">Java实现</th>
<th style="text-align:left">原生实现</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DEFLATE</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">gzip</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">bzip2</td>
<td style="text-align:left">Yes Yes</td>
</tr>
<tr>
<td style="text-align:left">LZO</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">LZ4</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">Snappy</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
</tbody>
</table>
<p>Java提供了一些钩子函数，使得调用本地方法成为可能。Java语言中的关键字native用于表示某个方法为本地方法，显然，本地方法是类的成员方法。例如，下面的例子中在org.apache.hadoop.io.compress.snappy包中，类SnappyCompressor的静态方法initIDs()和方法compressByteDirect()用关键字native修饰，表明这是一个本地化方法。</p>
<p>实际上，如果什么都不做也可以编译这个类，但是当使用这个类的时候，Java虚拟机会告诉你无法找到上述两个方法。要想实现这两个本地方法，一般需要三个步骤：</p>
<ul>
<li>为方法生成一个Java调用和实际C函数转换的C存根</li>
<li>建立一个共享库并导出该存根</li>
<li>使用System.loadLibrary()方法通知Java运行环境加载共享库</li>
</ul>
<p>Java为C存根的生成提供了实用程序javah，以上面的SnappyCompressor为例，可以在build/classes目录下执行命令：<code>javah org.apache.hadoop.io.compress.snappy.SnappyCompressor</code>,系统会生成一个头文件：<code>org_apache_hadoop_io_compress_snappy_SnappyCompressor.h</code>,该头文件包含上述两个本地方法相应的声明：</p>
<ul>
<li>Java_org_apache_hadoop_io_compress_snappy_SnappyCompressor_initIDs</li>
<li>Java_org_apache_hadoop_io_compress_snappy_SnappyCompressor_compressBytesDirect</li>
</ul>
<p>这两个声明遵从了Java本地方法的命名规则，以Java起首，然后是类的名字、方法名。声明中的JNIEXPORT和JNICALL命令表明了这两个方法会被JNI调用。上述第一个声明对应的方法是Java…initIDs，由于是一个静态方法，它的参数类型为JNIEnv的指针，用于和JVM通信。JNIEnv提供了大量的函数，可以执行类和对象的相关方法，也可以访问对象的成员变量或类的静态变量，参数jclass提供了引用静态方法对应类的机制，而Java…compressBytesDirect中的jobject相当于this引用，这两个参数大量应用于JNI提供的C API中。</p>
<p>JNIEnv提供了C代码和Java虚拟机通信的环境，GetObjectField()函数可用于获得对象的一个域，GetIntField()可用于得到Java对象的整型成员变量，SetField()设置Java对象的整型成员变量的值。最后使用System.loadLibrary()方法调用在java.library.path指定的路径下，寻找并加载附加驱动的动态库，如Snappy的libsnappy.so库。</p>
<h2 id="CodecPool"><a href="#CodecPool" class="headerlink" title="CodecPool"></a>CodecPool</h2><p>如果使用的是原生代码库并且需要在应用中执行大量压缩和解压缩操作，可以考虑使用 CodecPool。它支持反复使用压缩和解压缩，以分摊创建这些对象的开销。</p>
<p>下面的代码显示了API函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledStreamCompressor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  String codecClassname = args[<span class="number">0</span>];</span><br><span class="line">  Class&lt;?&gt; codecClass = Class.forName(codecClassname);</span><br><span class="line">  Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">  CompressionCodec codec = (CompressionCodec)</span><br><span class="line">  ReflectionUtils.newInstance(codecClass, conf);</span><br><span class="line">  Compressor compressor = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    compressor = CodecPool.getCompressor(codec);</span><br><span class="line">    CompressionOutputStream out = codec.createOutputStream(System.out, compressor);</span><br><span class="line">    IOUtils.copyBytes(System.in, out, <span class="number">4096</span>, <span class="keyword">false</span>);</span><br><span class="line">    out.finish();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  CodecPool.returnCompressor(compressor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在codec的重载方法createOutputStream()中，对于指定的CompressionCodec，我们从池中获取一个Compressor实例。通过使用finally数据块，我们在不同的数据流之家来回复制数据，即使出现IOException异常，也可以确保compressor可以返回池中。</p>
<h2 id="支持Snappy压缩"><a href="#支持Snappy压缩" class="headerlink" title="支持Snappy压缩"></a>支持Snappy压缩</h2><p>org.apache.hadoop.io.compress.snappy包括支持Snappy的压缩器SnappyCompressor和解压器SnappyDecompressor。LoadSnappy类用于判断Snappy本地库是否可用，如果可用，则通过System.loadLibrary()加载本地库。</p>
<p>SnappyCompressor实现了Compressor接口。压缩器的一般方法是循环调用setInput()、finish()和compress()三个方法对数据进行压缩。</p>
<p>SnappyCompressor的主要成员变量如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_DIRECT_BUFFER_SIZE = <span class="number">64</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// HACK - Use this as a global lock in the JNI layer</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"unused"</span>&#125;)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Class clazz = SnappyCompressor.class;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> directBufferSize;</span><br><span class="line">  <span class="keyword">private</span> Buffer compressedDirectBuf = <span class="keyword">null</span>;  <span class="comment">// 输出(压缩)数据缓冲区</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> uncompressedDirectBufLen;</span><br><span class="line">  <span class="keyword">private</span> Buffer uncompressedDirectBuf = <span class="keyword">null</span>;  <span class="comment">// 输入数据缓冲区</span></span><br><span class="line">  <span class="comment">// userBuf,userBufOff,userBufLen用于保存通过setInput()设置的，但超过压缩器工作空间uncompressedDirectBuf剩余可用空间的数据</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] userBuf = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> userBufOff = <span class="number">0</span>, userBufLen = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> finish, finished;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> bytesRead = <span class="number">0L</span>; <span class="comment">//计数器，供getBytesRead()使用</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> bytesWritten = <span class="number">0L</span>; <span class="comment">//计数器，供getBytesWritten()使用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> nativeSnappyLoaded = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<p>在分析压缩器/解压器和压缩流/解压流中，一直强调Compressor的setInput、needsInput、finish、finished和compress五个方法间的配合。下面分析这些方法的实现：</p>
<h3 id="setInput"><a href="#setInput" class="headerlink" title="setInput"></a>setInput</h3><p>setInput方法为压缩器提供数据，在做了一番数据合法性检查后，先将finished标志为false，并尝试将数据复制到内部缓冲区中。如果内部缓存器剩余空间不够大，那么压缩器将借用输入数据对应的缓冲区，即利用userBuff/userBufOff/userBufLen记录输入的数据。否则，setInput()复制数据到uncompressedDirectBuf中。</p>
<p>需要注意的是，当借用发生时，使用的是引用，即数据并没有实际的复制，用户不能随便修改传入的数据。同时，缓冲区只能借用一次，用户如果再次调用setInput，将会替换原来保存的信息，造成数据错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInput</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || off &gt; b.length - len) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">    finished = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; uncompressedDirectBuf.remaining()) &#123;</span><br><span class="line">      <span class="comment">// 借用外部缓冲区，这个时候needsInput为false</span></span><br><span class="line">      <span class="keyword">this</span>.userBuf = b;</span><br><span class="line">      <span class="keyword">this</span>.userBufOff = off;</span><br><span class="line">      <span class="keyword">this</span>.userBufLen = len;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ((ByteBuffer) uncompressedDirectBuf).put(b, off, len);</span><br><span class="line">      uncompressedDirectBufLen = uncompressedDirectBuf.position();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bytesRead += len;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>setInput()借用外部缓冲区后就不能再接收数据，这时用户调用needsInput()将返回false，就可以获知这个消息。</p>
<h3 id="needsInput"><a href="#needsInput" class="headerlink" title="needsInput"></a>needsInput</h3><p>needsInput()返回false有三种情况：输出缓冲区（即保持压缩结果的缓冲区）有未读取的数据、输入缓冲区没有空间、压缩器已经借用外部缓冲区。这时，用户需要通过compress()方法取走已经压缩的数据，直至needsInput()返回true，才可以再次通过setInput()方法添加待压缩数据，相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needsInput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(compressedDirectBuf.remaining() &gt; <span class="number">0</span></span><br><span class="line">        || uncompressedDirectBuf.remaining() == <span class="number">0</span> || userBufLen &gt; <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="compress"><a href="#compress" class="headerlink" title="compress"></a>compress</h3><p>compress方法用于获取压缩后的数据，它需要处理needsInput()返回false的几种情况。</p>
<ul>
<li>如果压缩数据缓冲区有数据，即compressedDirectBuf中还有数据，则读取这部分数据，并返回。</li>
<li>如果该缓冲区为空，则需要压缩数据。首先清理compressedDirectBuf，这个清理（即调用clear()和limit()）是一个典型的Buffer操作。待压缩的数据有两个来源：输入缓冲区uncompressedDirectBuf或者“借用”的数据缓冲区。</li>
<li>如果输入缓冲区没有数据，那待压缩数据可能(可以在没有任何待压缩数据的情况下调用compress()方法)在“借用”的数据缓冲区里，这时使用setInputFromSavedData()方法复制“借用”数据缓冲区中的数据到uncompressedDirectBuf中。setInputFromSavedData()方法调用结束后，待压缩数据缓冲区中里还没有数据，则设置finished标志位，并返回0，表明压缩数据已经读完。</li>
</ul>
<p>uncompressedDirectBuffer中的数据，利用前面介绍的native方法compressBytesDirect()进行压缩，压缩后的数据保存在compressedDirectBuf中。由于待压缩数据缓冲区和压缩数据缓冲区的大小是一样的，所以uncompressedDirectBuf中的数据是一次被处理完的。compressedByteDirect()调用结束后，需要再次设置缓冲区的标记，并根据情况复制数据到compress()的参数b提供的缓冲区中。相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || off &gt; b.length - len) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否还有未取走的已经压缩的数据</span></span><br><span class="line">    <span class="keyword">int</span> n = compressedDirectBuf.remaining();</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      n = Math.min(n, len);</span><br><span class="line">      ((ByteBuffer) compressedDirectBuf).get(b, off, n);</span><br><span class="line">      bytesWritten += n;</span><br><span class="line">      <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理压缩数据缓冲区</span></span><br><span class="line">    compressedDirectBuf.clear();</span><br><span class="line">    compressedDirectBuf.limit(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == uncompressedDirectBuf.position()) &#123;</span><br><span class="line">      <span class="comment">// 输入数据缓冲区没有数据</span></span><br><span class="line">      setInputFromSavedData();</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">0</span> == uncompressedDirectBuf.position()) &#123;</span><br><span class="line">        <span class="comment">// Called without data; write nothing</span></span><br><span class="line">        finished = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压缩数据</span></span><br><span class="line">    n = compressBytesDirect();</span><br><span class="line">    compressedDirectBuf.limit(n);</span><br><span class="line">    uncompressedDirectBuf.clear(); <span class="comment">// snappy consumes all buffer input</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// snappy已经处理完所有的数据，设置finished为true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == userBufLen) &#123;</span><br><span class="line">      finished = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get atmost 'len' bytes</span></span><br><span class="line">    n = Math.min(n, len);</span><br><span class="line">    bytesWritten += n;</span><br><span class="line">    ((ByteBuffer) compressedDirectBuf).get(b, off, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="finished-和finish"><a href="#finished-和finish" class="headerlink" title="finished()和finish"></a>finished()和finish</h3><p>finished()返回true，表明压缩过程已经结束。压缩过程结束包含多个条件，包括finish标志位和finished标志位都必须为true，以及compressedDirectBuf中没有未取走的数据。其中，finish为true，表明用户已经确认完成数据的输入过程，finished表明压缩器中没有待压缩数据，这三个条件缺一不可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">finished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Check if all uncompressed data has been consumed</span></span><br><span class="line">    <span class="keyword">return</span> (finish &amp;&amp; finished &amp;&amp; compressedDirectBuf.remaining() == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a data-url="http://keyunluo.github.io/2016/08/15/2016-08-15-hadoop-io-10.html" data-id="cix1kr3z60041hyglvv5jbs2e" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Hadoop/">Hadoop</a></div><div class="post-nav"><a href="/2016/08/15/2016-08-15-statical-learning-3.html" class="pre">统计学习方法——K近邻算法</a><a href="/2016/08/14/2016-08-14-hadoop-io-9.html" class="next">Hadoop源码学习(13)——压缩(1)</a></div><div data-thread-key="2016/08/15/2016-08-15-hadoop-io-10.html" data-title="Hadoop源码学习(14)——压缩(2)" data-url="http://keyunluo.github.io/2016/08/15/2016-08-15-hadoop-io-10.html" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/08/15/2016-08-15-hadoop-io-10.html" data-title="Hadoop源码学习(14)——压缩(2)" data-url="http://keyunluo.github.io/2016/08/15/2016-08-15-hadoop-io-10.html" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-5"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AdvancedAlgorithms/">AdvancedAlgorithms</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/AlgorithmApplication/">AlgorithmApplication</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/BigData/">BigData</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DataBase/">DataBase</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DistributedSystem/">DistributedSystem</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/FileAndStorage/">FileAndStorage</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MachineLearning/">MachineLearning</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/">Programming</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SourceCodeLearning/">SourceCodeLearning</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Latex/" style="font-size: 15px;">Latex</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/二次排序/" style="font-size: 15px;">二次排序</a> <a href="/tags/Oracle/" style="font-size: 15px;">Oracle</a> <a href="/tags/DataBase/" style="font-size: 15px;">DataBase</a> <a href="/tags/elasticsearch/" style="font-size: 15px;">elasticsearch</a> <a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/VPN/" style="font-size: 15px;">VPN</a> <a href="/tags/sqoop/" style="font-size: 15px;">sqoop</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/生活/" style="font-size: 15px;">生活</a> <a href="/tags/毕业/" style="font-size: 15px;">毕业</a> <a href="/tags/Markdown/" style="font-size: 15px;">Markdown</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/UML/" style="font-size: 15px;">UML</a> <a href="/tags/PlantUML/" style="font-size: 15px;">PlantUML</a> <a href="/tags/机器学习/" style="font-size: 15px;">机器学习</a> <a href="/tags/CentOS/" style="font-size: 15px;">CentOS</a> <a href="/tags/Cloudera/" style="font-size: 15px;">Cloudera</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/数据压缩/" style="font-size: 15px;">数据压缩</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/OpenCV/" style="font-size: 15px;">OpenCV</a> <a href="/tags/存储引擎/" style="font-size: 15px;">存储引擎</a> <a href="/tags/LSM树/" style="font-size: 15px;">LSM树</a> <a href="/tags/分布式系统/" style="font-size: 15px;">分布式系统</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/12/23/2016-12-23-distributed-system-1.html">分布式系统——课程总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/23/2016-12-22-data-mining.html">数据挖掘——课程总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/16/2016-11-16-skiplist1.html">SkipList 跳跃表(1) ——基本介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/16/2016-11-16-lsm1.html">LSM Tree (1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/15/2016-11-15-hash.html">Hash存储引擎</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/03/2016-11-03-advanced-algorithm-assignment2.html">高级算法--作业2</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/2016-10-13-advanced-algorithm-assignment1.html">高级算法--作业1</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/06/2016-10-06-advanced-algorithm-3.html">高级算法(3)--Min-Cut-Max-Flow(2)-近似算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/05/2016-10-05-advanced-algorithm-2.html">高级算法(2)--Min-Cut-Max-Flow(1)-确定性算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/04/2016-10-04-advanced-algorithm-1.html">高级算法(1)--NP完全性与近似算法</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 外部链接</i></div><ul></ul><a href="http://keyunluo.github.io/algorithm" title="个人算法练习" target="_blank">个人算法练习</a></div><div class="widget"><div class="widget-title"><i class="fa fa-bar-chart"> 访客</i></div><a href="http://info.flagcounter.com/uNxw"><img src="http://s07.flagcounter.com/count2/uNxw/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_10/viewers_3/labels_0/pageviews_0/flags_0/percent_0/" alt="" border="0"></a></div></div></div><div class="pure-u-1 pure-u-md-4-5"><div id="footer">© <a href="/." rel="nofollow">流光.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=1.0.0"><script>var duoshuoQuery = {short_name:'streamers'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-76470846-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?945b21807344d0260f24455bbd82dfea";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>