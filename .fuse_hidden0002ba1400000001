<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[高级算法--作业1]]></title>
      <url>http://keyunluo.github.io/2016/10/13/2016-10-13-advanced-algorithm-assignment1.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>高级算法：第一次作业。</p>
</blockquote>
<a id="more"></a>
<h2 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem 1"></a>Problem 1</h2><p>For any $\alpha\ge 1$, a cut $C$ in an undirected (multi)graph $G(V,E)$ is called an <strong>α-min-cut</strong> if $|C|\le\alpha|C^*|$ where $C^*$ is a min-cut in $G$.</p>
<ol>
<li><p>Give a lower bound to the probability that Karger’s Random Contraction algorithm returns an <strong>α-min-cut</strong> in a graph $G(V,E) $ of n vertices.</p>
</li>
<li><p>Use the above bound to estimate the number of distinct <strong>α-min</strong> cuts in $G$.</p>
</li>
</ol>
<hr>
<h3 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h3><p>1.From Karger’s algorithm we know that the maximum size of α-min-cut <strong>C</strong> is <strong>α|C*|</strong>, the degree of multi-graph $G_i:degree(G_i) = 2|E_i| \geq |V_i| |C^*| \ge |V_i|\cdot|C|/ \alpha $ ,so
the probability $p_i =\Pr[e_i \notin C \vert \forall j &lt; i,e_i \notin C]$ can be computed as:</p>
<p>$$\begin{array} {lcl}
p_i  &amp; = &amp; 1 - \frac{\vert C \vert}{\vert E_i \vert} \\
&amp; \geq &amp; 1 - \frac{2\alpha}{|V_i|} \\
&amp; = &amp; 1- \frac{2\alpha}{n-i+1}
\end{array}$$</p>
<p>and further, apply the Karger’s algorithm until <strong>2α</strong> vertices remain:</p>
<p>$$\begin{array} {lcl}
p_{\text{survives until 2α vertices remain}} &amp; \geq &amp; \Pr[\,C_{2α}\mbox{ is returned by }{RandomContract}\,]\\
&amp; = &amp; \Pr[\,e_i\not\in C\mbox{ for all }i=1,2,\ldots,n-2α\,]\\
&amp; = &amp; \prod_{i=1}^{n-2α}\Pr[e_i\not\in C\mid \forall j&lt;i, e_j\not\in C]\\
&amp; \geq &amp; \prod_{i=1}^{n-2α}\left(1-\frac{2α}{n-i+1}\right)\\
&amp; = &amp; \frac{(n-2α)!}{n!/(2α)!} \\
&amp; = &amp; \frac{(n-2α)!(2α)!}{n!} \\
&amp; = &amp; \frac{1}{n \choose 2α}
\end{array}$$</p>
<p>then, choose a random cut in the remaining multi-graph:G</p>
<p>$$\begin{array} {lcl}
p_{\text{correct}} &amp; = &amp; \Pr[\text{C survives until 2α vertices remain}] \times \Pr[\text{C survives random cut}]\\
&amp; \geq &amp; \frac{1}{n \choose 2α} \times \frac{2}{2^{2α}}\\
&amp; = &amp; \frac{(2α)!}{2^{2α-1}} \times \frac{(n-2α)!}{n!}\\
&amp; \geq &amp; \frac{(2α)!}{2^{2α-1}} \times \frac{1}{n^{2α}}\\
&amp; \geq &amp; \frac{1}{n^{2α}}
\end{array}$$</p>
<p>So, a lower bound to the probability that Karger’s Random Contraction algorithm returns an α-min-cut in a graph G(V,E) of n vertices can be $n^{-2α}$.</p>
<p>2.By the analysis of Karger’s algorithm, we know $p_C\ge\frac{1}{n^{2α}}$. And since $p_{correct}$ is a well defined probability, due to the unitarity of probability, it must hold that $p_{\text{correct}}\le 1$. Therefore:</p>
<p>$$1 \ge p_{correct} = \sum_{C \in \sf{C}}p_C \ge |\sf{C}| \frac{1}{n^{2α}}$$</p>
<p>and this means that $ |\sf{C}| \le n^{2α}$, So  the up bound of the number of distinct α-min cuts in G is $ n^{2α}$.</p>
<hr>
<h2 id="Problem-2"><a href="#Problem-2" class="headerlink" title="Problem 2"></a>Problem 2</h2><p>Let $G(V,E) $ be an undirected graph with positive edge weights $w:E\to\mathbb{Z}^+$. Given a partition of $V$ into $k$ disjoint subsets $S_1,S_2,\ldots,S_k$, we define
$w(S_1,S_2,\ldots,S_k)=\sum_{uv\in E\atop \exists i\neq j: u\in S_i,v\in S_j}w(uv)$
as the cost of the k-cut ${S_1,S_2,\ldots,S_k}$. Our goal is to find a <strong>k-cut</strong> with maximum cost.</p>
<ol>
<li><p>Give a poly-time greedy algorithm for finding the weighted max $k-cut$. Prove that the approximation ratio is $(1 − 1 / k)$.</p>
</li>
<li><p>Consider the following local search algorithm for the weighted max cut <strong>(max 2-cut)</strong>.</p>
<p> Fill in the blank parenthesis. Give an analysis of the running time of the algorithm. And prove that the approximation ratio is <em>0.5</em>.</p>
</li>
</ol>
<blockquote>
<p>start with an arbitrary bipartition of $V$ into disjoint $S_0,S_1$;</p>
<p> while (true) do</p>
<p>  &emsp;&emsp;if $\exists i\in{0,1}$ and $v\in S_i$ such that (<strong><strong><strong>__</strong></strong></strong>)</p>
<p>  &emsp;&emsp;&emsp;then $v$ leaves $S_i$ and joins $S_{1 − i}$;</p>
<p>  &emsp;&emsp;&emsp;continue;</p>
<p>  &emsp;&emsp;end if</p>
<p>  &emsp;&emsp;break;</p>
<p>end</p>
</blockquote>
<hr>
<h3 id="My-Solution-1"><a href="#My-Solution-1" class="headerlink" title="My Solution"></a>My Solution</h3><p>1.(1) <strong>algorithm</strong></p>
<blockquote>
<p>$S_1={v_1},S_2={v_2},\ldots,S_k={v_k}$,$V =V - {v_1,v_2,\ldots,v_k} $  ;</p>
<p>while ( V is not empty) do:</p>
<p>&emsp;&emsp; Randomly select  a vertic $v$ in V;</p>
<p>&emsp;&emsp; $V = V- v$</p>
<p>&emsp;&emsp; put $v$ to $S_j$ for the biggest increased value</p>
</blockquote>
<p>(2) <strong>proof</strong>:</p>
<p>$$\begin{array} {lcl}
E(w) &amp; = &amp; \sum_{(i,j) \in E} w_{i,j} \Pr[i \in V_m,j\in V_n, \forall m \neq n] \\
        &amp; = &amp; \sum_{(i,j) \in E} w_{i,j}  (1 - \Pr[i \in V_m,j\in V_m, \forall m ]) \\
        &amp; = &amp; \sum_{(i,j) \in E} w_{i,j}  (1 - \sum_{m=1}^k\Pr[i \in V_m,j\in V_m]) \\
        &amp; = &amp; \sum_{(i,j) \in E} w_{i,j}  (1 - \sum_{m=1}^k\frac{1}{k^2}) \\
        &amp; = &amp; (1-\frac{1}{k})\sum_{(i,j) \in E} w_{i,j}  \\
        &amp; \ge &amp; (1-\frac{1}{k})OPT
\end{array}$$</p>
<p>2.(1) the <strong>blank</strong>: $\underline{v \in S_{1-i} \ has\ bigger\ cut \ result}$</p>
<p>(2) <strong>analysis</strong>: calculate the cut  between $S_0,S_1$ is $O(n^2)$, and in each loop the value is increaed at least 1, thus the maximum possible cut value is $\sum_{e \in E}w_e$,then the loop size is $\sum_{e \in E}w_e$ at most. finally the total running time is $O(n^2 \cdot \sum_{e \in E}w_e)$.</p>
<p>(3) <strong>proof</strong>:</p>
<ul>
<li><p>the <em>OPT</em> can’t be larger than the sum of all egde weights, then : $\sum_{e \in E} w_e\geq OPT $</p>
</li>
<li><p>if we move $v$ from $S_i \  to \ S_{1-i}$, then $\sum_{v \in S_{1-i}, (u,v) \in E}w(u,v) \geq \sum_{v \in S_{i}, (u,v) \in E}w(u,v) $,
according to the mean value theorem, we have $\sum_{v \in S_{1-i}, (u,v) \in E}w(u,v) \geq \frac{1}{2}\sum_{v :(u,v) \in E}w(u,v)$, and  for any $u’ \in S_{1-i}$ , we can get $\sum_{v \in S_i, (u’,v) \in E}w(u’,v) \geq \frac{1}{2}\sum_{v :(u’,v) \in E}w(u’,v)$ similarly.</p>
</li>
</ul>
<p>Finally, for all vertices in V, the max-cut is :</p>
<p>$$\begin{array} {lcl}
V(S) &amp;= &amp; \sum_{u \in S_i,v \in S_{1-i},(u,v) \in E } \\
        &amp; = &amp; \sum_{v \in S_i, (u,v) \in E}w(u,v) + \sum_{v \in S_{1-i}, (u,v) \in E}w(u,v)  \\
        &amp; \ge &amp; \frac{1}{2}\sum_{v :(u’,v) \in E}w(u,v) + \frac{1}{2}\sum_{v :(u,v) \in E}w(u,v) \\
        &amp; = &amp; \frac{1}{2} \sum_{e \in E}w_e \\
        &amp; \ge &amp;\frac{1}{2}OPT
 \end{array}$$</p>
<hr>
<h2 id="Problem-3"><a href="#Problem-3" class="headerlink" title="Problem 3"></a>Problem 3</h2><p>Given $m$ subsets $S_1,S_2,\ldots, S_m\subseteq U $of a universe $U$ of size $n$, we want to find a $C\subseteq{1,2,\ldots, n}$ of fixed size $k = | C |$ with the <em>maximum coverage</em> $\left|\bigcup_{i\in C}S_i\right|$.</p>
<ul>
<li>Give a poly-time greedy algorithm for the problem. Prove that the approximation ratio is $1 − (1 − 1 / k)k &gt; 1 − 1 / e$.</li>
</ul>
<hr>
<h3 id="My-Solution-2"><a href="#My-Solution-2" class="headerlink" title="My Solution"></a>My Solution</h3><p><strong>algorithm</strong>:</p>
<blockquote>
<p><strong>GreedyCover</strong></p>
<p>Input: sets $S_1,S_2,\ldots,S_m$;</p>
<p>initially, $U=\bigcup_{i=1}^mS_i$, and $C=\emptyset$, count = 0;</p>
<p>while $U\neq\emptyset$ and count &lt; k do</p>
<p>&emsp;&emsp;find $i\in{1,2,\ldots, m}$ with the largest $|S_i\cap U|$;</p>
<p>&emsp;&emsp;let $C=C\cup{i}$and $U=U-  S_i$;</p>
<p>&emsp;&emsp;count = count + 1</p>
<p>return C;</p>
</blockquote>
<p><strong>proof</strong>:
let $c_i$ denote the elements of selected $S_j$ in the i-th round , and $C_i=\sum_{i=1}^ic_i$, the optimum solution is $OPT$, the remaining elements in $OPT$ is $R_i$, we have: $R_i = OPT - C_i,R_0 = OPT, C_0 =0$.</p>
<p>At each round , the Greedy algorithm selects the subset $S_j$ with maximum size of uncoverd elements yet,  there exists one set that cover at least $\frac{1}{k}$ fraction of the remaning uncovered elements $R_i$, so we have $c_{i+1} \ge \frac{R_i}{k}$.</p>
<p>On the other hand, consider  the  conclusion that we want to prove:$C_k  = OPT - R_k \ge (1- (1-\frac{1}{k})^k)\cdot OPT$, that equals to: $R_k \leq (1- \frac{1}{k})^k \cdot OPT$,it is hard to prove it directly, we use  the technique of mathematical induction: $R_i \leq (1- \frac{1}{k})^i \cdot OPT$</p>
<ul>
<li>for i =0, $R_0 \le OPT$, it is true</li>
<li>suppose  i, it is true: $R_i \le (1 - \frac{1}{k})^i\cdot OPT$</li>
<li>when it comes to i+1: $R_{i+1} \leq R_{i} - c_{i+1} \leq R_i - \frac{R_i}{k} = R_i(1- \frac{1}{k}) \le (1- \frac{1}{k})^{i+1}\cdot OPT$</li>
<li>we have proved it!</li>
</ul>
<hr>
<h2 id="Problem-4"><a href="#Problem-4" class="headerlink" title="Problem 4"></a>Problem 4</h2><p>We consider minimum makespan scheduling on parallel identical machines when jobs are subject to <strong>precedence constraints</strong>.</p>
<p>We still want to schedule $n$ jobs $j=1,2,\ldots, n$ on $m$ identical machines, where job $j$ has processing time $p_j$. But now a partial order $\preceq$ is defined on jobs, so that if $j\prec k $ then job $j$ must be completely finished before job $k$ begins. The following is a variant of the <em>List algorithm</em> for this problem: we still assume that the input is a list of $n$ jobs with processing times $p_1,p_2,\ldots, p_n$.</p>
<blockquote>
<p>whenever a machine becomes idle</p>
<p> &emsp;&emsp;assign the next <em>available job</em> on the list to the machine;</p>
</blockquote>
<p>Here a job $k$ is available if all jobs $j\prec k$ have already been completely processed.</p>
<ul>
<li>Prove that the approximation ratio is 2.</li>
</ul>
<hr>
<h3 id="My-Solution-3"><a href="#My-Solution-3" class="headerlink" title="My Solution"></a>My Solution</h3><p><strong>proof</strong>:</p>
<ul>
<li><p>with <strong>precedence constraints</strong>,it is known that:
 $$OPT \ge \max_{\mathcal{A}:i \preceq j}p_{\mathcal{A}}, OPT\ge\frac{1}{m}\sum_{j=1}^np_j$$</p>
</li>
<li><p>with <strong>greedy stratege</strong>,it is known that the max  completion time is less than the sum of the max processing time $p_{max}$ in  precedence constraints and the average processing time $p_{mean}$ among m identical machines, which is:
$$C_{max} \le \max_{\mathcal{A}:i \preceq j}p(\mathcal{A}) + \frac{1}{m}\sum_{j=1}^np_j = 2\cdot OPT$$</p>
</li>
</ul>
<hr>
<h2 id="Problem-5"><a href="#Problem-5" class="headerlink" title="Problem 5"></a>Problem 5</h2><p>For a <strong>hypergraph</strong> $H(V,E)$ with vertex set $V$, every <em>hyperedge</em> $e\in E$ is a subset $e\subset V$ of vertices, not necessarily of size 2. A hypergraph $H(V,E)$ is <strong>k-uniform</strong> if every hyperedge $e\in V$ is of size $k = | e | $.</p>
<p>A <strong>hypergraph</strong> $H(V,E)$ is said to have <strong>property B</strong> (named after Bernstein) if $H$ is 2-coloable; that is, if there is a proper 2-coloring $f:V \to \{ {\color{red}{R},\color{blue}{B}} \}$ which assigns each vertex one of the two colors $\color{red}{Red}$ or $\color{blue}{Blue}$, such that none of the hyperedge is monochromatic.</p>
<ol>
<li><p>Let $H(V,E)$ be a <strong>k-uniform hypergraph</strong> in which every hyperedge $e\in E$ shares vertices with at most d other hyperedges.</p>
<ul>
<li><p>Prove that if $2\mathrm{e}\cdot (d+1)\le 2^{k}$, then $H$ has <strong>property B</strong>.</p>
</li>
<li><p>Describe how to use <strong>Moser’s recursive Fix</strong> algorithm to find a proper <strong>2-coloring</strong> of $H$. Give the pseudocode. Prove the condition in in terms of $d$ and $k$ under which the algorithm can find a 2-coloring of $H$ with high probability.</p>
</li>
<li><p>Describe how to use Moser-Tardos random solver to find a proper 2-coloring of H. Give the pseudocode. Prove the condition in in terms of d and k under which the algorithm can find a 2-coloring of $H$ within bounded expected time. Give an upper bound on the expected running time.</p>
</li>
</ul>
</li>
<li><p>Let $H(V,E)$ be a hypergraph (not necessarily uniform) with at least $n\ge 2 $ vertices satisfying that
$\forall v\in V, \sum_{e\ni v}(1-1/n)^{-|e|}2^{-|e|+1}\le \frac{1}{n}$.</p>
</li>
</ol>
<ul>
<li><p>Prove that $H$ has <strong>property B</strong>.</p>
</li>
<li><p>Describe how to use Moser-Tardos random solver to find a proper 2-coloring of $H$. Give an <u> upper bound </u> on the expected running time.</p>
</li>
</ul>
<hr>
<h3 id="My-Solution-4"><a href="#My-Solution-4" class="headerlink" title="My Solution"></a>My Solution</h3><p>1.<strong>(1)proof</strong>:</p>
<ul>
<li>if $2\mathrm{e}\cdot (d+1)\le 2^{k}$, it equal to $\mathrm{e}\cdot \frac{1}{2^{k-1}} (d+1)\le 1 \qquad(1)$, on the other hand,  the size of each edge $|e| = k$,  let the probability of one edge cannot be  2-coloable in edge $e_i$ is $Pr[e_i]= 2 / 2^k = 1/2^{k-1} \qquad (2)$, it is a bad thing. From the two formulas above, we know that it  meets <code>Lovász Local Lemma</code>  condition . So the probability that not all bad things happen is greater than 0. In our problem, it means H has property B.</li>
</ul>
<p><strong>(2)algorithm</strong>:</p>
<blockquote>
<ul>
<li><p>$\phi$: k-CNF of max degree d with m clauses on n variables, $|e| = m$, for clause $C_i$, bad event $A_i: C_i$ is not satisfied, which is the vertices in edge is colored the same color.</p>
</li>
<li><p>$n$ variables: $x_1,x_2,\ldots,x_n, \ n$ is the total number of vertices, $x_i=\{0,1\}$</p>
</li>
<li><p>For each clause C in φ, we denote by $\mathsf{vbl}(C)\subseteq\mathcal{X}$ the set of variables on which C is defined.</p>
</li>
<li><p>We also abuse the notation and denote by $\Gamma(C)=\{\text{clause }D\text{ in }\phi\mid D\neq C, \mathsf{vbl}(C)\cap\mathsf{vbl}(D)\neq\phi\} $ the neighborhood of <strong>C</strong>, i.e. the set of other clauses in φ that shares variables with C, and $\Gamma^+(C)=\Gamma(C)\cup\{C\}$ the inclusive neighborhood of <strong>C</strong>,</p>
</li>
</ul>
<p><strong>Solve($\phi$)</strong></p>
<ol>
<li><p>Pick values of $x_1,x_2\ldots,x_n$ uniformly and independently at random;</p>
</li>
<li><p>while ∃ unsatisfied clause C  in φ :</p>
</li>
</ol>
<p>&emsp;&emsp;Fix ($C$);</p>
<p><strong>Fix(C):</strong></p>
<ol>
<li><p>Replace the values of variables in $\mathsf{vbl}(C)$ with uniform and independent random values;</p>
</li>
<li><p>while ∃ unsatisfied clause D overlapping with C:</p>
</li>
</ol>
<p>&emsp;&emsp;Fix(D);</p>
</blockquote>
<ul>
<li><strong>proof</strong>:<ul>
<li>first, for the edges number m, we have $m \le 2^{k-1}$, that is $k \ge \log_2^m +1$, the proof is as follows:
the probability of one edge cannot be  2-coloable in edge $e_i$ is $Pr[e_i]= 2 / 2^k = 1/2^{k-1} $, therefore the probability of the bad 2-coloring is:$Pr(\bigwedge_{i=1}^m e_i)\le \sum_{i=1}^mPr(e_i)=\frac{m}{2^{k-1}} \le 1$, so $k \ge \log_2^m +1 \qquad(1)$.</li>
<li>second,  using Moser’s recursive Fix algorithm, there are <strong>m</strong> recursion trees, <strong>t</strong> total nodes, total of random bits is: $n+tk$, the sequence of random bits can be recoverd from <u>final assignment+ reciursion trees, for each recursion tree, the root uses $\left \lceil \log_2m\right \rceil$ bits, each internal node uses at most : $\log_2d + c $ bits</u>,  which is $m\left \lceil \log_2m\right \rceil + t(\log_2d + c)$, with the <strong>Incompressibility Theorem</strong>(N uniform random bits cannot be encoded to substantially less than N bits.), we have $n+tk \le m\left \lceil \log_2m\right \rceil + t(\log_2d + c)$,  and it is equal to $t(k-c-\log_2d \le m\left \lceil \log_2m\right \rceil + \log_2n)$, and $k-c-\log_2d &gt;0$, we get : $d\le 2^{k-c} \qquad(2)$,  with <code>Lovász Local Lemma</code>, we know that $ep(d+1) \leq 1$, and  here is $p = 1/2^{k-1}$, so $d \le \frac{2^{k-1}}{e} - 1\qquad(3)$  ,and the probability the algorithm can find a 2-coloring of H is $n+tk=O(n+km\log_2m)$ .</li>
<li>using (1) ,(2) and (3), we can get the conditions of d and k: $k \ge \log_2^m +1$,$d \le \frac{2^{k-1}}{e} - 1$</li>
</ul>
</li>
</ul>
<p><strong>(3)algorithm</strong>:</p>
<blockquote>
<ul>
<li>$\mathcal{X}$ is a set of mutually independent random variables.</li>
</ul>
<p><strong>RandomSolver:</strong></p>
<ol>
<li><p>sample all $X \in \mathcal{X}$;</p>
</li>
<li><p>while there is non-violated bad event $A \in \mathcal{A}$:</p>
</li>
</ol>
<p>&emsp;&emsp;resample all $X \in vbl(A)$;</p>
</blockquote>
<ul>
<li><strong>proof</strong>:<ul>
<li>from above problem, we know that  $k \ge \log_2^m +1 \qquad(1)$.</li>
<li>with <code>Lovász Local Lemma</code>, we know that $d \le \frac{2^{k-1}}{e} - 1\qquad(2)$</li>
</ul>
</li>
</ul>
<ol>
<li><strong>(1) proof(unsolved)</strong>:</li>
</ol>
<ul>
<li><p>let $k= |e|$, <strong>m</strong> edges, <strong>n</strong> vertices, $n \ge 2$, max degree of dependency graph: <strong>d</strong>, then we have $2(1-1/n) \ge 1$</p>
</li>
<li><p>$\forall v\in V, \frac{1}{n} \geq \sum_{e \ni v}(1-\frac{1}{n})^{-|e|}2^{-|e|+1} = \sum_{e \ni v}2(2(1-1/n))^{-|e|}= 2 \sum_{i=1}^n \frac{k_i}{2(2-1/n)^{k_i}}$</p>
</li>
<li><p>$\forall i, p = \Pr[A_i] \le \frac{2}{2^{\min(k)}} \le \frac{1}{2}, d \le \max(k_i)$</p>
</li>
</ul>
<p><strong>(2) algorithm(unsolved)</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[高级算法(3)--Min-Cut-Max-Flow(2)-近似算法]]></title>
      <url>http://keyunluo.github.io/2016/10/06/2016-10-06-advanced-algorithm-3.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>本节重点讨论Karger’s Contraction algorithm解决最小割问题及其运行复杂度分析。</p>
</blockquote>
<a id="more"></a>
<h2 id="收缩操作"><a href="#收缩操作" class="headerlink" title="收缩操作"></a>收缩操作</h2><p>在上一博客的基础上，讨论收缩操作：</p>
<blockquote>
<p>The contraction operator Contract(G, e) </p>
<p> say e = uv:</p>
<ul>
<li>replace $\{u,v\}$ by a new vertex x;</li>
<li>for every edge (no matter parallel or not) in the form of $uw$ or $vw$ that connects one of $\{u,v\}$ to a vertex $w\in V\setminus\{u,v\}$ in the graph other than $u,v$, replace it by a new edge $xw$;</li>
<li>the reset of the graph does not change.</li>
</ul>
</blockquote>
<p>换句话说，$Contract(G, uv)$就是将和$u,v$合并成一个新的点$x$,其他与新点$x$相邻的点所形成的边都将保存下来，因此，即使原图没有并行边，收缩操作也会产生并行边，所以我们把条件放宽至multi-graph。</p>
<h2 id="Karger’s-algorithm"><a href="#Karger’s-algorithm" class="headerlink" title="Karger’s algorithm"></a>Karger’s algorithm</h2><h3 id="简单的idea"><a href="#简单的idea" class="headerlink" title="简单的idea"></a>简单的idea</h3><ul>
<li><p>在当前的multi-graph中每一步随机选择一条边来收缩直到最终仅剩下两个点为止</p>
</li>
<li><p>这两个点之间的并行边一定是这个原始图的一个Cut</p>
</li>
<li><p>我们返回这个Cut并且希望有很大几率这个Cut是minimum-Cut</p>
</li>
</ul>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><blockquote>
<p>RandomContract (Karger 1993)</p>
<p>Input: multi-graph G(V,E);</p>
<p>while | V | &gt; 2 do</p>
<p>&emsp;&emsp;choose an edge ${uv}\in E$ uniformly at random;</p>
<p>&emsp;&emsp;G = $Contract(G,uv)$;</p>
<p>return C = E (the parallel edges between the only two vertices in V);</p>
</blockquote>
<p>从另一个方面说，顶点集$V=\{v_1,v_2,\ldots,v_n\}$,我们从n个顶点类$ S_1,S_2,\ldots, S_n ，其中每一个S_i = {v_i} $仅包含一个顶点开始，通过调用收缩操作$Contract(G,uv),  u \in S_i and v\in S_j , i \neq j$, 我们使用$S_i \bigcup S_j$操作。</p>
<h3 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h3><p>在上述RandomContract算法中，一共有$n-2$个收缩操作，每一个收缩操作可以在$O(n)$时间内完成，因此，时间上限是：$O(n^2)$</p>
<h2 id="精度分析"><a href="#精度分析" class="headerlink" title="精度分析"></a>精度分析</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><strong>约定</strong>：$ e_1,e_2,\ldots,e_{n-2} $ 为运行<em>RandomContract Algorithm</em>随机选择的边，$G_1 = G$为原始的输入multi-graph,$G_{i + 1} = Contract(G_i,e_i) ,i = 1,2, \ldots, n-2$, $C$是multi-graph $G$ 中的最小割， $p_C=Pr[C\ is\  returned \  by \  RandomContract]$。</p>
<blockquote>
<p><strong>命题1</strong>：如果：$e \notin C$，那么$C$仍然是multi-graph $G^{‘} = contract(G,e)$的一个最小割</p>
</blockquote>
<p>基于上述命题，事件$ \mbox{“}C\mbox{ is returned by }RandomContract\mbox{”}\,$等价于事件$“ e_i \notin C , for\ all\ i=1,2,\ldots,n-2 ”$，因此，根据条件概率中的链式规则，可以得到如下等式：</p>
<p>$$\begin{array} {lcl}
p_C  &amp; = &amp; Pr[ C\ is\ returned\ by\ RandomContract] \\
      &amp; = &amp; Pr[e_i \notin C for\ all\ i = 1,2,\ldots, n-2] \\
      &amp; = &amp; \prod_{i=1}^{n-2}Pr[ e_i \notin C \vert \forall j &lt; i, e_j \notin C]
\end{array}$$</p>
<p>即前i-1个边都不在C中，第i个边在上述条件发生的情况下也不在C中，下面考虑上式的上界：</p>
<blockquote>
<p><strong>命题2</strong>:如果 C 是multi-graph $G(V,E)$中的一个最小割，那么其满足如下约束条件：$degree(G)=2|E|/|V| \geq |C|$，即C的度数小于等于平均每个点的度数。</p>
</blockquote>
<p>已知，$|V_i| = n -i +1， p_i = Pr[e_i \notin C \vert \forall j &lt; i, e_j \notin C]$,根据命题2，可得：</p>
<p>$$\begin{array} {lcl}
p_i  &amp; = &amp; 1 - \frac{\vert C \vert}{\vert E_i \vert} \\
      &amp; \geq &amp; 1 - \frac{2}{|V_i|} \\
      &amp; = &amp; 1- \frac{2}{n-i+1}
\end{array}$$</p>
<p>因此，得到最终结果：</p>
<p>$$\begin{array} {lcl}
p_{\text{correct}} &amp; = &amp; \Pr[\,\text{a minimum cut is returned by }RandomContract\,]\\
                    &amp; \geq &amp; \Pr[\,C\mbox{ is returned by }{RandomContract}\,]\\
                    &amp; = &amp; \Pr[\,e_i\not\in C\mbox{ for all }i=1,2,\ldots,n-2\,]\\
                    &amp; = &amp; \prod_{i=1}^{n-2}\Pr[e_i\not\in C\mid \forall j&lt;i, e_j\not\in C]\\
                    &amp; \geq &amp; \prod_{i=1}^{n-2}\left(1-\frac{2}{n-i+1}\right)\\
                    &amp; = &amp; \prod_{k=3}^{n}\frac{k-2}{k}\\
                    &amp; = &amp; \frac{2}{n(n-1)}.
\end{array}$$</p>
<h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><blockquote>
<p><strong>定理</strong>：对于任意具有n个顶点的多图，随机收缩算法返回一个最小割的概率至少是$\frac{2}{n(n-1)}$,当我们独立地运行$t=\frac{n(n-1)\ln n}{2}$次时，一个最小割被找到的概率为：
$$\begin{array} {lcl}
&amp;\quad &amp; 1-\Pr[\,\mbox{all }t\mbox{ independent runnings of } RandomContract\mbox{ fails to find a min-cut}\,] \\
&amp; = &amp; 1-\Pr[\,\mbox{a single running of }{RandomContract}\mbox{ fails}\,]^{t} \\
&amp; \geq &amp; 1- \left(1-\frac{2}{n(n-1)}\right)^{\frac{n(n-1)\ln n}{2}} \\
&amp; \geq &amp; 1-\frac{1}{n}.
\end{array}$$</p>
</blockquote>
<p>随机收缩算法时间复杂度为$O(n^2)$,所以总的时间复杂度为：$O(n^4\log n)$</p>
<h3 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h3><p>根据上述定理，一个随机收缩算法找到一个正确的最小割的概率至少是$\frac{2}{n(n-1)}$，则最小割至多有$\frac{n(n-1)}{2}$个。</p>
<h2 id="Fast-Min-Cut"><a href="#Fast-Min-Cut" class="headerlink" title="Fast Min-Cut"></a>Fast Min-Cut</h2><p>在随机收缩算法中，$p_C \ge\prod_{i=1}^{n-2}\left(1-\frac{2}{n-i+1}\right).$,随着i增加$\left(1-\frac{2}{n-i+1}\right)$值减小，这就意味着成功的概率会随着收缩程度的增加而不断减小，此时剩余的点变少。</p>
<p>因此，我们考虑如下的分段算法：首先使用随机收缩算法减少顶点的个数到一个相当小的程度，然后在每一个小的实例里寻找最小割，这样的算法称为FastCut。</p>
<h3 id="FastCut算法"><a href="#FastCut算法" class="headerlink" title="FastCut算法"></a>FastCut算法</h3><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul>
<li>预处理算法：RandomContract</li>
</ul>
<blockquote>
<p>RandomContract(G,t)</p>
<p>Input: multi-graph $G(V,E)$, and integer $t \ge 2$;
while $| V | &gt; t$ do</p>
<ul>
<li>choose an edge ${uv}\in E$ uniformly at random;</li>
<li>$G = Contract(G,uv)$;
return $G$;</li>
</ul>
</blockquote>
<ul>
<li>FastCut算法</li>
</ul>
<blockquote>
<p>FastCut(G)</p>
<p>Input: multi-graph $G(V,E)$;</p>
<p>if $|V|\le 6$ then return a mincut by brute force;</p>
<p>else let $t=\left\lceil1+|V|/\sqrt{2}\right\rceil$;</p>
<ul>
<li>$G_1$ = $RandomContract(G,t)$;</li>
<li>$G_2$ = $RandomContract(G,t)$;</li>
<li>return the smaller one of $FastCut(G_1)$ and $FastCut(G_2)$;</li>
</ul>
</blockquote>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><strong>随机收缩过程</strong>：</p>
<p>$$\begin{array} {lcl}
&amp;\quad &amp; \Pr[C\text{ survives all contractions in }RandomContract(G,t)]\\
&amp; = &amp; \prod_{i=1}^{n-t}\Pr[C\text{ survives the }i\text{-th contraction}\mid C\text{ survives the first }(i-1)\text{-th contractions}]\\
&amp; \ge &amp; \prod_{i=1}^{n-t}\left(1-\frac{2}{n-i+1}\right)\\
&amp; = &amp; \prod_{k=t+1}^{n}\frac{k-2}{k}\\
&amp; = &amp; \frac{t(t-1)}{n(n-1)}.
\end{array}$$</p>
<p>当$t=\left\lceil1+n/\sqrt{2}\right\rceil$, 上式概率至少是$ 1 / 2$</p>
<p><strong>FastCut过程</strong>:</p>
<p>p(n)为C被FastCut(G)返回的概率：</p>
<p>$$\begin{array} {lcl}
p(n) &amp; = &amp; \Pr[C\text{ is returned by }\textit{FastCut}(G)]\\
     &amp; = &amp; 1-\left(1-\Pr[C\text{ survives in }G_1\wedge C=\textit{FastCut}(G_1)]\right)^2\\
     &amp; = &amp; 1-\left(1-\Pr[C\text{ survives in }G_1]\Pr[C=\textit{FastCut}(G_1)\mid C\text{ survives in }G_1]\right)^2\\
     &amp; \ge &amp; 1-\left(1-\frac{1}{2}p\left(\left\lceil1+n/\sqrt{2}\right\rceil\right)\right)^2,
\end{array}$$</p>
<p>基本案例是$ p(n) = 1\ for\ n\le 6.$</p>
<p>$$p(n)=\Omega\left(\frac{1}{\log n}\right).$$</p>
<p>时间复杂度为：</p>
<p>$$T(n)=2T\left(\left\lceil1+n/\sqrt{2}\right\rceil\right)+O(n^2),$$</p>
<p>$T(n) = O(1)\ for\ n\le 6$, 因此$ T(n) = O(n^2logn)$.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[高级算法(2)--Min-Cut-Max-Flow(1)-确定性算法]]></title>
      <url>http://keyunluo.github.io/2016/10/05/2016-10-05-advanced-algorithm-2.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>对于一个图中的两个节点来说，如果把图中的一些边去掉，刚好让他们之间无法连通的话，这些被去掉的边组成的集合就叫做割了，最小割就是指所有割中权重之和最小的一个割。</p>
</blockquote>
<a id="more"></a>
<h2 id="图的割"><a href="#图的割" class="headerlink" title="图的割"></a>图的割</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>对于无向图 $G(V,E)$ 以及边的子集 $C \subseteq E$, 如果把C中所有的边都删除后图G不再连通则称边的子集C是图G的一个割。更加严格地，我们考虑割集断开了图的剩余部分的顶点的一个子集S。</p>
<p>一对不相交集合： $S,T \subseteq V$ 如果S和T不为空，并且$S \bigcup T = V$成立，那么S,T称作V的二划分。</p>
<p>给定一个顶点V的二划分 $\{S,T\}$，一个割集C定义如下：</p>
<p>$$C = E(S,T), 其中 E(S,T) = \{ uv \in E \vert u \in S , v \in T \}$$</p>
<p>对于一个图G，割可能有很多个，我们对找出最小的割集和最大的割集感兴趣。</p>
<h3 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h3><blockquote>
<p>输入：无向图 $G(V,E)$ , 输出：一个G中边数最小的割C。</p>
</blockquote>
<p>也就是说，将顶点集合$V$二划分成两个不相交的非空集合$\{S，T\}$，使得 $E|(S,T)|$ 最小。</p>
<p>更一般地，允许点$(u,v)$之间存在不止一条边，即并行边，这样的图称为<strong>multi-graphs</strong>,此时割C包括并行边。</p>
<h2 id="流网络"><a href="#流网络" class="headerlink" title="流网络"></a>流网络</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>流网络（Flow Networks）指的是一个有向图 $G = (V, E)$，其中每条边 $(u, v) ∈ E$ 均有一非负容量 $c(u, v) ≥ 0$。如果 $(u, v) ∉ E$ 则可以规定 $c(u, v) = 0$。流网络中有两个特殊的顶点：源点 s （source）和汇点 t（sink）。为方便起见，假定每个顶点均处于从源点到汇点的某条路径上，就是说，对每个顶点 $v ∈ E$，存在一条路径 s –&gt; v –&gt; t。因此，图 G 为连通图，且 $|E| ≥ |V| - 1$。</p>
<h3 id="流-Flow-的基本性质"><a href="#流-Flow-的基本性质" class="headerlink" title="流(Flow)的基本性质"></a>流(Flow)的基本性质</h3><p>设$C_{uv}$代表边u到v最大允许流量(Capacity), $f_{uv}$代表u到v的当前流量, 那么有一下两个性质:</p>
<ul>
<li><p>$(u, v)$为有向图边, $0 \leq f_{uv} \leq C_{uv}$, 即对于所有的边, 当前流量不允许超过其Capacity</p>
</li>
<li><p>除了$s, t$之外, 对所有节点有 $\sum\limits_{(v, u)}f_{wu} = \sum\limits_{(u, v)}f_{uv}$, 即对于任何一点, 流入该点的流量等于留出该点的流量, 流量守恒原则(类似与能量守恒的概念)。</p>
</li>
</ul>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul>
<li><p>残存网络 ：给定网络G和流量f, 残存网络$G_f$由那些仍有空间对流量进行调整的边构成.<strong>残存网络 = 容量网络capacity - 流量网络flow</strong>。</p>
</li>
<li><p>增广路径：增广路径p是残存网络中一条从源节点s到汇点t的简单路径,在一条增广路径p上能够为每条边增加的流量的最大值为路径p的残存容量$c_f(p) = min {c_f(u,v):(u,v) \in p }$。 在一条增广路径p上, 要增加整条增广路径的水流量, 则必须看最小能承受水流量的管道, 不然水管会爆掉, 这最小承受水流量就是<strong>残存容量</strong>。</p>
</li>
</ul>
<h3 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h3><p>流的值定义为：$|f| =Σ_{v∈V}f(s, v)$，即从源点 s 出发的总流。</p>
<p>最大流问题（Maximum-flow problem）中，给出源点 s 和汇点 t 的流网络 G，希望找出从 s 到 t 的最大值流。</p>
<h2 id="最小割最大流定理"><a href="#最小割最大流定理" class="headerlink" title="最小割最大流定理"></a>最小割最大流定理</h2><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>如果 f 是具有源点 s 和汇点 t 的流网络 $G = (V, E)$ 中的一个流，则下列条件是等价的：</p>
<ul>
<li><p>f 是 G 的一个最大流。</p>
</li>
<li><p>残留网络 $G_f$ 不包含增广路径。</p>
</li>
<li><p>对 G 的某个割 (S, T)，有 |f| = c(S, T)。</p>
</li>
</ul>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul>
<li><p>min=MAXINT,确定一个源点</p>
</li>
<li><p>枚举汇点</p>
</li>
<li><p>计算最大流，并确定当前源汇的最小割集，若比min小更新min</p>
</li>
<li><p>转到2直到枚举完毕</p>
</li>
<li><p>min即为所求，输出min</p>
</li>
</ul>
<p>不难看出复杂度很高：枚举汇点要$O(n)$，最短增广路最大流算法求最大流是$O((n^2)m)$复杂度，在复杂网络中$O(m)=O(n^2)$，算法总复杂度就是$O(n^5)$；哪怕采用最高标号预进流算法求最大流$O((n^2)(m^{0.5}))$，算法总复杂度也要$O(n^4)$</p>
<h2 id="最小割的确定性算法"><a href="#最小割的确定性算法" class="headerlink" title="最小割的确定性算法"></a>最小割的确定性算法</h2><p>目前已知最好的求最小割的确定性算法是<strong> Stoer–Wagner algorithm</strong> $(O(mn + n^2\log n), m=|E|)$,包含并行边</p>
<h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h3><p>1.min=MAXINT，固定一个顶点P</p>
<p>2.从点P用“类似”prim的s算法扩展出“最大生成树”，记录最后扩展的顶点和最后扩展的边</p>
<p>3.计算最后扩展到的顶点的切割值（即与此顶点相连的所有边权和），若比min小更新min</p>
<p>4.合并最后扩展的那条边的两个端点为一个顶点（当然他们的边也要合并，这个好理解吧？）</p>
<p>5.转到2，合并N-1次后结束</p>
<p>6.min即为所求，输出min</p>
<p>prim本身复杂度是$O(n^2)$，合并n-1次，算法复杂度即为$O(n^3)$</p>
<p>如果在prim中加堆优化，复杂度会降为$O((n^2)logn)$</p>
<p>其核心思想是迭代缩小规模, 算法基于这样一个事实:</p>
<blockquote>
<p>对于图中任意两点s和t, 它们要么属于最小割的两个不同集中, 要么属于同一个集.</p>
</blockquote>
<p>如果是后者, 那么合并s和t后并不影响最小割. 基于这么个思想, 如果每次能求出图中某两点之间的最小割, 然后更新答案后合并它们再继续求最小割, 就得到最终答案了. 算法步骤如下:</p>
<ol>
<li><p>设最小割cut=INF, 任选一个点s到集合A中, 定义W(A, p)为A中的所有点到A外一点p的权总和.</p>
</li>
<li><p>对刚才选定的s, 更新W(A,p)(该值递增).</p>
</li>
<li><p>选出A外一点p, 且W(A,p)最大的作为新的s, 若A!=G(V), 则继续2.</p>
</li>
<li><p>把最后进入A的两点记为s和t, 用W(A,t)更新cut.</p>
</li>
<li><p>新建顶点u, 边权w(u, v)=w(s, v)+w(t, v), 删除顶点s和t, 以及与它们相连的边.</p>
</li>
<li><p>若|V|!=1则继续1.</p>
</li>
</ol>
<p>一个很详细的博客<a href="http://blog.coolstack.cc/2016/01/08/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE%EF%BC%9A%E6%97%A0%E5%90%91%E5%9B%BE%E5%85%A8%E5%B1%80%E6%9C%80%E5%B0%8F%E5%89%B2/" target="_blank" rel="external">朝花夕拾：无向图全局最小割</a></p>
<h3 id="基本步骤："><a href="#基本步骤：" class="headerlink" title="基本步骤："></a>基本步骤：</h3><p>用wage数组记录点的连通度，vis数组标记点是否在集合里面，In数组表示点被其它点合并。</p>
<ul>
<li><p>一：找到S - T的最小割Mincut，其中S 和 T为最后并入集合的两个点。</p>
<ul>
<li><p>1，初始化数组vis 和 wage；</p>
</li>
<li><p>2，遍历所有不在集合且没有被合并的点，找到最大wage值的点Next，并记录Mincut、S和T；</p>
</li>
<li><p>3，Next并入集合，叠加与Next相连的所有点（不在集合 且 没有被合并），更新这些点的wage值；</p>
</li>
<li><p>4，重复操作2和3一共N次 或者 找不到新的Next值时 跳出，返回Mincut；</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>二、找全局最小割ans，需要重复第一步N-1次，因为每次合并一个点，最多合并N-1个点；</p>
<ul>
<li><p>1，每次对返回的Mincut，更新ans = min(ans, Mincut)，当然ans为0时，说明图不连通；</p>
</li>
<li><p>2，把点T合并到S点，操作有：对 所有没有被合并的点j，Map[S][j] += Map[T][j]。</p>
</li>
</ul>
</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>来自<a href="http://blog.csdn.net/i_love_home/article/details/9698791" target="_blank" rel="external">CSDN博客</a></p>
<p>步骤: <img src="/resource/blog/2016-10/mincut.jpg" alt="寻找 s, t 两点，然后合并于 s 点"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 500+10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> Map[MAXN][MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];<span class="comment">//是否已并入集合</span></span><br><span class="line"><span class="keyword">int</span> wage[MAXN];<span class="comment">//记录每个点的连通度</span></span><br><span class="line"><span class="keyword">bool</span> In[MAXN];<span class="comment">//该点是否已经合并到其它点</span></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMap</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Map, <span class="number">0</span>, <span class="keyword">sizeof</span>(Map));</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        a++, b++;</span><br><span class="line">        Map[a][b] += c;</span><br><span class="line">        Map[b][a] += c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> S, T;<span class="comment">//记录每次找s-t割  所遍历的最后两个点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Mincut;<span class="comment">//每一步找到的s-t割</span></span><br><span class="line">    <span class="built_in">memset</span>(wage, <span class="number">0</span>, <span class="keyword">sizeof</span>(wage));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">int</span> Next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> Max = -INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!In[j] &amp;&amp; !vis[j] &amp;&amp; Max &lt; wage[j])<span class="comment">//找最大的wage值</span></span><br><span class="line">            &#123;</span><br><span class="line">                Next = j;</span><br><span class="line">                Max = wage[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Next == T) <span class="keyword">break</span>;<span class="comment">//找不到点 图本身不连通</span></span><br><span class="line">        vis[Next] = <span class="literal">true</span>;<span class="comment">//标记 已经并入集合</span></span><br><span class="line">        Mincut = Max;<span class="comment">//每次更新</span></span><br><span class="line">        S = T, T = Next;<span class="comment">// 记录前、后点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++)<span class="comment">//继续找不在集合 且 没有被合并过的点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(In[j] || vis[j]) <span class="keyword">continue</span>;</span><br><span class="line">            wage[j] += Map[Next][j];<span class="comment">//累加 连通度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Mincut;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stoer_wagner</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(In, <span class="literal">false</span>, <span class="keyword">sizeof</span>(In));</span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = min(ans, work());</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//本身不连通</span></span><br><span class="line">        In[T] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++)<span class="comment">//把T点合并到S点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(In[j]) <span class="keyword">continue</span>;<span class="comment">//已经合并</span></span><br><span class="line">            Map[S][j] += Map[T][j];</span><br><span class="line">            Map[j][S] += Map[j][T];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        getMap();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Stoer_wagner());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[高级算法(1)--NP完全性与近似算法]]></title>
      <url>http://keyunluo.github.io/2016/10/04/2016-10-04-advanced-algorithm-1.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>本学期修读了尹一通老师的高级算法课，感觉略有困难，故将学习过程中的知识点以博客的形式记录下来，温故而知新，本节总结NP完全性问题和近似算法的概念。</p>
</blockquote>
<a id="more"></a>
<h2 id="NP完全理论"><a href="#NP完全理论" class="headerlink" title="NP完全理论"></a>NP完全理论</h2><p>NP理论如下：</p>
<ul>
<li><p><strong>多项式时间</strong>：一个问题的计算时间m(n)不大于问题大小n的多项式倍数。</p>
</li>
<li><p><strong>判定问题</strong>：判定某类问题是否具有算法解，或者是否存在能行性的方法使得对该问题类中的每一个特例能在有限步内机械地判定它是否具有某种性质的问题。</p>
</li>
<li><p><strong>P类问题</strong>：在多项式时间内求解的判定问题构成P类问题。</p>
</li>
<li><p><strong>非确定性算法</strong>：非确定性算法将问题分解成猜测和验证两个阶段。算法的猜测阶段是非确定性的，算法的验证阶段是确定性的，它验证猜测阶段给出解的正确性。</p>
</li>
<li><p><strong>NP类问题</strong>：非确定性多项式时间可解的判定问题构成NP类问题。</p>
</li>
<li><p><strong>NPC问题</strong>：NP中的某些问题的复杂性与整个类的复杂性相关联。这些问题中任何一个如果存在多项式时间的算法,那么所有NP问题都是多项式时间可解的。</p>
</li>
<li><p><strong>NPH问题</strong>：某个问题被称作NP困难，当所有NP问题可以在多项式时间归约到这个问题。</p>
</li>
</ul>
<p>它们之间的关系：</p>
<p>$$P \subseteq NP, NPC \subseteq NP, NPC \subseteq NPH$$</p>
<h2 id="近似算法"><a href="#近似算法" class="headerlink" title="近似算法"></a>近似算法</h2><p>在计算复杂性理论中的某些假设下，比如最著名的 $ P\neq NP  $假设下，对于一些可已被证明为NP完全的优化问题，无法在多项式时间内精确求到最优解，然而在现实或理论研究中，这类问题都有广泛的应用，在精确解无法得到的情况下，转而依靠高效的近似算法求可以接受的近似解。</p>
<h3 id="近似比"><a href="#近似比" class="headerlink" title="近似比"></a>近似比</h3><p>对于一个最大化问题的实例，设其最优解是 $ OPT $，某个近似算法的解是 $x$，若下式成立，</p>
<p>$$\alpha \leq \frac{x}{OPT} \leq 1 $$</p>
<p>其中 $ 0&lt;\alpha &lt;1 $ 则定义此近似算法的近似比为 $ \alpha $。</p>
<p>相应的，对于一个最小化问题的实例，</p>
<p>$$\alpha \geq \frac{x}{OPT} \geq 1 $$</p>
<p>其中 $\alpha &gt;1$则定义此近似算法的近似比为 $ \alpha $。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>按照可以达到近似比的不同，可以将近似算法大致按以下分类：</p>
<ul>
<li><p>FPTAS(Fully Polynomial-Time Approximation Scheme):FPTAS要求算法对问题规模n和1/ε都是多项式时间复杂度的，称为完全多项式时间近似模式，如$O((1/ε)^2n^3)$。</p>
</li>
<li><p>PTAS(Polynomial-Time Approximation Scheme):该算法的输入为问题的实例以及一个任意小的值ε &gt; 0，而算法的结果是一个近似度为 1 + ε的可行解；并且对于每一个固定的ε，算法运行时间复杂度对于实例的规模n是多项式时间的,如$O(n^{2/ε})$。</p>
</li>
<li><p>常数近似</p>
</li>
<li><p>对数的多项式</p>
</li>
<li><p>多项式</p>
</li>
</ul>
<p>其中对数的多项式和多项式都是对应于输入规模的。</p>
<h3 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h3><p>近似算法的常用设计方法有贪心法，线性规划、半正定规划的松弛和取整，随机算法等。</p>
<h2 id="课程网站"><a href="#课程网站" class="headerlink" title="课程网站"></a>课程网站</h2><p><a href="http://tcs.nju.edu.cn/wiki/index.php/%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95_%5C_%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95_(Fall_2016%29" target="_blank" rel="external">随机算法/高级算法</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu16.04上编译OpenCV的Python3包]]></title>
      <url>http://keyunluo.github.io/2016/10/04/2016-10-04-ubuntu16.04-opencv3-python3.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>本篇博文记录在Ubuntu16.04上安装OpenCV。</p>
</blockquote>
<a id="more"></a>
<h2 id="安装依赖软件"><a href="#安装依赖软件" class="headerlink" title="安装依赖软件"></a>安装依赖软件</h2><p>从源代码编译时需要很多第三方软件，因此首先需要在系统中安装这些库，具体如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential cmake cmake-gui git libjpeg-dev libpng-dev       \</span><br><span class="line">libtiff5-dev libjasper-dev libavcodec-dev libavformat-dev libswscale-dev pkg-config   \</span><br><span class="line">libgtk2<span class="number">.0</span>-dev libeigen3-dev libtheora-dev libvorbis-dev libxvidcore-dev libx264-dev   \</span><br><span class="line">sphinx-common libtbb-dev yasm libfaac-dev libopencore-amrnb-dev libopencore-amrwb-dev \</span><br><span class="line">libopenexr-dev libgstreamer-plugins-base1<span class="number">.0</span>-dev libavcodec-dev libavutil-dev \</span><br><span class="line">libavfilter-dev libavformat-dev libavresample-dev libgphoto2-dev libhdf5-mpi-dev \</span><br><span class="line">libhdf5-openmpi-dev libhdf5-mpich-dev</span><br></pre></td></tr></table></figure>
<p>安装好这些库后便可以从<code>github</code>上<code>clone</code>最新的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line">git clone --branch 3.1.0 --depth 1 https://github.com/Itseez/opencv.git</span><br><span class="line">git clone --branch 3.1.0 --depth 1 https://github.com/itseez/opencv_contrib</span><br></pre></td></tr></table></figure>
<p>建立编译目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd opencv &amp;&amp; mkdir release</span><br><span class="line">cd release</span><br></pre></td></tr></table></figure>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>接上，若使用Anaconda Python，则指定Python库所在的位置，这里是<code>/usr/local/anaconda3/lib/libpython3.5m.so</code>：在终端下运行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cmake -D OPENCV_EXTRA_MODULES_PATH=../../opencv_contrib/modules/  -DBUILD_TIFF=ON \</span><br><span class="line">-DBUILD_opencv_java=ON -DWITH_CUDA=OFF -DENABLE_AVX=ON -DWITH_OPENGL=ON -DWITH_OPENCL=ON \</span><br><span class="line">-DWITH_IPP=ON -DWITH_TBB=ON -DWITH_EIGEN=ON -DWITH_V4L=ON -DBUILD_TESTS=OFF \</span><br><span class="line">-DBUILD_PERF_TESTS=OFF -DCMAKE_BUILD_TYPE=RELEASE -DCMAKE_INSTALL_PREFIX=$(python3 -c <span class="string">"import sys; print(sys.prefix)"</span>) \</span><br><span class="line">-DPYTHON_EXECUTABLE=$(which python3) \</span><br><span class="line">-DPYTHON_INCLUDE_DIR=$(python3 -c <span class="string">"from distutils.sysconfig import get_python_inc; print(get_python_inc())"</span>) \</span><br><span class="line">-DPYTHON_PACKAGES_PATH=$(python3 -c <span class="string">"from distutils.sysconfig import get_python_lib; print(get_python_lib())"</span>) \</span><br><span class="line">-DPYTHON_LIBRARY=/usr/local/anaconda3/lib/libpython3<span class="number">.5</span>m.so ..</span><br></pre></td></tr></table></figure>
<p>没有报错后，接着便<code>make</code>和<code>make install</code> :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make </span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>安装完成后，测试是否安装成功:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line">x = cv2.bgsegm.createBackgroundSubtractorGMG()</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据压缩(1) —— 概述]]></title>
      <url>http://keyunluo.github.io/2016/09/24/2016-09-24-compress-1.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong> 数据压缩，是指在不丢失信息的前提下，缩减数据量以减少存储空间，提高传输、存储和处理效率的一种技术方法。或者是按照一定的算法对数据进行重新组织，减少数据的冗余和存储的空间。本系列博文具体学习经典的压缩算法以及最近流行的算法，并应用到FASTQ下一代基因数据的压缩过程中。</p>
</blockquote>
<a id="more"></a>
<h2 id="压缩技术"><a href="#压缩技术" class="headerlink" title="压缩技术"></a>压缩技术</h2><p>压缩，是为了减少存储空间而把数据转换成比原始格式更紧凑形式的过程。能实现数据压缩的本质原因就是数据的冗余性。</p>
<h3 id="无损压缩"><a href="#无损压缩" class="headerlink" title="无损压缩"></a>无损压缩</h3><p>无损压缩是指使用压缩后的数据进行重构(或者叫做还原，解压缩)，重构后的数据与原来的数据完全相同；无损压缩用于要求重构的信号与原始信号完全一致的场合。一个很常见的例子是磁盘文件的压缩。根据目前的技术水平，无损压缩算法一般可以把普通文件的数据压缩到原来的1/2～1/4。一些常用的无损压缩算法有霍夫曼(Huffman)算法和LZW(Lenpel-Ziv &amp; Welch)压缩算法。</p>
<h3 id="有损压缩"><a href="#有损压缩" class="headerlink" title="有损压缩"></a>有损压缩</h3><p>有损压缩是指使用压缩后的数据进行重构，重构后的数据与原来的数据有所不同，但不会让人对原始资料表达的信息造成误解。有损压缩适用于重构信号不一定非要和原始信号完全相同的场合。例如，图像和声音的压缩就可以采用有损压缩，因为其中包含的数据往往多于我们的视觉系统和听觉系统所能接收的信息，丢掉一些数据而不至于对声音或者图像所表达的意思产生误解，但可大大提高压缩比。</p>
<h3 id="性能测量"><a href="#性能测量" class="headerlink" title="性能测量"></a>性能测量</h3><ul>
<li><p>压缩比：压缩前后数据文件的大小比较</p>
</li>
<li><p>压缩/解压时间：压缩/解压缩文件所需要的时间</p>
</li>
<li><p>并行化：利用多核CPU或多线程实现加速</p>
</li>
<li><p>失真： 有损压缩中原数据与重构结果之间的差别</p>
</li>
</ul>
<h2 id="信息论与熵编码"><a href="#信息论与熵编码" class="headerlink" title="信息论与熵编码"></a>信息论与熵编码</h2><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>信息的定义是度量一个数据片段复杂度的量。一个数据集拥有越多的信息，它就越难被压缩。稀有的概念和信息的概念是相关的，因为稀有符号的出现比常见符号的出现提供了更多的信息。</p>
<p>我们把压缩算法降低信息负载的有效性，称为它的效率。一个效率更高的压缩算法相比效率低的压缩算法，能够更多地降低特定数据集的大小。</p>
<h3 id="概率模型"><a href="#概率模型" class="headerlink" title="概率模型"></a>概率模型</h3><p>设计一个压缩方案的最重要一步，是为数据创建一个概率模型。这个模型允许我们测量数据的特征，达到有效的适应压缩算法的目的。</p>
<h3 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h3><p>熵定义为给定模型的最小编码率，它建立在字母表和它的概率模型之上：</p>
<p>$$H(G,P) =  - \sum_{i=0}^nP(X_i)\log_2(P(X_i))  X_i \in G $$</p>
<p>拥有更多罕见符号的模型，比拥有较少并且常见符号的模型的熵要高。更进一步，熵值更高的模型比熵值低的模型更难压缩。</p>
<h2 id="编码实例"><a href="#编码实例" class="headerlink" title="编码实例"></a>编码实例</h2><h3 id="Huffman压缩算法"><a href="#Huffman压缩算法" class="headerlink" title="Huffman压缩算法"></a>Huffman压缩算法</h3><p>huffman压缩算法可以说是无损压缩中最优秀的算法。它使用预先二进制描述来替换每个符号，长度由特殊符号出现的频率决定。其中出现次数比较多的符号需要很少的位来表示，而出现次数较少的符号则需要较多的位来表示。</p>
<p>huffman压缩算法的原理：利用数据出现的次数构造Huffman二叉树，并且出现次数较多的数据在树的上层，出现次数较少的数据在树的下层。于是，我们就可以从根节点到每个数据的路径来进行编码并实现压缩。</p>
<p>如：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>概率</th>
<th>码子</th>
</tr>
</thead>
<tbody>
<tr>
<td>B</td>
<td>0.4</td>
<td>0</td>
</tr>
<tr>
<td>D</td>
<td>0.3</td>
<td>10</td>
</tr>
<tr>
<td>A</td>
<td>0.2</td>
<td>110</td>
</tr>
<tr>
<td>C</td>
<td>0.1</td>
<td>111</td>
</tr>
</tbody>
</table>
<p>平均编码率显著地降低到了1.9比特/符号.</p>
<h3 id="字典方法"><a href="#字典方法" class="headerlink" title="字典方法"></a>字典方法</h3><p>这种类型的编码器使用一个字典来保存最近发现的符号。当遇到一个符号时，首先会在字典中查找它，检查是否已经存储过了。如果是，那么输出将只包含字典入口的引用（通常是一个偏移量），而不是整个符号。</p>
<p>使用字典方法的压缩方案包括LZ77 and LZ78，它们是很多不同的无损压缩方案的基础。</p>
<p>在一些情况下，会使用一个滑动窗口来自适应地追踪最近发现的符号。这种情况下，一个符号只在相对较近发现时才会保存在字典中。否则，符号被剔除（之后再出现可能会重新加入字典）。这个过程防止符号字典变得过大，并利用了一个事实，即序列中的符号会在相对短的窗口内重复出现。</p>
<h3 id="算术编码"><a href="#算术编码" class="headerlink" title="算术编码"></a>算术编码</h3><p>算术编码是一种无损数据压缩方法，也是一种熵编码的方法。和其它熵编码方法不同的地方在于，其他的熵编码方法通常是把输入的消息分区为符号，然后对每个符号进行编码，而算术编码是直接把整个输入的消息编码为一个数，一个满足(0.0 ≤ n &lt; 1.0)的小数n。</p>
<h3 id="游程编码"><a href="#游程编码" class="headerlink" title="游程编码"></a>游程编码</h3><p>统计某一节字节在整个字节表中出现的次数，并以该字节和出现的次数作为编码的依据。</p>
<p>如：输入字符<code>ASSDDRRZZZZZO</code> =&gt; <code>A1S2D2R2Z5O1</code></p>
<p>对于上述方法，有人提出：如果字节表中出现连续不重复的数据，就会因为设置太多的字节次数为而达不到压缩的效果。
再想的坏一点，如果字符表中的各个字符只出现一次，也就是全部不重复，那么经过RLE编码之后，不仅没有实现压缩，
反倒是增加了一倍。比如“ABCDEFG”，如果用上述方法，那么经过压缩后应为：A1B1C1D1E1F1G1，针对上述问题，
人们对算法做了一些改进。</p>
<p>改进算法的核心思想是：我们知道一个字节是八位，那么用最高位来当做一个标志位，这个标志位如果为1，
则表示后面跟的是重复的数据，如果为0则表示后面跟的是非重复的数据；我们用低七位来表示这个数据重复的次数。
用下一个字节来表示这个字节数据。</p>
<p>如输入<code>AAABBBBBCABCDDD</code>=&gt;<code>0X83 A 0X85 B 0X41 C A B C 0X83 D</code></p>
<h3 id="增量编码"><a href="#增量编码" class="headerlink" title="增量编码"></a>增量编码</h3><p>对于给定一系列增量数字，如<code>[0,1,2,3,4,5,6,7]</code> =&gt; <code>[0,1,1,1,1,1,1,1]</code>,熵减为1</p>
<h3 id="符号分组"><a href="#符号分组" class="headerlink" title="符号分组"></a>符号分组</h3><p>S = <code>&quot;TOBEORNOTTOBEORTOBEORNOT&quot;</code> =&gt; <code>[TO,BE,OR,NOT]</code> , H(S)=1.98</p>
<h3 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h3><p>B <code>[5, 7, 1, 4, 6, 3, 2, 0]</code>是<code>[0,1,2,3,4,5,6,7]</code>的一个排列，对其采用擦除码(Elimination Coding)编码，结果如下：</p>
<p><img src="/resource/blog/2016-09/escode.png" alt="擦除码实例"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[统计学习方法——决策树]]></title>
      <url>http://keyunluo.github.io/2016/09/23/2016-09-23-statical-learning-5.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>决策树(decision tree)是一种基本的分类与回归方法。决策树模型呈树形结构，其主要优点是模型具有可读性，分类速度快，学习时，利用训练数据根据损失函数最小化的原则建立决策树模型，分类速度快。决策树的学习通常包括3个步骤：特征选择、决策树的生成和决策树的修建。本节对应于统计学习方法第五章的内容，主要学习ID3、C4.5和CART算法。</p>
</blockquote>
<a id="more"></a>
<h1 id="决策树模型与学习"><a href="#决策树模型与学习" class="headerlink" title="决策树模型与学习"></a>决策树模型与学习</h1><h2 id="决策树模型"><a href="#决策树模型" class="headerlink" title="决策树模型"></a>决策树模型</h2><p>分类决策树模型是一种描述对实例进行分类的树形结构。决策树由结点和有向边组成。结点有两种类型：内部节点和叶节点，内部节点表示一个特征或属性，叶节点表示一个类。</p>
<p>分类的时候，从根节点开始，当前节点设为根节点，当前节点必定是一种特征，根据实例的该特征的取值，向下移动，直到到达叶节点，将实例分到叶节点对应的类中。</p>
<h2 id="决策树与if-then规则"><a href="#决策树与if-then规则" class="headerlink" title="决策树与if-then规则"></a>决策树与if-then规则</h2><p>决策树的属性结构其实对应着一个规则集合：由决策树的根节点到叶节点的每条路径构成的规则组成；路径上的内部特征对应着if条件，叶节点对应着then结论。决策树和规则集合是等效的，都具有一个重要的性质：互斥且完备。也就是说任何实例都被且仅被一条路径或规则覆盖。</p>
<h2 id="决策树与条件概率分布"><a href="#决策树与条件概率分布" class="headerlink" title="决策树与条件概率分布"></a>决策树与条件概率分布</h2><p>决策树还是给定特征条件下类的条件概率分布的一种退化表示（非等效，个人理解）。该条件分布定义在特征空间的划分上，特征空间被花费为互不相交的单元，每个单元定义一个类的概率分布就构成了一个条件概率分布。决策树的每条路径对应于划分中的一个单元。给定实例的特征X，一定落入某个划分，决策树选取该划分里最大概率的类作为结果输出。如图：</p>
<p><img src="/resource/blog/2016-08/决策树与条件概率密度.jpg" alt="决策树与条件概率密度"></p>
<p>关于b图，我是这么理解的，将a图的基础上增加一个条件概率的维度P，代表在当前特征X的情况下，分类为+的后验概率。图中的方块有些地方完全没有，比如x2轴上[a2,1]这个区间，说明只要X落在这里，Y就一定是-的，同理对于[0,a1]和[0,a2]围起来的一定是+的。有些地方只有一半，比如x1轴上[a1,1]这个区间，说明决策树认为X落在这里，Y只有一半概率是+的，根据选择条件概率大的类别的原则，就认为Y是-的（因为不满足P(+)&gt;0.5)。</p>
<h2 id="决策树学习"><a href="#决策树学习" class="headerlink" title="决策树学习"></a>决策树学习</h2><p>决策树学习算法包含特征选择、决策树的生成与剪枝过程。决策树的学习算法一般是递归地选择最优特征，并用最优特征对数据集进行分割。开始时，构建根节点，选择最优特征，该特征有几种值就分割为几个子集，每个子集分别递归调用此方法，返回节点，返回的节点就是上一层的子节点。直到数据集为空，或者数据集只有一维特征为止。</p>
<p>基本骨架的Python实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityCnt</span><span class="params">(classList)</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    返回出现次数最多的分类名称</span><br><span class="line">    :param classList: 类列表</span><br><span class="line">    :return: 出现次数最多的类名称</span><br><span class="line">    """</span></span><br><span class="line">    classCount = &#123;&#125;  <span class="comment"># 这是一个字典</span></span><br><span class="line">    <span class="keyword">for</span> vote <span class="keyword">in</span> classList:</span><br><span class="line">        <span class="keyword">if</span> vote <span class="keyword">not</span> <span class="keyword">in</span> classCount.keys(): classCount[vote] = <span class="number">0</span></span><br><span class="line">        classCount[vote] += <span class="number">1</span></span><br><span class="line">    sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTree</span><span class="params">(dataSet, labels, chooseBestFeatureToSplitFunc=chooseBestFeatureToSplitByID3)</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    创建决策树</span><br><span class="line">    :param dataSet:数据集</span><br><span class="line">    :param labels:数据集每一维的名称</span><br><span class="line">    :return:决策树</span><br><span class="line">    """</span></span><br><span class="line">    classList = [example[<span class="number">-1</span>] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]  <span class="comment"># 类别列表</span></span><br><span class="line">    <span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == len(classList):</span><br><span class="line">        <span class="keyword">return</span> classList[<span class="number">0</span>]  <span class="comment"># 当类别完全相同则停止继续划分</span></span><br><span class="line">    <span class="keyword">if</span> len(dataSet[<span class="number">0</span>]) == <span class="number">1</span>:  <span class="comment"># 当只有一个特征的时候，遍历完所有实例返回出现次数最多的类别</span></span><br><span class="line">        <span class="keyword">return</span> majorityCnt(classList)</span><br><span class="line">    bestFeat = chooseBestFeatureToSplitFunc(dataSet)</span><br><span class="line">    bestFeatLabel = labels[bestFeat]</span><br><span class="line">    myTree = &#123;bestFeatLabel: &#123;&#125;&#125;</span><br><span class="line">    <span class="keyword">del</span> (labels[bestFeat])</span><br><span class="line">    featValues = [example[bestFeat] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">    uniqueVals = set(featValues)</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">        subLabels = labels[:]  <span class="comment"># 复制操作</span></span><br><span class="line">        myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value), subLabels)</span><br><span class="line">    <span class="keyword">return</span> myTree</span><br></pre></td></tr></table></figure>
<p>由于决策树表示条件概率分布，所以高度不同的决策树对应不同复杂度的概率模型。最优决策树的生成是个NP问题，能实现的生成算法都是局部最优的，剪枝则是既定决策树下的全局最优。</p>
<h1 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h1><h2 id="特征选择-1"><a href="#特征选择-1" class="headerlink" title="特征选择"></a>特征选择</h2><p>样本通常有很多维特征，希望选择具有分类能力的特征。比如下表：</p>
<p><img src="/resource/blog/2016-08/贷款申请.jpg" alt="贷款申请"></p>
<p>可以用Python建立数据集：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    创建数据集</span><br><span class="line">    :return:数据集和每个维度的名称</span><br><span class="line">    """</span></span><br><span class="line">    dataSet = [[<span class="string">u'青年'</span>, <span class="string">u'否'</span>, <span class="string">u'否'</span>, <span class="string">u'一般'</span>, <span class="string">u'拒绝'</span>],</span><br><span class="line">               [<span class="string">u'青年'</span>, <span class="string">u'否'</span>, <span class="string">u'否'</span>, <span class="string">u'好'</span>, <span class="string">u'拒绝'</span>],</span><br><span class="line">               [<span class="string">u'青年'</span>, <span class="string">u'是'</span>, <span class="string">u'否'</span>, <span class="string">u'好'</span>, <span class="string">u'同意'</span>],</span><br><span class="line">               [<span class="string">u'青年'</span>, <span class="string">u'是'</span>, <span class="string">u'是'</span>, <span class="string">u'一般'</span>, <span class="string">u'同意'</span>],</span><br><span class="line">               [<span class="string">u'青年'</span>, <span class="string">u'否'</span>, <span class="string">u'否'</span>, <span class="string">u'一般'</span>, <span class="string">u'拒绝'</span>],</span><br><span class="line">               [<span class="string">u'中年'</span>, <span class="string">u'否'</span>, <span class="string">u'否'</span>, <span class="string">u'一般'</span>, <span class="string">u'拒绝'</span>],</span><br><span class="line">               [<span class="string">u'中年'</span>, <span class="string">u'否'</span>, <span class="string">u'否'</span>, <span class="string">u'好'</span>, <span class="string">u'拒绝'</span>],</span><br><span class="line">               [<span class="string">u'中年'</span>, <span class="string">u'是'</span>, <span class="string">u'是'</span>, <span class="string">u'好'</span>, <span class="string">u'同意'</span>],</span><br><span class="line">               [<span class="string">u'中年'</span>, <span class="string">u'否'</span>, <span class="string">u'是'</span>, <span class="string">u'非常好'</span>, <span class="string">u'同意'</span>],</span><br><span class="line">               [<span class="string">u'中年'</span>, <span class="string">u'否'</span>, <span class="string">u'是'</span>, <span class="string">u'非常好'</span>, <span class="string">u'同意'</span>],</span><br><span class="line">               [<span class="string">u'老年'</span>, <span class="string">u'否'</span>, <span class="string">u'是'</span>, <span class="string">u'非常好'</span>, <span class="string">u'同意'</span>],</span><br><span class="line">               [<span class="string">u'老年'</span>, <span class="string">u'否'</span>, <span class="string">u'是'</span>, <span class="string">u'好'</span>, <span class="string">u'同意'</span>],</span><br><span class="line">               [<span class="string">u'老年'</span>, <span class="string">u'是'</span>, <span class="string">u'否'</span>, <span class="string">u'好'</span>, <span class="string">u'同意'</span>],</span><br><span class="line">               [<span class="string">u'老年'</span>, <span class="string">u'是'</span>, <span class="string">u'否'</span>, <span class="string">u'非常好'</span>, <span class="string">u'同意'</span>],</span><br><span class="line">               [<span class="string">u'老年'</span>, <span class="string">u'否'</span>, <span class="string">u'否'</span>, <span class="string">u'一般'</span>, <span class="string">u'拒绝'</span>],</span><br><span class="line">               ]</span><br><span class="line">    labels = [<span class="string">u'年龄'</span>, <span class="string">u'有工作'</span>, <span class="string">u'有房子'</span>, <span class="string">u'信贷情况'</span>]</span><br><span class="line">    <span class="comment"># 返回数据集和每个维度的名称</span></span><br><span class="line">    <span class="keyword">return</span> dataSet, labels</span><br></pre></td></tr></table></figure>
<p>也可以根据特征分割数据集：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitDataSet</span><span class="params">(dataSet, axis, value)</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    按照给定特征划分数据集</span><br><span class="line">    :param dataSet: 待划分的数据集</span><br><span class="line">    :param axis: 划分数据集的特征的维度</span><br><span class="line">    :param value: 特征的值</span><br><span class="line">    :return: 符合该特征的所有实例（并且自动移除掉这维特征）</span><br><span class="line">    """</span></span><br><span class="line">    retDataSet = []</span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="keyword">if</span> featVec[axis] == value:</span><br><span class="line">            reducedFeatVec = featVec[:axis]  <span class="comment"># 删掉这一维特征</span></span><br><span class="line">            reducedFeatVec.extend(featVec[axis + <span class="number">1</span>:])</span><br><span class="line">            retDataSet.append(reducedFeatVec)</span><br><span class="line">    <span class="keyword">return</span> retDataSet</span><br></pre></td></tr></table></figure>
<h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p>对于一个可能有n种取值的随机变量：$P(X=x_i)=p_i$,其熵为：$H(X)=-\sum_{i=1}^np_i\log p_i$ ,另外定义0log0=0,当对数的底为2时，熵的单位是bit，为自然对数时，单位是nat。</p>
<p>用Python实现信息熵（香农熵）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcShannonEnt</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    计算训练数据集中的Y随机变量的香农熵</span><br><span class="line">    :param dataSet:</span><br><span class="line">    :return:</span><br><span class="line">    """</span></span><br><span class="line">    numEntries = len(dataSet)  <span class="comment"># 实例的个数</span></span><br><span class="line">    labelCounts = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:  <span class="comment"># 遍历每个实例，统计标签的频次</span></span><br><span class="line">        currentLabel = featVec[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys(): labelCounts[currentLabel] = <span class="number">0</span></span><br><span class="line">        labelCounts[currentLabel] += <span class="number">1</span></span><br><span class="line">    shannonEnt = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> labelCounts:</span><br><span class="line">        prob = float(labelCounts[key]) / numEntries</span><br><span class="line">        shannonEnt -= prob * log(prob, <span class="number">2</span>)  <span class="comment"># log base 2</span></span><br><span class="line">    <span class="keyword">return</span> shannonEnt</span><br></pre></td></tr></table></figure>
<p>由定义知，X的熵与X的值无关，只与分布有关，所以也可以将X的熵记作H(p),即：</p>
<p>$$H(p)=-\sum_{i=1}^np_i\log p_i$$</p>
<p>熵其实就是X的不确定性，从定义可以验证$0 \leq H(p) \leq \log n$</p>
<p>设随机变量(X,Y)，其联合分布为：</p>
<p>$$P(X=x_i,Y=y_i)=p_{ij},i=1,2,\cdots,n;j=1,2,\cdots,m$$</p>
<p>条件熵H(Y|X)表示在已知随机变量X的条件下随机变量Y的不确定性，定义为在X给定的条件下，Y的概率分布对X的数学期望：</p>
<p>$$H(Y|X)=\sum_{i=1}^np_iH(Y|X=x_i),p_i=P(X=x_i),i=1,2,\cdots,n$$</p>
<p>当上述定义式中的概率由数据估计（比如上一章提到的极大似然估计）得到时，所对应的熵和条件熵分别称为经验熵和经验条件熵。</p>
<p>Python实现条件熵的计算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcConditionalEntropy</span><span class="params">(dataSet, i, featList, uniqueVals)</span>:</span></span><br><span class="line">    <span class="string">'''</span><br><span class="line">    计算X_i给定的条件下，Y的条件熵</span><br><span class="line">    :param dataSet:数据集</span><br><span class="line">    :param i:维度i</span><br><span class="line">    :param featList: 数据集特征列表</span><br><span class="line">    :param uniqueVals: 数据集特征集合</span><br><span class="line">    :return:条件熵</span><br><span class="line">    '''</span></span><br><span class="line">    ce = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">        subDataSet = splitDataSet(dataSet, i, value)</span><br><span class="line">        prob = len(subDataSet) / float(len(dataSet))  <span class="comment"># 极大似然估计概率</span></span><br><span class="line">        ce += prob * calcShannonEnt(subDataSet)  <span class="comment"># ∑pH(Y|X=xi) 条件熵的计算</span></span><br><span class="line">    <span class="keyword">return</span> ce</span><br></pre></td></tr></table></figure>
<p>有了上述知识，就可以一句话说明什么叫信息增益了：信息增益表示得知特征X的信息而使类Y的信息的熵减少的程度。形式化的定义如下：</p>
<blockquote>
<p>特征A对训练数据集D的信息增益g(D,A),定义为集合D的经验熵H(D)与特征A给定条件下D的经验条件熵H(D|A)之差，即$g(D|A)=H(D)-H(D|A)$,这个差又称为互信息，决策树学习中的信息增益等价于训练数据集中类与特征的互信息。</p>
</blockquote>
<p>用Python计算信息增益：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcInformationGain</span><span class="params">(dataSet, baseEntropy, i)</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    计算信息增益</span><br><span class="line">    :param dataSet:数据集</span><br><span class="line">    :param baseEntropy:数据集中Y的信息熵</span><br><span class="line">    :param i: 特征维度i</span><br><span class="line">    :return: 特征i对数据集的信息增益g(dataSet|X_i)</span><br><span class="line">    """</span></span><br><span class="line">    featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]  <span class="comment"># 第i维特征列表</span></span><br><span class="line">    uniqueVals = set(featList)  <span class="comment"># 转换成集合</span></span><br><span class="line">    newEntropy = calcConditionalEntropy(dataSet, i, featList, uniqueVals)</span><br><span class="line">    infoGain = baseEntropy - newEntropy  <span class="comment"># 信息增益，就是熵的减少，也就是不确定性的减少</span></span><br><span class="line">    <span class="keyword">return</span> infoGain</span><br></pre></td></tr></table></figure>
<p>回到最初的问题，如何判断一个特征的分类能力呢？信息增益大的特征具有更强的分类能力。只要计算出各个特征的信息增益，找出最大的那一个就行。</p>
<h2 id="信息增益的算法"><a href="#信息增益的算法" class="headerlink" title="信息增益的算法"></a>信息增益的算法</h2><p>输入：训练数据集D和特征A；</p>
<p>输出：特征A对训练数据集D的信息增益g(D,A);</p>
<p>(1) 计算数据集D的经验熵H(D)</p>
<p>$$H(D)=-\sum_{k=1}^K\frac{\vert C_k \vert}{\vert D \vert}\log_2\frac{\vert C_k \vert}{\vert D \vert}$$</p>
<p>(2) 计算特征A对数据集D的经验条件熵H(D|A)</p>
<p>$$H(D \vert A)=\sum_{i=1}^n \frac{\vert D_i \vert}{\vert D \vert} H(D_i) = -\sum_{i=1}^n \frac{\vert D_i \vert}{\vert D \vert} \sum_{k=1}^K \frac{\vert D_{ik} \vert}{\vert D_i \vert} \log_2 \frac{\vert D_{ik} \vert}{\vert D_i \vert}$$</p>
<p>(3) 计算信息增益</p>
<p>$$g(D,A)=H(D)-H(D|A)$$</p>
<h2 id="信息增益比"><a href="#信息增益比" class="headerlink" title="信息增益比"></a>信息增益比</h2><p>信息增益算法有个缺点，信息增益的值是相对于训练数据集而言的，当H(D)大的时候，信息增益值往往会偏大，这样对H(D)小的特征不公平。改进的方法是信息增益比：</p>
<blockquote>
<p>特征增益比：特征A对训练数据集D的信息增益比$g_R(D,A)$定义为其信息增益g(D,A)与训练数据集D的经验熵H(D)之比：$$g_R(D,A)=\frac{g(D,A)}{H(D)}$$</p>
</blockquote>
<p>Python代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcInformationGainRate</span><span class="params">(dataSet, baseEntropy, i)</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    计算信息增益比</span><br><span class="line">    :param dataSet:数据集</span><br><span class="line">    :param baseEntropy:数据集中Y的信息熵</span><br><span class="line">    :param i: 特征维度i</span><br><span class="line">    :return: 特征i对数据集的信息增益g(dataSet|X_i)</span><br><span class="line">    """</span></span><br><span class="line">    <span class="keyword">return</span> calcInformationGain(dataSet, baseEntropy, i) / baseEntropy</span><br></pre></td></tr></table></figure>
<h1 id="决策树的生成"><a href="#决策树的生成" class="headerlink" title="决策树的生成"></a>决策树的生成</h1><h2 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>从根节点开始，计算所有可能的特征的信息增益，选择信息增益最大的特征作为当前节点的特征，由特征的不同取值建立空白子节点，对空白子节点递归调用此方法，直到所有特征的信息增益小于阀值或者没有特征可选为止。</p>
<h3 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h3><p>ID3特征选择算法的Python实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseBestFeatureToSplitByID3</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    选择最好的数据集划分方式</span><br><span class="line">    :param dataSet:</span><br><span class="line">    :return:</span><br><span class="line">    """</span></span><br><span class="line">    numFeatures = len(dataSet[<span class="number">0</span>]) - <span class="number">1</span>  <span class="comment"># 最后一列是分类</span></span><br><span class="line">    baseEntropy = calcShannonEnt(dataSet)</span><br><span class="line">    bestInfoGain = <span class="number">0.0</span></span><br><span class="line">    bestFeature = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numFeatures):  <span class="comment"># 遍历所有维度特征</span></span><br><span class="line">        infoGain = calcInformationGain(dataSet, baseEntropy, i)</span><br><span class="line">        <span class="keyword">if</span> (infoGain &gt; bestInfoGain):  <span class="comment"># 选择最大的信息增益</span></span><br><span class="line">            bestInfoGain = infoGain</span><br><span class="line">            bestFeature = i</span><br><span class="line">    <span class="keyword">return</span> bestFeature  <span class="comment"># 返回最佳特征对应的维度</span></span><br></pre></td></tr></table></figure>
<p>完整调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Filename: testTree.py</span></span><br><span class="line"><span class="comment"># Author：hankcs</span></span><br><span class="line"><span class="comment"># Date: 2014-04-19 下午9:19</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###########中文支持################</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> tree <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">mpl.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'SimHei'</span>]  <span class="comment"># 指定默认字体</span></span><br><span class="line">mpl.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="keyword">False</span>  <span class="comment"># 解决保存图像时负号'-'显示为方块的问题</span></span><br><span class="line"><span class="comment">##################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试决策树的构建</span></span><br><span class="line">myDat, labels = createDataSet()</span><br><span class="line">myTree = createTree(myDat, labels)</span><br><span class="line"><span class="comment"># 绘制决策树</span></span><br><span class="line"><span class="keyword">import</span> treePlotter</span><br><span class="line">treePlotter.createPlot(myTree)</span><br></pre></td></tr></table></figure>
<h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Filename: treePlotter.py</span></span><br><span class="line"><span class="comment"># Author：hankcs</span></span><br><span class="line"><span class="comment"># Date: 2015/2/9 21:24</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义文本框和箭头格式</span></span><br><span class="line">decisionNode = dict(boxstyle=<span class="string">"round4"</span>, color=<span class="string">'#3366FF'</span>)  <span class="comment">#定义判断结点形态</span></span><br><span class="line">leafNode = dict(boxstyle=<span class="string">"circle"</span>, color=<span class="string">'#FF6633'</span>)  <span class="comment">#定义叶结点形态</span></span><br><span class="line">arrow_args = dict(arrowstyle=<span class="string">"&lt;-"</span>, color=<span class="string">'g'</span>)  <span class="comment">#定义箭头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#绘制带箭头的注释</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotNode</span><span class="params">(nodeTxt, centerPt, parentPt, nodeType)</span>:</span></span><br><span class="line">    createPlot.ax1.annotate(nodeTxt, xy=parentPt, xycoords=<span class="string">'axes fraction'</span>,</span><br><span class="line">                            xytext=centerPt, textcoords=<span class="string">'axes fraction'</span>,</span><br><span class="line">                            va=<span class="string">"center"</span>, ha=<span class="string">"center"</span>, bbox=nodeType, arrowprops=arrow_args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#计算叶结点数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getNumLeafs</span><span class="params">(myTree)</span>:</span></span><br><span class="line">    numLeafs = <span class="number">0</span></span><br><span class="line">    firstStr = myTree.keys()[<span class="number">0</span>]</span><br><span class="line">    secondDict = myTree[firstStr]</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">        <span class="keyword">if</span> type(secondDict[key]).__name__ == <span class="string">'dict'</span>:</span><br><span class="line">            numLeafs += getNumLeafs(secondDict[key])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            numLeafs += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> numLeafs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#计算树的层数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTreeDepth</span><span class="params">(myTree)</span>:</span></span><br><span class="line">    maxDepth = <span class="number">0</span></span><br><span class="line">    firstStr = myTree.keys()[<span class="number">0</span>]</span><br><span class="line">    secondDict = myTree[firstStr]</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">        <span class="keyword">if</span> type(secondDict[key]).__name__ == <span class="string">'dict'</span>:</span><br><span class="line">            thisDepth = <span class="number">1</span> + getTreeDepth(secondDict[key])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            thisDepth = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> thisDepth &gt; maxDepth:</span><br><span class="line">            maxDepth = thisDepth</span><br><span class="line">    <span class="keyword">return</span> maxDepth</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#在父子结点间填充文本信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotMidText</span><span class="params">(cntrPt, parentPt, txtString)</span>:</span></span><br><span class="line">    xMid = (parentPt[<span class="number">0</span>] - cntrPt[<span class="number">0</span>]) / <span class="number">2.0</span> + cntrPt[<span class="number">0</span>]</span><br><span class="line">    yMid = (parentPt[<span class="number">1</span>] - cntrPt[<span class="number">1</span>]) / <span class="number">2.0</span> + cntrPt[<span class="number">1</span>]</span><br><span class="line">    createPlot.ax1.text(xMid, yMid, txtString, va=<span class="string">"center"</span>, ha=<span class="string">"center"</span>, rotation=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotTree</span><span class="params">(myTree, parentPt, nodeTxt)</span>:</span></span><br><span class="line">    numLeafs = getNumLeafs(myTree)</span><br><span class="line">    depth = getTreeDepth(myTree)</span><br><span class="line">    firstStr = myTree.keys()[<span class="number">0</span>]</span><br><span class="line">    cntrPt = (plotTree.xOff + (<span class="number">1.0</span> + float(numLeafs)) / <span class="number">2.0</span> / plotTree.totalW, plotTree.yOff)</span><br><span class="line">    plotMidText(cntrPt, parentPt, nodeTxt)  <span class="comment">#在父子结点间填充文本信息</span></span><br><span class="line">    plotNode(firstStr, cntrPt, parentPt, decisionNode)  <span class="comment">#绘制带箭头的注释</span></span><br><span class="line">    secondDict = myTree[firstStr]</span><br><span class="line">    plotTree.yOff = plotTree.yOff - <span class="number">1.0</span> / plotTree.totalD</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">        <span class="keyword">if</span> type(secondDict[key]).__name__ == <span class="string">'dict'</span>:</span><br><span class="line">            plotTree(secondDict[key], cntrPt, str(key))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            plotTree.xOff = plotTree.xOff + <span class="number">1.0</span> / plotTree.totalW</span><br><span class="line">            plotNode(secondDict[key], (plotTree.xOff, plotTree.yOff), cntrPt, leafNode)</span><br><span class="line">            plotMidText((plotTree.xOff, plotTree.yOff), cntrPt, str(key))</span><br><span class="line">    plotTree.yOff = plotTree.yOff + <span class="number">1.0</span> / plotTree.totalD</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createPlot</span><span class="params">(inTree)</span>:</span></span><br><span class="line">    fig = plt.figure(<span class="number">1</span>, facecolor=<span class="string">'white'</span>)</span><br><span class="line">    fig.clf()</span><br><span class="line">    axprops = dict(xticks=[], yticks=[])</span><br><span class="line">    createPlot.ax1 = plt.subplot(<span class="number">111</span>, frameon=<span class="keyword">False</span>, **axprops)</span><br><span class="line">    plotTree.totalW = float(getNumLeafs(inTree))</span><br><span class="line">    plotTree.totalD = float(getTreeDepth(inTree))</span><br><span class="line">    plotTree.xOff = <span class="number">-0.5</span> / plotTree.totalW;</span><br><span class="line">    plotTree.yOff = <span class="number">1.0</span>;</span><br><span class="line">    plotTree(inTree, (<span class="number">0.5</span>, <span class="number">1.0</span>), <span class="string">''</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<h2 id="C4-5生成算法"><a href="#C4-5生成算法" class="headerlink" title="C4.5生成算法"></a>C4.5生成算法</h2><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><p>输入： 训练数据集D，特征集A，阈值$\epsilon$</p>
<p>输出：决策树T</p>
<p>(1) 如果D中所有实例属于同一类$C_k$,则置T为单节点树，并将$C_k$作为该节点的类，返回T</p>
<p>(2) 如果$A=\emptyset$,则置T为单节点树，并将D中实例数最大的类$C_k$作为该节点的类，返回T</p>
<p>(3) 否则，计算A中各特征对D的信息增益比，选择信息增益比最大的特征$A_g$</p>
<p>(4) 如果$A_g$的信息增益比小于阈值$\epsilon$，则置T为单节点树，并将D中实例数最大的类$C_k$作为该节点的类，返回T</p>
<p>(5) 否则，对$A_g$的每一个可能值$a_i$,依$A_g=a_i$将D分割为子集若干非空$D_i$,将$D_i$中实例数最大的类作为标记，构建子节点，由节点及其子节点构成树T，返回T</p>
<p>(6) 对节点i，以$D_i$作为训练集，以$A-\{A_g\}$为特征集，递归调用(1)~(5)步，得到子树$T_i$,返回$T_i$</p>
<h3 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseBestFeatureToSplitByC45</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    选择最好的数据集划分方式</span><br><span class="line">    :param dataSet:</span><br><span class="line">    :return:</span><br><span class="line">    """</span></span><br><span class="line">    numFeatures = len(dataSet[<span class="number">0</span>]) - <span class="number">1</span>  <span class="comment"># 最后一列是分类</span></span><br><span class="line">    baseEntropy = calcShannonEnt(dataSet)</span><br><span class="line">    bestInfoGainRate = <span class="number">0.0</span></span><br><span class="line">    bestFeature = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numFeatures):  <span class="comment"># 遍历所有维度特征</span></span><br><span class="line">        infoGainRate = calcInformationGainRate(dataSet, baseEntropy, i)</span><br><span class="line">        <span class="keyword">if</span> (infoGainRate &gt; bestInfoGainRate):  <span class="comment"># 选择最大的信息增益</span></span><br><span class="line">            bestInfoGainRate = infoGainRate</span><br><span class="line">            bestFeature = i</span><br><span class="line">    <span class="keyword">return</span> bestFeature  <span class="comment"># 返回最佳特征对应的维度</span></span><br></pre></td></tr></table></figure>
<p>调用方法只需加个参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myTree = createTree(myDat, labels, chooseBestFeatureToSplitByC45)</span><br></pre></td></tr></table></figure>
<h1 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a>决策树的剪枝</h1><p>决策树很容易发生过拟合，过拟合的原因在于学习的时候过多地考虑如何提高对训练数据的正确分类，从而构建出过于复杂的决策树。解决这个问题的办法就是简化已生成的决策树，也就是剪枝。</p>
<p>决策树的剪枝往往通过极小化决策树整体的损失函数或代价函数来实现。</p>
<p>设决策树T的叶节点有|T|个，t是某个叶节点，t有$N_t$个样本点，其中归入k类的样本点有$N_{tk}$个，$H_t(T)$为叶节点t上的经验熵，α≥0为参数，则损失函数可以定义为：</p>
<p>$$C_{\alpha}(T)=\sum_{t=1}^{\vert T \vert} N_tH_t(T) + \alpha \vert T \vert$$</p>
<p>其中经验熵Ht(T)为：</p>
<p>$$H_t(T)=- \sum_k \frac{N_{ik}}{N_t} \log \frac{N_{tk}}{N_t}$$</p>
<p>表示叶节点t所代表的类别的不确定性。损失函数对它求和表示所有被导向该叶节点的样本点所带来的不确定的和的和。</p>
<p>在损失函数中，将右边第一项记作：</p>
<p>$$C(T)=\sum_{t=1}^{\vert T \vert}N_tH_t(T)=-\sum_{t=1}^{\vert T \vert}\sum_{k=1}^K N_{tk} \log \frac{N_{tk}}{N_t}$$</p>
<p>则损失函数可以简单记作：</p>
<p>$$C_{\alpha}(T)=C(T) + \alpha \vert T \vert$$</p>
<p>C(T)表示模型对训练数据的预测误差，即模型与训练数据的拟合程度，|T|表示模型复杂度，参数α≥0控制两者之间的影响，α越大，模型越简单，α=0表示不考虑复杂度。</p>
<p>剪枝，就是当α确定时，选择损失函数最小的模型。子树越大C(T)越小，但是α|T|越大，损失函数反映的是两者的平衡。</p>
<p>决策树的生成过程只考虑了信息增益或信息增益比，只考虑更好地拟合训练数据，而剪枝过程则考虑了减小复杂度。前者是局部学习，后者是整体学习。</p>
<h2 id="树的剪枝算法"><a href="#树的剪枝算法" class="headerlink" title="树的剪枝算法"></a>树的剪枝算法</h2><p>从每个叶节点往上走，走了后如果损失函数减小了，则减掉叶节点，将父节点作为叶节点。如图：</p>
<p><img src="/resource/blog/2016-08/决策树剪枝.jpg" alt="树的剪枝算法"></p>
<p>说是这么说，实际上如果叶节点有多个，那么父节点变成叶节点后，新叶节点到底应该选择原来的叶节点中的哪一种类别呢？大概又是多数表决吧，原著并没有深入展开。</p>
<h1 id="CART算法"><a href="#CART算法" class="headerlink" title="CART算法"></a>CART算法</h1><p>分类与回归树（CART）模型同样由特征选取、树的生成和剪枝组成，既可以用于分类也可以用于回归。CART假设决策树是二叉树，内部节点特征的取值为是和否，对应一个实例的特征是否是这样的。决策树递归地二分每个特征，将输入空间划分为有限个单元。</p>
<h2 id="CART生成"><a href="#CART生成" class="headerlink" title="CART生成"></a>CART生成</h2><p>决策树的生成就是递归地构建二叉决策树的过程。对回归树用平方误差最小化准则，对分类树用基尼系数最小化准则，进行特征选择，生成二叉树。</p>
<h3 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a>回归树</h3><p>回归树与分类树在数据集上的不同就是数据集的输出部分不是类别，而是连续变量。</p>
<p>假设输入空间已经被分为M个单元输入空间单元$R_1,R_2,\cdots,R_M$，分别对应输出值$c_m$，于是回归树模型可以表示为：</p>
<p>$$f(x)=\sum_{m=1}^Mc_mI(x \in R_m)$$</p>
<p>回归树的预测误差：</p>
<p>$$\sum_{x_x \in R_m}(y_i - f(x_i))^2$$</p>
<p>那么输出值就是使上面误差最小的值，也就是均值：</p>
<p>$$\hat c_m = ave(y_i \vert x_i \in R_m)$$</p>
<p>难点在于怎么划分，一种启发式的方法（其实就是暴力搜索吧）：</p>
<p>遍历所有输入变量，选择第j个变量和它的值s作为切分变量和切分点，将空间分为两个区域：</p>
<p>$$R_1(j,s)=\{x \vert x^{(j)} \leq s\} 和R_2(j,s)=\{x \vert x^{(j)} &gt; s\}$$</p>
<p>然后计算两个区域的平方误差，求和，极小化这个和，具体的，就是：</p>
<p>$$\min_{j,s} \left [ \min_{c_1} \sum_{x_i \in R_1(j,s)}(y_i-c_1)^2 + \min_{c_2} \sum_{x_i \in R_2(j,s)}(y_i-c_2)^2 \right ]$$</p>
<p>当j最优化的时候，就可以将切分点最优化：</p>
<p>$$\hat c_1 = ave()y_i | x_i \in R_1(j,s)) 和 \hat c_2 = ave()y_i | x_i \in R_2(j,s))$$</p>
<p>递归调用此过程，这种回归树通常称为最小二乘回归树。</p>
<h3 id="最小二乘回归树生成算法"><a href="#最小二乘回归树生成算法" class="headerlink" title="最小二乘回归树生成算法"></a>最小二乘回归树生成算法</h3><p>输入：训练数据集D</p>
<p>输出：回归树f(x)</p>
<p>在训练数据集所在的输入空间中，递归地将每个区域划分为两个子区域并决定每个子区域上的输出值，构建二叉决策树：</p>
<p>(1) 选择最优切分变量j与切分点s，求解：</p>
<p>$$\min_{j,s} \left [ \min_{c_1} \sum_{x_i \in R_1(j,s)}(y_i-c_1)^2 + \min_{c_2} \sum_{x_i \in R_2(j,s)}(y_i-c_2)^2 \right ]$$</p>
<p>遍历变量j，对固定的切分变量j扫描切分点s,选择使上式达到最小值的对(j,s)</p>
<p>(2) 用选定的对(j,s)划分区域并决定相应的输出值：</p>
<p>$$R_1(j,s)=\{x \vert x^{(j)} \leq s\} 和R_2(j,s)=\{x \vert x^{(j)} &gt; s\}$$</p>
<p>$$\hat c_m = \frac{1}{N_m}\sum_{x_i \in R_m(j,s)} y_i, x \in R_m,m=1,2 $$</p>
<p>(3) 继续对两个子区域调用步骤(1)和(2)，直到满足停止条件</p>
<p>(4) 将输入空间划分为M个区域R_1,R_2,\cdots,R_M,生成决策树：</p>
<p>$$f(x)=\sum_{m=1}^M \hat c_m I(x \in R_m)$$</p>
<h3 id="分类树"><a href="#分类树" class="headerlink" title="分类树"></a>分类树</h3><p>与回归树算法流程类似，只不过选择的是最优切分特征和最优切分点，并采用基尼指数衡量。基尼指数定义：</p>
<p>$$Gini(p)=\sum_{k=1}^{K}p_k(1-p_k)=1-\sum_{k=1}^Kp_k^2$$</p>
<p>对于给定数据集D，其基尼指数是：</p>
<p>$$Gini(D)=1-\sum_{k=1}^K \left ( \frac{\vert C_k \vert}{\vert D \vert} \right) ^2$$</p>
<p>Ck是属于第k类的样本子集，K是类的个数。Gini(D)反应的是D的不确定性（与熵类似），分区的目标就是降低不确定性。</p>
<p>D根据特征A是否取某一个可能值a而分为D1和D2两部分：</p>
<p>$$D_1=\{(x,y) \in D \vert A(x) = a\}, D_2 = D - D_1$$</p>
<p>则在特征A的条件下，D的基尼指数是：</p>
<p>$$Gini(D,A)=\frac{D_1}{D}Gini(D_1) + \frac{D_2}{D}Gini(D_2)$$</p>
<p>有了上述知识储备，可以给出CART生成算法的伪码：</p>
<p>设节点的当前数据集为D，对D中每一个特征A，对齐每个值a根据D中样本点是否满足A==a分为两部分，计算基尼指数。对所有基尼指数选择最小的，对应的特征和切分点作为最优特征和最优切分点，生成两个子节点，将对应的两个分区分配过去，然后对两个子节点递归。</p>
<h2 id="CART剪枝"><a href="#CART剪枝" class="headerlink" title="CART剪枝"></a>CART剪枝</h2><p>在上面介绍的损失函数中，当α固定时，一定存在使得损失函数最小的子树，记为复杂度=Tα，α偏大Tα就偏小。设对α递增的序列，对应的最优子树序列为Tn，子树序列第一棵包含第二棵，依次类推。</p>
<p>从T0开始剪枝，对它内部的任意节点t，只有t这一个节点的子树的损失函数是：</p>
<p>$$C_{\alpha}=C(t)+\alpha$$</p>
<p>以t为根节点的子树的损失函数是：</p>
<p>$$C_{\alpha}(T_t)=C(T_t)+\alpha \vert T \vert$$</p>
<p>当α充分小，肯定有:</p>
<p>$$C_{\alpha}(T_t)&lt;C_{\alpha}(t)$$</p>
<p>这个不等式的意思是复杂模型在复杂度影响力小的情况下损失函数更小。</p>
<p>当α增大到某一点，这个不等式的符号会反过来。</p>
<p>只要$\alpha = \frac{C(t)-C(T_t)}{\vert T_t \vert -1}$,损失函数值就相同，但是t更小啊，所以t更可取，于是把Tt剪枝掉。</p>
<p>为此，对每一个t，计算</p>
<p>$$g(t)=$\frac{C(t)-C(T_t)}{\vert T_t \vert -1}$$</p>
<p>表示损失函数的减少程度，从T中剪枝掉g(t)最小的Tt，取新的α=g(t)，直到根节点。这样就得到了一个子树序列，对此序列，应用独立的验证数据集交叉验证，选取最优子树，剪枝完毕。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop源码学习(15)——文件系统(1)]]></title>
      <url>http://keyunluo.github.io/2016/09/22/2016-09-22-hadoop-filesystem-1.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>为了提供对不同数据访问的一致接口，Hadoop借鉴了Linux虚拟文件系统的概念，引入了Hadoop抽象文件系统，并在Hadoop抽象文件系统上，提供了大量的具体文件系统的实现，满足构建于Hadoop应用之上的数据访问需求。本节学习Hadoop文件系统API。</p>
</blockquote>
<a id="more"></a>
<h2 id="分布式文件系统的特性"><a href="#分布式文件系统的特性" class="headerlink" title="分布式文件系统的特性"></a>分布式文件系统的特性</h2><ul>
<li><p>访问透明性：用户不需要了解文件的分布性</p>
</li>
<li><p>位置透明性：客户程序可以使用单一的文件空间</p>
</li>
<li><p>移动透明性：文件被移动时，客户程序不需要改变</p>
</li>
<li><p>性能透明性，伸缩透明性，复制透明性，故障透明性，并发透明性</p>
</li>
<li><p>数据完整性、安全性和系统异构</p>
</li>
</ul>
<h2 id="Hadoop文件系统类图"><a href="#Hadoop文件系统类图" class="headerlink" title="Hadoop文件系统类图"></a>Hadoop文件系统类图</h2><p>Hadoop提供了一个抽象的文件系统，该系统可以作为分布式系统实现也可是本地磁盘。HDFS是这个抽象文件系统的具体实现。抽象系统类org.apache.hadoop.fs.FileSystem的类图如下：</p>
<p><img src="/resource/blog/2016-08/FileSystem.png" alt="FileSystem"></p>
<h2 id="API对应关系"><a href="#API对应关系" class="headerlink" title="API对应关系"></a>API对应关系</h2><p>和Linux与Java文件API类似，Hadoop抽象文件系统的方法可以分为两个部分：一部分用于处理文件和目录的相关事务，另一部分用于读写数据。下表总结了Hadoop抽象文件系统的文件操作与Java、Linux的对应关系</p>
<ul>
<li>Hadoop抽象文件系统文件操作(部分)</li>
</ul>
<table>
<thead>
<tr>
<th>HadoopFileSystem类</th>
<th>Java操作</th>
<th>Linux操作</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>URL.openStream, FileSystem.open, FileSystem.create, FileSystem.append</td>
<td>URL.openStream</td>
<td>open</td>
<td>打开一个文件</td>
</tr>
<tr>
<td>FSDataInputStream.read</td>
<td>InputStream.read</td>
<td>read</td>
<td>读取文件中包含的数据</td>
</tr>
<tr>
<td>FSDataOutputStream.write</td>
<td>OutputStream.write</td>
<td>write</td>
<td>向文件中写数据</td>
</tr>
<tr>
<td>FSDataOutputStream.close, FSDataInputStream.close</td>
<td>InputStream.close,OutputStream.close</td>
<td>close</td>
<td>关闭一个文件</td>
</tr>
<tr>
<td>FSDataInputStream.seek</td>
<td>RandomAccessFile.seek</td>
<td>lseek</td>
<td>改变文件的读写位置</td>
</tr>
<tr>
<td>FileSystem.getFileStatus, FileSystem.get*</td>
<td>File.get*</td>
<td>stat</td>
<td>获取文件/目录的属性</td>
</tr>
<tr>
<td>FileSystem.set*</td>
<td>File.set*</td>
<td>chmod等</td>
<td>修改文件属性</td>
</tr>
<tr>
<td>FileSystem.createNewFile</td>
<td>File.createNewFile</td>
<td>create</td>
<td>创建一个文件</td>
</tr>
<tr>
<td>FileSystem.delete</td>
<td>File.delete</td>
<td>remove/rmdir</td>
<td>从文件系统中删除一个文件/文件夹</td>
</tr>
<tr>
<td>FileSystem.rename</td>
<td>File.renameTo</td>
<td>rename</td>
<td>更改文件/目录名</td>
</tr>
<tr>
<td>FileSystem.mkdirs</td>
<td>FileSystem.mkdir</td>
<td>mkdir</td>
<td>在给定目录下创建一个子目录</td>
</tr>
<tr>
<td>FileSystem.listStatus</td>
<td>File.list</td>
<td>readdir</td>
<td>读取一个目录下的项目</td>
</tr>
<tr>
<td>FileSystem.setWorkingDirectory</td>
<td></td>
<td>getcwd/getwd</td>
<td>返回当前工作目录</td>
</tr>
<tr>
<td>FileSystem.setWorkingDirectory</td>
<td></td>
<td>chdir</td>
<td>更改当前工作目录</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[统计学习方法——朴素贝叶斯法]]></title>
      <url>http://keyunluo.github.io/2016/08/16/2016-08-16-statical-learning-4.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>朴素贝叶斯(native Bates)是基于贝叶斯定理与特征条件独立假设的分类法。对于给定的训练数据集，首先基于特征条件独立假设学习输入/输出的联合概率密度；然后基于此模型，对给定的输入x，利用贝叶斯定理求出后验概率的最大的输出y。朴素贝叶斯实现简单，学习和预测的效率都很高，是一种常用的方法。本节对应于统计学习方法第四章的内容。</p>
</blockquote>
<a id="more"></a>
<h2 id="朴素贝叶斯法的学习与分类"><a href="#朴素贝叶斯法的学习与分类" class="headerlink" title="朴素贝叶斯法的学习与分类"></a>朴素贝叶斯法的学习与分类</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><p>设输入空间$\mathcal{X} \subseteq R^n$为n维向量的集合，输出空间为类标记集合$\mathcal{Y} = \{c_1,c_2, \cdots ,c_K \}$.输入为特征向量$x \in \mathcal{X}$,输出为类标记$y \in \mathcal{Y},X$是定义在输入空间$\mathcal{X}$上的随机变量，$\mathcal{Y}$是定义在输出空间Y上的随机变量.P(X,Y)是X和Y的联合概率分布。训练数据集：</p>
<p>$$T = \{(x_1,y_1),(x_2,y_2), \cdots , (x_N,y_N) \}$$</p>
<p>由P(X,Y)独立同分布产生。朴素贝叶斯法通过训练数据集学习联合概率分布P(X,Y),具体地，学习以下先验概率密度及条件概率密度。先验概率密度：</p>
<p>$$P(Y=c_k) , k= 1,2, \cdots ,K$$</p>
<p>条件概率密度：</p>
<p>$$P(X=x|Y=c_k) = P(X^{(1)}=x^{(1)},\cdots , X^{(n)}=x^{(n)} |Y=c_k), k= 1,2, \cdots ,K$$</p>
<p>于是学习到联合概率分布P(X,Y).</p>
<p>朴素贝叶斯法对条件概率分布作了条件独立性的假设：</p>
<p>$$P(X=x|Y=c_k) = P(X^{(1)}=x^{(1)},\cdots , X^{(n)}=x^{(n)} |Y=c_k)=\prod_{j=1}^n P(X^{(j)}=x^{(j)} | Y = c_k)$$</p>
<p>朴素贝叶斯法实际上学习到的是生成数据的机制，所以属于生成模型。条件独立性假设是说用于分类的特征在类确定的情况都是条件独立的，这一假设会使得朴素贝叶斯法变得简单，但有时会牺牲一定的分类准确率。</p>
<p>朴素贝叶斯法时，对给定的输入x，通过学习到的模型计算后验概率分布$P(Y=c_k|X=x)$，将后验概率最大的类作为x的类输出，后验概率计算根据贝叶斯定理进行：</p>
<p>$$P(Y=c_k|X=x)= \frac{P(X=x|Y=c_k)P(Y=c_k)}{\sum_k P(X=x|Y=c_k)P(Y=c_k)}$$</p>
<p>将条件独立性假设公式带入上式，得：</p>
<p>$$P(Y=c_k|X=x)= \frac{P(Y=c_k)\prod_jP(X^{(j)}=x^{(j)}|Y=c_k)}{\sum_k P(Y=c_k)\prod_jP(X^{(j)}=x^{(j)}s|Y=c_k)} , k=1,2, \cdots ,K$$</p>
<p>考虑到分母对所有的$c_k$都相同，朴素贝叶斯分类器可表示为：</p>
<p>$$y =  arg \max_{c_k}P(Y=c_k)\prod_jP(X^{(j)}=x^{(j)}|Y=c_k)$$</p>
<h3 id="后验概率最大化的含义"><a href="#后验概率最大化的含义" class="headerlink" title="后验概率最大化的含义"></a>后验概率最大化的含义</h3><p>朴素贝叶斯法将实例分到后验概率最大的类中，这等价于期望风险最小化，假设选择0-1损失函数：</p>
<p>$$
L(Y,f(X))=
\begin{cases}
0&amp; Y=f(x)\\
1&amp; Y \neq f(X)
\end{cases}
$$</p>
<p>式中f(X)是分类决策函数，这时期望风险函数为：</p>
<p>$$R_{exp}(f)=E[L(Y,f(X))]$$</p>
<p>期望是对联合分布P(X,Y)取的，由此取期望：</p>
<p>$$R_{exp}(f)=E_X\sum_{k=1}^{K}[L(c_k,f(X))]P(c_k|X)$$</p>
<p>为了使期望风险最小化，只需对X=x逐个最小化，由此得到：</p>
<p>$$f(x)= \arg \min_{y \in \mathcal{Y}} P(y=c_k|X=x)$$</p>
<h2 id="朴素贝叶斯法的参数估计"><a href="#朴素贝叶斯法的参数估计" class="headerlink" title="朴素贝叶斯法的参数估计"></a>朴素贝叶斯法的参数估计</h2><h3 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h3><p>在朴素贝叶斯法中，学习意味着估计$P(Y=c_k)和P(X^{(j)}=x^{(j)}| Y=c_k)$,可以应用极大似然估计法估计相应的概率。先验概率$P(Y=c_k)$的极大似然估计是：</p>
<p>$$P(Y=c_k)=\frac{\sum_{i=1}^NI(y_i=c_k)}{N},k=1,2,\cdots ,K$$</p>
<p>设第j个特征$x^{(j)}$可能取值的集合为$\{a_{j1},a_{j2},\cdots ,a_{jS_j}\}$,条件概率$P(X^{(j)}=a_{jl}|Y=c_k)$的极大似然估计是：</p>
<p>$$P(X^{(j)}=a_{jl}|Y=c_k)=\frac{\sum_{i=1}^NI(x_i^{(j)}=a_{jl},y_i=c_k)}{\sum_{i=1}^NI(y_i=c_k)}, j=1,2,\cdots ,n;l=1,2,\cdots ,S_j;k=1,2,\cdots ,K$$</p>
<p>式中，$x_i^{(j)}$是第i个样本的第j个特征；$a_{jl}$是第j个特征可能取的第l个值；I为指示函数。</p>
<h3 id="学习与分类方法"><a href="#学习与分类方法" class="headerlink" title="学习与分类方法"></a>学习与分类方法</h3><p><strong>朴素贝叶斯算法</strong></p>
<p>输入：训练数据集$T=\{(x_1,y_1),(x_2,y_2),\cdots ,(x_N,y_N)\}$,其中$x_i=(x_i^{(1)},\cdots , x_i^{(n)})^T,x_i^{(j)}$是第i个样本的第j个特征，$x_i^{(j)} \in \{a_{j1},a_{j2}, \cdots ,a_{jS_j}\},a_{jl}$是第j个特征可能取的第l个值，$j=1,2,\cdots ,n;l=1,2, \cdots ,S_j;y_i \in \{c_1,c_2,\cdots ,c_K\}$;实例x;
输出：实例x的分类</p>
<p>(1) 计算先验概率及条件概率</p>
<p>$$P(Y=c_k)=\frac{\sum_{i=1}^NI(y_i=c_k)}{N},k=1,2,\cdots ,K$$</p>
<p>$$P(X^{(j)}=a_{jl} | Y= c_k)=\frac{\sum_{i=1}^NY(x_i^{(j)}=a_{jl},y_i=c_k)}{\sum_{i=1}^NI(y_i=c_k)},j=1,2,\cdots,n;l=1,2,\cdots,S_j;k=1,2,\cdots,K$$</p>
<p>(2) 对于给定的实例$x=(x^{(1)},x^{(2)},\cdots ,x^{(n)})^T$,计算：</p>
<p>$$P(Y=c_k)\prod_jP(X^{(j)}=x^{(j)}s|Y=c_k) , k=1,2, \cdots ,K$$</p>
<p>(3) 确定实例x的分类</p>
<p>$$y =  arg \max_{c_k}P(Y=c_k)\prod_jP(X^{(j)}=x^{(j)}|Y=c_k)$$</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>试由下表的训练数据学习一个朴素贝叶斯分类器并确定$x=(2,S)^T$的类标记y，表中$X^{(1)},X^{(2)}$为特征，取值的集合分别为$A_1=\{1,2,3\},A_2=\{S,M,L\}$,Y为类标记，$Y \in C =\{1,-1\}$</p>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
</tr>
</thead>
<tbody>
<tr>
<td>$X^{(1)}$</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>$X^{(2)}$</td>
<td>S</td>
<td>M</td>
<td>M</td>
<td>S</td>
<td>S</td>
<td>S</td>
<td>M</td>
<td>M</td>
<td>L</td>
<td>L</td>
<td>L</td>
<td>M</td>
<td>M</td>
<td>L</td>
<td>L</td>
</tr>
<tr>
<td>$Y$</td>
<td>-1</td>
<td>-1</td>
<td>1</td>
<td>1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>-1</td>
</tr>
</tbody>
</table>
<p>根据朴素贝叶斯分类器，容易计算下列概率：</p>
<p>$P(Y=1)=9/15,p(Y=-1)=6/15$</p>
<p>$P(X^{(1)}=1|Y=1)=2/9,P(X^{(1)}=2|Y=1)=3/9,P(X^{(1)}=3|Y=1)=4/9$</p>
<p>$P(X^{(2)}=S|Y=1)=1/9,P(X^{(2)}=M|Y=1)=4/9,P(X^{(2)}=L|Y=1)=4/9$</p>
<p>$P(X^{(1)}=1|Y=-1)=3/6,P(X^{(1)}=2|Y=-1)=2/6,P(X^{(1)}=3|Y=-1)=1/6$</p>
<p>$P(X^{(2)}=S|Y=-1)=3/6,P(X^{(2)}=M|Y=-1)=2/6,P(X^{(2)}=L|Y=-1)=1/6$</p>
<p>于是，对于给定的$x=(2,S)^T$,计算：</p>
<p>$P(Y=1)P(X^{(1)}=2|Y=1)P(X^{(2)}=S|Y=1)=9/15\cdot 3/9 \cdot 1/9=1/45$</p>
<p>$P(Y=-1)P(X^{(1)}=2|Y=-1)P(X^{(2)}=S|Y=-1)=6/15\cdot 2/6 \cdot 3/6=1/15$</p>
<p>故$y=-1$</p>
<h3 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h3><p>用极大似然估计可能会出现所要估计的概率的值为0的情况，这时会影响到后验概率的计算结果，使分类出现偏差，解决这一问题的方法是采用贝叶斯估计。具体地，条件概率的贝叶斯估计是</p>
<p>$$P_{\lambda}(X^{(j)}=a_{jl}|Y=c_k)=\frac{\sum_{i=1}^NI(x_i^{(j)},y_i=c_k)+\lambda}{\sum_{i=1}^NI(y_i=c_k)+S_j\lambda}$$</p>
<p>式中$\lambda \geq 0$，等价于在随机变量各个取值的频数上赋予一个正数λ&gt;0,当λ=0时就是极大似然估计。常取λ=1，这时称为拉普拉斯平滑(Laplace smoothing)。显然，对任何$l=1,2,\cdots ,S_j,k=1,2, \cdots ,K$，有</p>
<p>$$P_{\lambda}(X^{(j)}=a_{jl}|Y=c_k)&gt;0$$</p>
<p>$$\sum_{l=1}^{S_j}P(X^{(j)}=a_{jl}|Y=c_k)=1$$</p>
<p>表明上式确为一种概率分布，同样先验概率的贝叶斯估计是</p>
<p>$$P_{\lambda}(Y=c_k)=\frac{\sum_{i=1}^NI(y_i=c_k)+\lambda}{N+K\lambda}$$</p>
<h3 id="综合：python实现简单情感极性分析器"><a href="#综合：python实现简单情感极性分析器" class="headerlink" title="综合：python实现简单情感极性分析器"></a>综合：python实现简单情感极性分析器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Filename: Bayes.py</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log, exp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LaplaceEstimate</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    拉普拉斯平滑处理的贝叶斯估计</span><br><span class="line">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.d = &#123;&#125;  <span class="comment"># [词-词频]的map</span></span><br><span class="line">        self.total = <span class="number">0.0</span>  <span class="comment"># 全部词的词频</span></span><br><span class="line">        self.none = <span class="number">1</span>  <span class="comment"># 当一个词不存在的时候，它的词频（等于0+1）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exists</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> self.d</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getsum</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.total</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.exists(key):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span>, self.none</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span>, self.d[key]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getprob</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        估计先验概率</span><br><span class="line">        :param key: 词</span><br><span class="line">        :return: 概率</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> float(self.get(key)[<span class="number">1</span>]) / self.total</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">samples</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        获取全部样本</span><br><span class="line">        :return:</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.d.keys()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        self.total += value</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.exists(key):</span><br><span class="line">            self.d[key] = <span class="number">1</span></span><br><span class="line">            self.total += <span class="number">1</span></span><br><span class="line">        self.d[key] += value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bayes</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.d = &#123;&#125;  <span class="comment"># [标签, 概率] map</span></span><br><span class="line">        self.total = <span class="number">0</span>  <span class="comment"># 全部词频</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> data:  <span class="comment"># d是[[词链表], 标签]</span></span><br><span class="line">            c = d[<span class="number">1</span>]  <span class="comment"># c是分类</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> self.d:</span><br><span class="line">                self.d[c] = LaplaceEstimate()  <span class="comment"># d[c]是概率统计工具</span></span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> d[<span class="number">0</span>]:</span><br><span class="line">                self.d[c].add(word, <span class="number">1</span>)  <span class="comment"># 统计词频</span></span><br><span class="line">        self.total = sum(map(<span class="keyword">lambda</span> x: self.d[x].getsum(), self.d.keys()))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">classify</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        tmp = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> self.d:  <span class="comment"># 分类</span></span><br><span class="line">            tmp[c] = log(self.d[c].getsum()) - log(self.total)  <span class="comment"># P(Y=ck)</span></span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> x:</span><br><span class="line">                tmp[c] += log(self.d[c].getprob(word))          <span class="comment"># P(Xj=xj | Y=ck)</span></span><br><span class="line">        ret, prob = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> self.d:</span><br><span class="line">            now = <span class="number">0</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">for</span> otherc <span class="keyword">in</span> self.d:</span><br><span class="line">                    now += exp(tmp[otherc] - tmp[c])            <span class="comment"># 将对数还原为1/p</span></span><br><span class="line">                now = <span class="number">1</span> / now</span><br><span class="line">            <span class="keyword">except</span> OverflowError:</span><br><span class="line">                now = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> now &gt; prob:</span><br><span class="line">                ret, prob = c, now</span><br><span class="line">        <span class="keyword">return</span> (ret, prob)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentiment</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.classifier = Bayes()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">segment</span><span class="params">(self, sent)</span>:</span></span><br><span class="line">        words = sent.split(<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">return</span> words</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, neg_docs, pos_docs)</span>:</span></span><br><span class="line">        data = []</span><br><span class="line">        <span class="keyword">for</span> sent <span class="keyword">in</span> neg_docs:</span><br><span class="line">            data.append([self.segment(sent), <span class="string">'消极'</span>])</span><br><span class="line">        <span class="keyword">for</span> sent <span class="keyword">in</span> pos_docs:</span><br><span class="line">            data.append([self.segment(sent), <span class="string">'积极'</span>])</span><br><span class="line">        self.classifier.train(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">classify</span><span class="params">(self, sent)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.classifier.classify(self.segment(sent))</span><br><span class="line"></span><br><span class="line">s = Sentiment()</span><br><span class="line">s.train([<span class="string">'糟糕'</span>, <span class="string">'好 差劲'</span>,<span class="string">'坏'</span>,<span class="string">'好 坏'</span>], [<span class="string">'优秀'</span>, <span class="string">'很 好'</span>,<span class="string">'棒'</span>,<span class="string">'好 人'</span>]) <span class="comment"># 空格分词</span></span><br><span class="line"></span><br><span class="line">print(s.classify(<span class="string">"好 棒"</span>))</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">'积极'</span>, <span class="number">0.6451612903225805</span>)</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[统计学习方法——K近邻算法]]></title>
      <url>http://keyunluo.github.io/2016/08/15/2016-08-15-statical-learning-3.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>k近邻算法(k-nearest neighbor,k-NN)是一种基本的分类与回归算法，不具有显式的学习过程。k值选择、距离度量以及分类决策规则是k近邻算法的三个基本要素。本节对应于统计学习方法第三章的内容。</p>
</blockquote>
<a id="more"></a>
<h2 id="K近邻算法"><a href="#K近邻算法" class="headerlink" title="K近邻算法"></a>K近邻算法</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>给定一个训练数据集，对新的输入实例，在训练数据集中找到跟它最近的k个实例，根据这k个实例的类判断它自己的类（一般采用多数表决的方法）。</p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>输入： 训练数据集 $T=\{(x_1,y_1),(x_2,y_2),\cdots ,(x_N,y_N)\}, 其中，x_i \in \mathcal{X} \subseteq R^n 为实例的特征向量，y_i \in \mathcal{Y} = \{c_1,c_2,\cdots ,c_K \}为实例的类别，i = 1,2,\cdots ,N;实例特征向量x;$</p>
<p>输出：实例x所属的类别y</p>
<p>(1) 根据给定的距离度量，在训练集T中找出与x最邻近的k个点，涵盖这k个点的x的领域记为$N_k(x)$;</p>
<p>(2) 在$N_k(x)$中根据分类决策规则(如多数表决)决定x的类别y:</p>
<p>$$y = arg max_{c_j} \sum_{x_i \in N_k(x)} I(y_i = c_j),i=1,2, \cdots ,N;j = 1,2, \cdots ,K$$</p>
<p>式中I为指示函数，即当$y_i=c_i$时I为1，否则I为0.</p>
<p>k近邻算法的特殊情况是k=1的情形，称为最近邻算法。对于输入的实例点x，最近邻法将训练数据集中与x最邻近的类作为x的类。</p>
<h2 id="K近邻模型"><a href="#K近邻模型" class="headerlink" title="K近邻模型"></a>K近邻模型</h2><p>模型有3个要素——距离度量方法、k值的选择和分类决策规则。</p>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>当3要素确定的时候，对任何实例（训练或输入），它所属的类都是确定的，相当于将特征空间分为一些子空间。</p>
<p><img src="/resource/blog/2016-08/k近邻模型.jpg" alt="k近邻模型"></p>
<h3 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h3><p>对n维实数向量空间$R^n$，经常用$L_p$距离或曼哈顿$Minkowski$距离。</p>
<p>设特征空间$\mathcal{X}$是n维实数向量空间$R^n,x_i,x_j \in \mathcal{X}, x_i = (x_i^{(1)},x_i^{(2)},\cdots , x_i^{(n)})^T,x_j = (x_j^{(1)},x_j^{(2)},\cdots , x_j^{(n)})^T,x_i,x_j的L_p距离定义为：$</p>
<p>$$L_p(x_i,x_j)=\left( \sum_{l=1}^{n} \vert x_i^{(l)}-x_j^{(l)} \vert ^p \right)^{\frac{1}{p}}$$</p>
<p>这里$p \geq 1$,当p=2时，称为欧氏距离(Euclidean distance)，即：</p>
<p>$$L_2(x_i,x_j)=\left( \sum_{l=1}^{n} \vert x_i^{(l)}-x_j^{(l)} \vert ^2 \right ) ^{\frac{1}{2}}$$</p>
<p>当p=1时，称为曼哈顿距离(Manhattan distance),即：</p>
<p>$$L_1(x_i,x_j)=\sum_{l=1}^{n} \vert x_i^{(l)}-x_j^{(l)} \vert $$</p>
<p>当$p=\infty$时，它是各个坐标距离的最大值,即：</p>
<p>$$L_{\infty}(x_i,x_j)=\max \vert x_i^{(l)}-x_j^{(l)} \vert $$</p>
<h3 id="k值的选择"><a href="#k值的选择" class="headerlink" title="k值的选择"></a>k值的选择</h3><p>k较小，容易被噪声影响，发生过拟合。</p>
<p>k较大，较远的训练实例也会对预测起作用，容易发生错误。</p>
<p>在应用中，k值一般取一个比较小的数值，通常采用交叉验证法来选取最优的k值。</p>
<h3 id="分类决策规则"><a href="#分类决策规则" class="headerlink" title="分类决策规则"></a>分类决策规则</h3><p>使用0-1损失函数衡量，那么误分类率是：</p>
<p>$$\frac{1}{k} \sum_{x_i \in N_k(x)} I(y_i \not= c_j) = 1- \frac{1}{k}\sum_{x_i \in N_k(x)} I(y_i = c_j)$$</p>
<p>$N_k$是近邻集合，要使左边最小，右边$\sum_{x_i \in N_k(x)} I(y_i = c_j)$必须最大，所以多数表决等价于经验风险最小化。</p>
<h2 id="kd树"><a href="#kd树" class="headerlink" title="kd树"></a>kd树</h2><p>算法核心在于怎么快速搜索k个近邻出来，朴素做法是线性扫描，不可取，这里介绍的方法是kd树。</p>
<h3 id="构造kd树"><a href="#构造kd树" class="headerlink" title="构造kd树"></a>构造kd树</h3><p>对数据集T中的子集S初始化S=T，取当前节点node=root取维数的序数i=0，对S递归执行：</p>
<p>找出S的第i维的中位数对应的点，通过该点，且垂直于第i维坐标轴做一个超平面。该点加入node的子节点。该超平面将空间分为两个部分，对这两个部分分别重复此操作（S=S’，++i，node=current），直到不可再分。</p>
<h4 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h4><p>输入：k维空间数据集 $T=\{x_1,x_2,…,x_N\}$,其中$x_i=(x_i^{(1)},x_i^{(2)},\cdots ,x_i^{(k)})^T,i=1,2,\cdots ,N$</p>
<p>输出： kd树</p>
<p>(1) 开始：构造根节点，根节点对应于包含T的k维空间的超矩形区域：选择$x^{(1)}$为坐标轴，以T中所有实例的$x^{(1)}$坐标的中位数为切分点，将根节点对应的超矩形区域切分为两个子区域。切分由通过切分点并与坐标轴$x^{(1)}$垂直的超平面实现。</p>
<p>由根节点生成深度为1的左右子节点：左子节点对应坐标$x^{(1)}$小于切分点的子区域，右子节点对应坐标$x^{(1)}$大于切分点的子区域。</p>
<p>将落在切分超平面的实例点保存在根节点。</p>
<p>(2) 重复：对深度为j的节点，选择$x^{(l)}$为切分的坐标轴，$l=j(mod k) +1$,以该节点的区域中所有实例的$x^{(l)}$坐标的中位数为切分点，将该节点对应的超矩形区域切分为两个子区域，切分由通过切分点并与坐标轴$x^{(l)}$垂直的超平面实现。</p>
<p>由该节点生成深度为j+1的左右子节点：左子节点对应坐标$x^{(l)}$小于切分点的子区域，右子节点对应坐标$x^{(l)}$大于切分点的子区域。</p>
<p>将落在切分超平面的实例点保存在根节点。</p>
<p>(3) 直到两个子区域没有实例存在时停止，从而形成kd树的区域划分。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>给定一个二维空间的数据集：$T=\{(2,3)^T,(5,4)^T,(9,6)^T,(4,7)^T,(8,1)^T,(7,2)^T\}$,
构造一棵平衡kd树。</p>
<h4 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">T = [[<span class="number">2</span>, <span class="number">3</span>], [<span class="number">5</span>, <span class="number">4</span>], [<span class="number">9</span>, <span class="number">6</span>], [<span class="number">4</span>, <span class="number">7</span>], [<span class="number">8</span>, <span class="number">1</span>], [<span class="number">7</span>, <span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, point)</span>:</span></span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line">        self.point = point</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">median</span><span class="params">(lst)</span>:</span></span><br><span class="line">    m = int(len(lst) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> lst[m], m</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_kdtree</span><span class="params">(data, d)</span>:</span></span><br><span class="line">    data = sorted(data, key=<span class="keyword">lambda</span> x: x[d])</span><br><span class="line">    p, m = median(data)</span><br><span class="line">    tree = node(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">del</span> data[m]</span><br><span class="line">    print(data, p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> m &gt; <span class="number">0</span>: tree.left = build_kdtree(data[:m], <span class="keyword">not</span> d)</span><br><span class="line">    <span class="keyword">if</span> len(data) &gt; <span class="number">1</span>: tree.right = build_kdtree(data[m:], <span class="keyword">not</span> d)</span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line"></span><br><span class="line">kd_tree = build_kdtree(T, <span class="number">0</span>)</span><br><span class="line">print(kd_tree)</span><br></pre></td></tr></table></figure>
<h4 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Filename: kdtree.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Rectangle</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> animation</span><br><span class="line"></span><br><span class="line">T = [[<span class="number">2</span>, <span class="number">3</span>], [<span class="number">5</span>, <span class="number">4</span>], [<span class="number">9</span>, <span class="number">6</span>], [<span class="number">4</span>, <span class="number">7</span>], [<span class="number">8</span>, <span class="number">1</span>], [<span class="number">7</span>, <span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_point</span><span class="params">(data)</span>:</span></span><br><span class="line">    X, Y = [], []</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> data:</span><br><span class="line">        X.append(p[<span class="number">0</span>])</span><br><span class="line">        Y.append(p[<span class="number">1</span>])</span><br><span class="line">    plt.plot(X, Y, <span class="string">'bo'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_line</span><span class="params">(xy_list)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> xy <span class="keyword">in</span> xy_list:</span><br><span class="line">        x, y = xy</span><br><span class="line">        plt.plot(x, y, <span class="string">'g'</span>, lw=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_square</span><span class="params">(square_list)</span>:</span></span><br><span class="line">    currentAxis = plt.gca()</span><br><span class="line">    colors = itertools.cycle([<span class="string">"r"</span>, <span class="string">"b"</span>, <span class="string">"g"</span>, <span class="string">"c"</span>, <span class="string">"m"</span>, <span class="string">"y"</span>, <span class="string">'#EB70AA'</span>, <span class="string">'#0099FF'</span>])</span><br><span class="line">    <span class="keyword">for</span> square <span class="keyword">in</span> square_list:</span><br><span class="line">        currentAxis.add_patch(</span><br><span class="line">            Rectangle((square[<span class="number">0</span>][<span class="number">0</span>], square[<span class="number">0</span>][<span class="number">1</span>]), square[<span class="number">1</span>][<span class="number">0</span>] - square[<span class="number">0</span>][<span class="number">0</span>], square[<span class="number">1</span>][<span class="number">1</span>] - square[<span class="number">0</span>][<span class="number">1</span>],</span><br><span class="line">                      color=next(colors)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">median</span><span class="params">(lst)</span>:</span></span><br><span class="line">    m = int(len(lst) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> lst[m], m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">history_quare = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_kdtree</span><span class="params">(data, d, square)</span>:</span></span><br><span class="line">    history_quare.append(square)</span><br><span class="line">    data = sorted(data, key=<span class="keyword">lambda</span> x: x[d])</span><br><span class="line">    p, m = median(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">del</span> data[m]</span><br><span class="line">    print(data, p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> m &gt;= <span class="number">0</span>:</span><br><span class="line">        sub_square = copy.deepcopy(square)</span><br><span class="line">        <span class="keyword">if</span> d == <span class="number">0</span>:</span><br><span class="line">            sub_square[<span class="number">1</span>][<span class="number">0</span>] = p[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sub_square[<span class="number">1</span>][<span class="number">1</span>] = p[<span class="number">1</span>]</span><br><span class="line">        history_quare.append(sub_square)</span><br><span class="line">        <span class="keyword">if</span> m &gt; <span class="number">0</span>: build_kdtree(data[:m], <span class="keyword">not</span> d, sub_square)</span><br><span class="line">    <span class="keyword">if</span> len(data) &gt; <span class="number">1</span>:</span><br><span class="line">        sub_square = copy.deepcopy(square)</span><br><span class="line">        <span class="keyword">if</span> d == <span class="number">0</span>:</span><br><span class="line">            sub_square[<span class="number">0</span>][<span class="number">0</span>] = p[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sub_square[<span class="number">0</span>][<span class="number">1</span>] = p[<span class="number">1</span>]</span><br><span class="line">        build_kdtree(data[m:], <span class="keyword">not</span> d, sub_square)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">build_kdtree(T, <span class="number">0</span>, [[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">10</span>, <span class="number">10</span>]])</span><br><span class="line">print(history_quare)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># draw an animation to show how it works, the data comes from history</span></span><br><span class="line"><span class="comment"># first set up the figure, the axis, and the plot element we want to animate</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = plt.axes(xlim=(<span class="number">0</span>, <span class="number">2</span>), ylim=(<span class="number">-2</span>, <span class="number">2</span>))</span><br><span class="line">line, = ax.plot([], [], <span class="string">'g'</span>, lw=<span class="number">2</span>)</span><br><span class="line">label = ax.text([], [], <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># initialization function: plot the background of each frame</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">()</span>:</span></span><br><span class="line">    plt.axis([<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">10</span>])</span><br><span class="line">    plt.grid(<span class="keyword">True</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'x_1'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'x_2'</span>)</span><br><span class="line">    plt.title(<span class="string">'构造KD树'</span>)</span><br><span class="line">    draw_point(T)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">currentAxis = plt.gca()</span><br><span class="line">colors = itertools.cycle([<span class="string">"#FF6633"</span>, <span class="string">"g"</span>, <span class="string">"#3366FF"</span>, <span class="string">"c"</span>, <span class="string">"m"</span>, <span class="string">"y"</span>, <span class="string">'#EB70AA'</span>, <span class="string">'#0099FF'</span>, <span class="string">'#66FFFF'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># animation function.  this is called sequentially</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">animate</span><span class="params">(i)</span>:</span></span><br><span class="line">    square = history_quare[i]</span><br><span class="line">    currentAxis.add_patch(</span><br><span class="line">        Rectangle((square[<span class="number">0</span>][<span class="number">0</span>], square[<span class="number">0</span>][<span class="number">1</span>]), square[<span class="number">1</span>][<span class="number">0</span>] - square[<span class="number">0</span>][<span class="number">0</span>], square[<span class="number">1</span>][<span class="number">1</span>] - square[<span class="number">0</span>][<span class="number">1</span>],</span><br><span class="line">                  color=next(colors)))</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># call the animator.  blit=true means only re-draw the parts that have changed.</span></span><br><span class="line">anim = animation.FuncAnimation(fig, animate, init_func=init, frames=len(history_quare), interval=<span class="number">1000</span>, repeat=<span class="keyword">False</span>,</span><br><span class="line">                               blit=<span class="keyword">False</span>)</span><br><span class="line">plt.show()</span><br><span class="line">anim.save(<span class="string">'kdtree_build.gif'</span>, fps=<span class="number">2</span>, writer=<span class="string">'imagemagick'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/resource/blog/2016-08/kdtree_build.gif" alt="构建kd树"></p>
<h3 id="搜索kd树"><a href="#搜索kd树" class="headerlink" title="搜索kd树"></a>搜索kd树</h3><h4 id="算法流程-2"><a href="#算法流程-2" class="headerlink" title="算法流程"></a>算法流程</h4><p>搜索跟二叉树一样，是一个递归的过程。先找到目标点的插入位置，然后往上走，逐步用自己到目标点的距离画个超球体，用超球体圈住的点来更新最近邻（或k最近邻）。</p>
<p>输入：已构造的kd树，目标点x</p>
<p>输出：x的最近邻</p>
<p>(1) 在kd树中找到包含目标点x的叶节点：从根节点出发，递归的向下访问kd树。若目标点x当前维的坐标小于切分点的坐标，则移动到左子节点，否则移动到右子节点。直到子节点为叶节点为止。</p>
<p>(2) 以此叶节点为“当前最近点”</p>
<p>(3) 递归的向上回退，在每个节点进行如下操作：</p>
<ul>
<li>如果该节点保存的实例点比当前最近点距离目标点更近，则以该实例点为“当前最近点”</li>
<li>当前最近点一定存在于该节点一个子节点对应的区域，检查该子节点的父节点的另一子节点对应的区域是否有更近的点。具体的，检查另一子节点对应的区域是否以目标点为球心、以目标点与“当前最近点”间的距离为半径的超球体相交。如果相交，可能在另一个子节点对应的区域内存在距离目标点更近的点，移动到另一个子节点，接着，递归地进行最近邻搜索。如果不相交，向上回退</li>
</ul>
<p>(4) 当回退到根节点时，搜索结束。最后的“当前最近点”即为x的最近邻点。</p>
<h4 id="python实现-1"><a href="#python实现-1" class="headerlink" title="python实现"></a>python实现</h4><p>以最近邻为例，实现如下（本实现由于测试数据简单，没有做超球体与超立体相交的逻辑）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># Filename: search_kdtree.py</span></span><br><span class="line"></span><br><span class="line">T = [[<span class="number">2</span>, <span class="number">3</span>], [<span class="number">5</span>, <span class="number">4</span>], [<span class="number">9</span>, <span class="number">6</span>], [<span class="number">4</span>, <span class="number">7</span>], [<span class="number">8</span>, <span class="number">1</span>], [<span class="number">7</span>, <span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, point)</span>:</span></span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line">        self.point = point</span><br><span class="line">        self.parent = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_left</span><span class="params">(self, left)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="keyword">None</span>: <span class="keyword">pass</span></span><br><span class="line">        left.parent = self</span><br><span class="line">        self.left = left</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_right</span><span class="params">(self, right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> right == <span class="keyword">None</span>: <span class="keyword">pass</span></span><br><span class="line">        right.parent = self</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">median</span><span class="params">(lst)</span>:</span></span><br><span class="line">    m = int(len(lst) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> lst[m], m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_kdtree</span><span class="params">(data, d)</span>:</span></span><br><span class="line">    data = sorted(data, key=<span class="keyword">lambda</span> x: x[d])</span><br><span class="line">    p, m = median(data)</span><br><span class="line">    tree = node(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">del</span> data[m]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> m &gt; <span class="number">0</span>: tree.set_left(build_kdtree(data[:m], <span class="keyword">not</span> d))</span><br><span class="line">    <span class="keyword">if</span> len(data) &gt; <span class="number">1</span>: tree.set_right(build_kdtree(data[m:], <span class="keyword">not</span> d))</span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distance</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    print(a, b)</span><br><span class="line">    <span class="keyword">return</span> ((a[<span class="number">0</span>] - b[<span class="number">0</span>]) ** <span class="number">2</span> + (a[<span class="number">1</span>] - b[<span class="number">1</span>]) ** <span class="number">2</span>) ** <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_kdtree</span><span class="params">(tree, d, target)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> target[d] &lt; tree.point[d]:</span><br><span class="line">        <span class="keyword">if</span> tree.left != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> search_kdtree(tree.left, <span class="keyword">not</span> d, target)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> tree.right != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> search_kdtree(tree.right, <span class="keyword">not</span> d, target)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_best</span><span class="params">(t, best)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> t == <span class="keyword">None</span>: <span class="keyword">return</span></span><br><span class="line">        t = t.point</span><br><span class="line">        d = distance(t, target)</span><br><span class="line">        <span class="keyword">if</span> d &lt; best[<span class="number">1</span>]:</span><br><span class="line">            best[<span class="number">1</span>] = d</span><br><span class="line">            best[<span class="number">0</span>] = t</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    best = [tree.point, <span class="number">100000.0</span>]</span><br><span class="line">    <span class="keyword">while</span> (tree.parent != <span class="keyword">None</span>):</span><br><span class="line">        update_best(tree.parent.left, best)</span><br><span class="line">        update_best(tree.parent.right, best)</span><br><span class="line">        tree = tree.parent</span><br><span class="line">    <span class="keyword">return</span> best[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kd_tree = build_kdtree(T, <span class="number">0</span>)</span><br><span class="line">print(search_kdtree(kd_tree, <span class="number">0</span>, [<span class="number">9</span>, <span class="number">4</span>]))</span><br></pre></td></tr></table></figure>
<p>输出
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">8</span>, <span class="number">1</span>] [<span class="number">9</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>] [<span class="number">9</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">6</span>] [<span class="number">9</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop源码学习(14)——压缩(2)]]></title>
      <url>http://keyunluo.github.io/2016/08/15/2016-08-15-hadoop-io-10.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>数据压缩往往是计算密集型操作，考虑到性能，建议使用本地库(Native Library)来压缩和解压缩。Snappy在Google的生产环境中经过了PB级数据压缩的考验，具有优良的性能，以Snappy为例，学习在Hadoop提供的压缩框架下集成新的压缩算法。</p>
</blockquote>
<a id="more"></a>
<h2 id="Java本地化方法"><a href="#Java本地化方法" class="headerlink" title="Java本地化方法"></a>Java本地化方法</h2><p>Hadoop的DEFLATE、gzip和Snappy都支持算法的本地化实现，默认情况下，Hadoop会在它运行的平台上查找本地库。</p>
<table>
<thead>
<tr>
<th style="text-align:left">压缩类型</th>
<th style="text-align:left">Java实现</th>
<th style="text-align:left">原生实现</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DEFLATE</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">gzip</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">bzip2</td>
<td style="text-align:left">Yes Yes</td>
</tr>
<tr>
<td style="text-align:left">LZO</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">LZ4</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">Snappy</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
</tbody>
</table>
<p>Java提供了一些钩子函数，使得调用本地方法成为可能。Java语言中的关键字native用于表示某个方法为本地方法，显然，本地方法是类的成员方法。例如，下面的例子中在org.apache.hadoop.io.compress.snappy包中，类SnappyCompressor的静态方法initIDs()和方法compressByteDirect()用关键字native修饰，表明这是一个本地化方法。</p>
<p>实际上，如果什么都不做也可以编译这个类，但是当使用这个类的时候，Java虚拟机会告诉你无法找到上述两个方法。要想实现这两个本地方法，一般需要三个步骤：</p>
<ul>
<li>为方法生成一个Java调用和实际C函数转换的C存根</li>
<li>建立一个共享库并导出该存根</li>
<li>使用System.loadLibrary()方法通知Java运行环境加载共享库</li>
</ul>
<p>Java为C存根的生成提供了实用程序javah，以上面的SnappyCompressor为例，可以在build/classes目录下执行命令：<code>javah org.apache.hadoop.io.compress.snappy.SnappyCompressor</code>,系统会生成一个头文件：<code>org_apache_hadoop_io_compress_snappy_SnappyCompressor.h</code>,该头文件包含上述两个本地方法相应的声明：</p>
<ul>
<li>Java_org_apache_hadoop_io_compress_snappy_SnappyCompressor_initIDs</li>
<li>Java_org_apache_hadoop_io_compress_snappy_SnappyCompressor_compressBytesDirect</li>
</ul>
<p>这两个声明遵从了Java本地方法的命名规则，以Java起首，然后是类的名字、方法名。声明中的JNIEXPORT和JNICALL命令表明了这两个方法会被JNI调用。上述第一个声明对应的方法是Java…initIDs，由于是一个静态方法，它的参数类型为JNIEnv的指针，用于和JVM通信。JNIEnv提供了大量的函数，可以执行类和对象的相关方法，也可以访问对象的成员变量或类的静态变量，参数jclass提供了引用静态方法对应类的机制，而Java…compressBytesDirect中的jobject相当于this引用，这两个参数大量应用于JNI提供的C API中。</p>
<p>JNIEnv提供了C代码和Java虚拟机通信的环境，GetObjectField()函数可用于获得对象的一个域，GetIntField()可用于得到Java对象的整型成员变量，SetField()设置Java对象的整型成员变量的值。最后使用System.loadLibrary()方法调用在java.library.path指定的路径下，寻找并加载附加驱动的动态库，如Snappy的libsnappy.so库。</p>
<h2 id="CodecPool"><a href="#CodecPool" class="headerlink" title="CodecPool"></a>CodecPool</h2><p>如果使用的是原生代码库并且需要在应用中执行大量压缩和解压缩操作，可以考虑使用 CodecPool。它支持反复使用压缩和解压缩，以分摊创建这些对象的开销。</p>
<p>下面的代码显示了API函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledStreamCompressor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  String codecClassname = args[<span class="number">0</span>];</span><br><span class="line">  Class&lt;?&gt; codecClass = Class.forName(codecClassname);</span><br><span class="line">  Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">  CompressionCodec codec = (CompressionCodec)</span><br><span class="line">  ReflectionUtils.newInstance(codecClass, conf);</span><br><span class="line">  Compressor compressor = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    compressor = CodecPool.getCompressor(codec);</span><br><span class="line">    CompressionOutputStream out = codec.createOutputStream(System.out, compressor);</span><br><span class="line">    IOUtils.copyBytes(System.in, out, <span class="number">4096</span>, <span class="keyword">false</span>);</span><br><span class="line">    out.finish();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  CodecPool.returnCompressor(compressor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在codec的重载方法createOutputStream()中，对于指定的CompressionCodec，我们从池中获取一个Compressor实例。通过使用finally数据块，我们在不同的数据流之家来回复制数据，即使出现IOException异常，也可以确保compressor可以返回池中。</p>
<h2 id="支持Snappy压缩"><a href="#支持Snappy压缩" class="headerlink" title="支持Snappy压缩"></a>支持Snappy压缩</h2><p>org.apache.hadoop.io.compress.snappy包括支持Snappy的压缩器SnappyCompressor和解压器SnappyDecompressor。LoadSnappy类用于判断Snappy本地库是否可用，如果可用，则通过System.loadLibrary()加载本地库。</p>
<p>SnappyCompressor实现了Compressor接口。压缩器的一般方法是循环调用setInput()、finish()和compress()三个方法对数据进行压缩。</p>
<p>SnappyCompressor的主要成员变量如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_DIRECT_BUFFER_SIZE = <span class="number">64</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// HACK - Use this as a global lock in the JNI layer</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"unused"</span>&#125;)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Class clazz = SnappyCompressor.class;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> directBufferSize;</span><br><span class="line">  <span class="keyword">private</span> Buffer compressedDirectBuf = <span class="keyword">null</span>;  <span class="comment">// 输出(压缩)数据缓冲区</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> uncompressedDirectBufLen;</span><br><span class="line">  <span class="keyword">private</span> Buffer uncompressedDirectBuf = <span class="keyword">null</span>;  <span class="comment">// 输入数据缓冲区</span></span><br><span class="line">  <span class="comment">// userBuf,userBufOff,userBufLen用于保存通过setInput()设置的，但超过压缩器工作空间uncompressedDirectBuf剩余可用空间的数据</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] userBuf = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> userBufOff = <span class="number">0</span>, userBufLen = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> finish, finished;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> bytesRead = <span class="number">0L</span>; <span class="comment">//计数器，供getBytesRead()使用</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> bytesWritten = <span class="number">0L</span>; <span class="comment">//计数器，供getBytesWritten()使用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> nativeSnappyLoaded = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<p>在分析压缩器/解压器和压缩流/解压流中，一直强调Compressor的setInput、needsInput、finish、finished和compress五个方法间的配合。下面分析这些方法的实现：</p>
<h3 id="setInput"><a href="#setInput" class="headerlink" title="setInput"></a>setInput</h3><p>setInput方法为压缩器提供数据，在做了一番数据合法性检查后，先将finished标志为false，并尝试将数据复制到内部缓冲区中。如果内部缓存器剩余空间不够大，那么压缩器将借用输入数据对应的缓冲区，即利用userBuff/userBufOff/userBufLen记录输入的数据。否则，setInput()复制数据到uncompressedDirectBuf中。</p>
<p>需要注意的是，当借用发生时，使用的是引用，即数据并没有实际的复制，用户不能随便修改传入的数据。同时，缓冲区只能借用一次，用户如果再次调用setInput，将会替换原来保存的信息，造成数据错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInput</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || off &gt; b.length - len) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">    finished = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; uncompressedDirectBuf.remaining()) &#123;</span><br><span class="line">      <span class="comment">// 借用外部缓冲区，这个时候needsInput为false</span></span><br><span class="line">      <span class="keyword">this</span>.userBuf = b;</span><br><span class="line">      <span class="keyword">this</span>.userBufOff = off;</span><br><span class="line">      <span class="keyword">this</span>.userBufLen = len;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ((ByteBuffer) uncompressedDirectBuf).put(b, off, len);</span><br><span class="line">      uncompressedDirectBufLen = uncompressedDirectBuf.position();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bytesRead += len;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>setInput()借用外部缓冲区后就不能再接收数据，这时用户调用needsInput()将返回false，就可以获知这个消息。</p>
<h3 id="needsInput"><a href="#needsInput" class="headerlink" title="needsInput"></a>needsInput</h3><p>needsInput()返回false有三种情况：输出缓冲区（即保持压缩结果的缓冲区）有未读取的数据、输入缓冲区没有空间、压缩器已经借用外部缓冲区。这时，用户需要通过compress()方法取走已经压缩的数据，直至needsInput()返回true，才可以再次通过setInput()方法添加待压缩数据，相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needsInput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(compressedDirectBuf.remaining() &gt; <span class="number">0</span></span><br><span class="line">        || uncompressedDirectBuf.remaining() == <span class="number">0</span> || userBufLen &gt; <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="compress"><a href="#compress" class="headerlink" title="compress"></a>compress</h3><p>compress方法用于获取压缩后的数据，它需要处理needsInput()返回false的几种情况。</p>
<ul>
<li>如果压缩数据缓冲区有数据，即compressedDirectBuf中还有数据，则读取这部分数据，并返回。</li>
<li>如果该缓冲区为空，则需要压缩数据。首先清理compressedDirectBuf，这个清理（即调用clear()和limit()）是一个典型的Buffer操作。待压缩的数据有两个来源：输入缓冲区uncompressedDirectBuf或者“借用”的数据缓冲区。</li>
<li>如果输入缓冲区没有数据，那待压缩数据可能(可以在没有任何待压缩数据的情况下调用compress()方法)在“借用”的数据缓冲区里，这时使用setInputFromSavedData()方法复制“借用”数据缓冲区中的数据到uncompressedDirectBuf中。setInputFromSavedData()方法调用结束后，待压缩数据缓冲区中里还没有数据，则设置finished标志位，并返回0，表明压缩数据已经读完。</li>
</ul>
<p>uncompressedDirectBuffer中的数据，利用前面介绍的native方法compressBytesDirect()进行压缩，压缩后的数据保存在compressedDirectBuf中。由于待压缩数据缓冲区和压缩数据缓冲区的大小是一样的，所以uncompressedDirectBuf中的数据是一次被处理完的。compressedByteDirect()调用结束后，需要再次设置缓冲区的标记，并根据情况复制数据到compress()的参数b提供的缓冲区中。相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span><br><span class="line">      <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || off &gt; b.length - len) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否还有未取走的已经压缩的数据</span></span><br><span class="line">    <span class="keyword">int</span> n = compressedDirectBuf.remaining();</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      n = Math.min(n, len);</span><br><span class="line">      ((ByteBuffer) compressedDirectBuf).get(b, off, n);</span><br><span class="line">      bytesWritten += n;</span><br><span class="line">      <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理压缩数据缓冲区</span></span><br><span class="line">    compressedDirectBuf.clear();</span><br><span class="line">    compressedDirectBuf.limit(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == uncompressedDirectBuf.position()) &#123;</span><br><span class="line">      <span class="comment">// 输入数据缓冲区没有数据</span></span><br><span class="line">      setInputFromSavedData();</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">0</span> == uncompressedDirectBuf.position()) &#123;</span><br><span class="line">        <span class="comment">// Called without data; write nothing</span></span><br><span class="line">        finished = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压缩数据</span></span><br><span class="line">    n = compressBytesDirect();</span><br><span class="line">    compressedDirectBuf.limit(n);</span><br><span class="line">    uncompressedDirectBuf.clear(); <span class="comment">// snappy consumes all buffer input</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// snappy已经处理完所有的数据，设置finished为true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == userBufLen) &#123;</span><br><span class="line">      finished = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get atmost 'len' bytes</span></span><br><span class="line">    n = Math.min(n, len);</span><br><span class="line">    bytesWritten += n;</span><br><span class="line">    ((ByteBuffer) compressedDirectBuf).get(b, off, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="finished-和finish"><a href="#finished-和finish" class="headerlink" title="finished()和finish"></a>finished()和finish</h3><p>finished()返回true，表明压缩过程已经结束。压缩过程结束包含多个条件，包括finish标志位和finished标志位都必须为true，以及compressedDirectBuf中没有未取走的数据。其中，finish为true，表明用户已经确认完成数据的输入过程，finished表明压缩器中没有待压缩数据，这三个条件缺一不可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">finished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Check if all uncompressed data has been consumed</span></span><br><span class="line">    <span class="keyword">return</span> (finish &amp;&amp; finished &amp;&amp; compressedDirectBuf.remaining() == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop源码学习(13)——压缩(1)]]></title>
      <url>http://keyunluo.github.io/2016/08/14/2016-08-14-hadoop-io-9.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>压缩广泛应用于海量数据处理中，对数据文件进行压缩，可以有效减少存储文件所需的空间，并加快数据在网络上或者磁盘上的传输速度。在Hadoop中，压缩应用于文件存储、Map阶段到Reduce阶段的数据交换等情景。</p>
</blockquote>
<a id="more"></a>
<h2 id="Hadoop压缩简介"><a href="#Hadoop压缩简介" class="headerlink" title="Hadoop压缩简介"></a>Hadoop压缩简介</h2><p>Hadoop作为一个通用的海量数据处理平台，在使用压缩方式上，主要考虑压缩速度和压缩文件额可分割性。</p>
<p>用于Hadoop的常见压缩格式以及特性：</p>
<table>
<thead>
<tr>
<th style="text-align:left">压缩格式</th>
<th style="text-align:left">UNIX工具</th>
<th style="text-align:left">算法</th>
<th style="text-align:left">文件扩展名</th>
<th style="text-align:left">支持多文件</th>
<th style="text-align:left">可分割</th>
<th style="text-align:left">编码解码器</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DEFLATE</td>
<td style="text-align:left">无</td>
<td style="text-align:left">DEFLATE</td>
<td style="text-align:left">.deflate</td>
<td style="text-align:left">否</td>
<td style="text-align:left">否</td>
<td style="text-align:left">org.apache.hadoop.io.compress.DefaultCodec</td>
</tr>
<tr>
<td style="text-align:left">gzip</td>
<td style="text-align:left">gzip</td>
<td style="text-align:left">DEFLATE</td>
<td style="text-align:left">.gz</td>
<td style="text-align:left">否</td>
<td style="text-align:left">否</td>
<td style="text-align:left">org.apache.hadoop.io.compress.GzipCodec</td>
</tr>
<tr>
<td style="text-align:left">zip</td>
<td style="text-align:left">zip</td>
<td style="text-align:left">DEFLATE</td>
<td style="text-align:left">.zip</td>
<td style="text-align:left">是</td>
<td style="text-align:left">是</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">bzip</td>
<td style="text-align:left">bzip2</td>
<td style="text-align:left">bzip2</td>
<td style="text-align:left">.bz2</td>
<td style="text-align:left">否</td>
<td style="text-align:left">是</td>
<td style="text-align:left">org.apache.hadoop.io.compress.BZip2Codec</td>
</tr>
<tr>
<td style="text-align:left">LZO</td>
<td style="text-align:left">lzop</td>
<td style="text-align:left">LZO</td>
<td style="text-align:left">.lzo</td>
<td style="text-align:left">否</td>
<td style="text-align:left">否</td>
<td style="text-align:left">com.hadoop.compression.lzo.LzopCodec</td>
</tr>
<tr>
<td style="text-align:left">LZ4</td>
<td style="text-align:left">无</td>
<td style="text-align:left">LZ4</td>
<td style="text-align:left">.lz4</td>
<td style="text-align:left">否</td>
<td style="text-align:left">否</td>
<td style="text-align:left">org.apache.hadoop.io.compress.Lz4Codec</td>
</tr>
<tr>
<td style="text-align:left">Snappy</td>
<td style="text-align:left">无</td>
<td style="text-align:left">Snappy</td>
<td style="text-align:left">.snappy</td>
<td style="text-align:left">否</td>
<td style="text-align:left">否</td>
<td style="text-align:left">org.apache.hadoop.io.compress.SnappyCodec</td>
</tr>
</tbody>
</table>
<h2 id="Hadoop压缩API应用实例"><a href="#Hadoop压缩API应用实例" class="headerlink" title="Hadoop压缩API应用实例"></a>Hadoop压缩API应用实例</h2><p>本节学习使用编码/解码器的典型实例。其中compress()方法接受一个字符串参数，用于指定编码/解码器，并应用对应的压缩算法对文本文件CodecDemo.java进行压缩。字符串参数使用Java的反射机制创建对应的编码/解码器对象，通过CompressionCodec对象，进一步使用它的createOutputStream()方法构造一个CompressionOutputStream流，未压缩的数据通过IOUtils.copyBytes()方法，从输入流中复制写入CompressionOutputStream流，最终以压缩格式写入底层的输出流中。底层的输出流是文件输出流FileOutputStream，它关联文件的文件名，是在原有文件名的基础上添加压缩算法相应的扩展名生成。该扩展名可以通过CompressionCodec对象的getDefaultExtension()方法获得。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.compress.CompressionCodec;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.compress.CompressionCodecFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.compress.CompressionOutputStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IOUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.ReflectionUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodecDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">(String method)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File fileIn = <span class="keyword">new</span> File(<span class="string">"CodecDemo.java"</span>);</span><br><span class="line">        <span class="comment">// 输入流</span></span><br><span class="line">        InputStream in = <span class="keyword">new</span> FileInputStream(fileIn);</span><br><span class="line">        Class&lt;?&gt; codecClass = Class.forName(method);</span><br><span class="line"></span><br><span class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过名称找对应的编码、解码器</span></span><br><span class="line">        CompressionCodec codec = (CompressionCodec) ReflectionUtils.newInstance(codecClass,conf);</span><br><span class="line"></span><br><span class="line">        File fileOut = <span class="keyword">new</span> File(<span class="string">"CodecDemo.java"</span>+codec.getDefaultExtension());</span><br><span class="line">        fileOut.delete();</span><br><span class="line">        <span class="comment">// 文件输出流</span></span><br><span class="line">        OutputStream out = <span class="keyword">new</span> FileOutputStream(fileOut);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过编码/解码器创建对应的输出流</span></span><br><span class="line">        CompressionOutputStream cout = codec.createOutputStream(out);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 压缩</span></span><br><span class="line">        IOUtils.copyBytes(in,cout,<span class="number">4096</span>,<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        in.close();</span><br><span class="line">        cout.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decompress</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        CompressionCodecFactory factory = <span class="keyword">new</span> CompressionCodecFactory(conf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过文件扩展名获取相应的编码/解码器</span></span><br><span class="line">        CompressionCodec codec = factory.getCodec(<span class="keyword">new</span> Path(file.getName()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (codec == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"无法找到"</span>+file+<span class="string">"的codec解码器"</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        File fileOut = <span class="keyword">new</span> File(file.getName()+<span class="string">".txt"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过编码/解码器创建对应的输入流</span></span><br><span class="line"></span><br><span class="line">        InputStream in = codec.createInputStream( <span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        OutputStream out = <span class="keyword">new</span> FileOutputStream(fileOut);</span><br><span class="line">        IOUtils.copyBytes(in,out,<span class="number">4096</span>,<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建压缩文件..."</span>);</span><br><span class="line">        compress(<span class="string">"org.apache.hadoop.io.compress.BZip2Codec"</span>);</span><br><span class="line">        System.out.println(<span class="string">"解压缩文件..."</span>);</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"CodecDemo.java.bz2"</span>);</span><br><span class="line">        decompress(file);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Hadoop压缩框架"><a href="#Hadoop压缩框架" class="headerlink" title="Hadoop压缩框架"></a>Hadoop压缩框架</h2><p>Hadoop通过以编码/解码器为基础的抽象工厂方法，提供了一个可扩展的框架，支持多种压缩方法。</p>
<h3 id="编码-解码器"><a href="#编码-解码器" class="headerlink" title="编码/解码器"></a>编码/解码器</h3><p>CompressionCodec接口实现了编码/解码器，使用的是抽象工厂的设计模式。CompressionCodec提供了一系列的方法，用于创建特定压缩算法的相关设施，其类图如下：</p>
<p><img src="/resource/blog/2016-08/CompressionCodec.png" alt="CompressionCodec"></p>
<p>CompressionCodec中的方法很对称，一个压缩功能对应一个解压缩的功能，其中，压缩有关的方法包括：</p>
<ul>
<li>createOutputStream()用于通过底层输出流创建对应压缩算法的压缩流，重载的createOutputStream()方法可使用压缩器创建压缩流；</li>
<li>createCompressor()用于创建压缩算法对应的压缩器，后面会继续介绍压缩流CompressionoutputStream和压缩器Compressor,解压缩也有对应的方法和类。</li>
</ul>
<p>CompressionCodec中还提供了获取对应文件扩展名的方法：getDefaultExtension()，如对于org.apache.hadoop.io.compression.BZip2Codec,该方法返回字符串”.bz2”。</p>
<p>CompressionCodecFactory是Hadoop压缩框架中的另一个类，它应用了工厂方法，使用者可以通过它提供的方法获得CompressionCodec。通过CompressionCodecFactory的getCodec()方法，可以创建GzipCodec对象或BZip2Codec对象。为了分析该方法，需要了解CompressionCodec类中保存文件扩展名和CompressionCodec映射关系的成员变量codecs。</p>
<p>codecs是一个有序映射表，即它本身是一个Map，同时它对Map的键排序，下面是codecs中保存的一个可能的映射关系：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2zb.: org.apache.hadoop.io.compress.BZip2Codec,</span><br><span class="line">etalfed.: org.apache.hadoop.io.compress.DeflatCodec,</span><br><span class="line">yppans.: org.apache.hadoop.io.compress.SnappyCodec,</span><br><span class="line">zg.: org.apache.hadoop.io.compress.GzipCodec,</span><br></pre></td></tr></table></figure>
<p>getCodec()方法的输入是Path对象，保存着文件路径，如上例中的”CodecDemo.java.bz2”。首先通过获取Path对象对应的文件名并逆转该字符串得到”2zb.avaj.omeDcedoC”,然后通过有序映射SortedMap的heapMap()方法，查找最接近上述字符串的有序映射的部分视图，如输入”2zb.avaj.omeDcedoC”的查找结果subMap，只包含”2zb.”对应的那个键值对，如果输入的是”zg.avaj.omeDcedoC”,则subMap会包含成员变量codecs中的保存的所有的键值对。然后简单地获取subMap的最后一个元素的键，如果该键是逆转文件名的前缀，那么就找到了文件对应的编码/解码器，否则返回空。实现的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompressionCodecFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该有序映射保存了逆转文件后缀(包括后缀前的‘.’)到CompressionCodec的映射</span></span><br><span class="line">    <span class="comment">// 通过逆转文件后缀，我们可以找到最长匹配后缀</span></span><br><span class="line">    <span class="keyword">private</span> SortedMap&lt;String, CompressionCodec&gt; codecs = <span class="keyword">null</span>;</span><br><span class="line">    ......</span><br><span class="line">     <span class="function"><span class="keyword">public</span> CompressionCodec <span class="title">getCodec</span><span class="params">(Path file)</span> </span>&#123;</span><br><span class="line">    CompressionCodec result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (codecs != <span class="keyword">null</span>) &#123;</span><br><span class="line">      String filename = file.getName();</span><br><span class="line">      String reversedFilename = <span class="keyword">new</span> StringBuilder(filename).reverse().toString();</span><br><span class="line">      SortedMap&lt;String, CompressionCodec&gt; subMap =</span><br><span class="line">        codecs.headMap(reversedFilename);</span><br><span class="line">      <span class="keyword">if</span> (!subMap.isEmpty()) &#123;</span><br><span class="line">        String potentialSuffix = subMap.lastKey();</span><br><span class="line">        <span class="keyword">if</span> (reversedFilename.startsWith(potentialSuffix)) &#123;</span><br><span class="line">          result = codecs.get(potentialSuffix);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="压缩器和解压器"><a href="#压缩器和解压器" class="headerlink" title="压缩器和解压器"></a>压缩器和解压器</h3><p>压缩器(Compressor)和解压缩器(Decompressor)是Hadoop压缩框架中的一对重要概念。Compressor可以插入压缩输出流的实现中，提供具体的压缩功能；相反，Decompressor提供具体的解压功能并插入CompressionInputStream中。Compressor和Decompressor的这种设计，最初是在Java的zlib库中引入的，对应的实现分别是java.util.zip.Deflater和java.util.zip.Inflater。下面以Compressor为例介绍这对组件。</p>
<p>Compressor通过setInput()方法接收数据到内部缓冲区，通过needsInput()的返回值，如果是false，表明缓冲区已满，这时必须通过compress方法获取压缩后的数据，释放缓冲区的空间。为了提高压缩效率，并不是每次用户调用setInput()方法压缩器就会立即工作，所以，为了通知压缩器所有数据已经写入，必须使用finish()方法。finish方法调用结束后，压缩器缓冲区中保持的已经压缩过的数据，可以继续通过compress()方法获得。至于要判断压缩器中是否还有未读取的压缩数据，则需要利用finished()方法来判断。</p>
<p>下面是使用Compressor的一个典型实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.compress.Compressor;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.compress.zlib.BuiltInZlibDeflater;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompressorDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compressor</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException,IOException</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> compressorOutputBufferSize = <span class="number">64</span>;</span><br><span class="line">        <span class="comment">// 读入被压缩的内容</span></span><br><span class="line">        File fin = <span class="keyword">new</span> File(<span class="string">"CompressorDemo.java"</span>);</span><br><span class="line">        InputStream in = <span class="keyword">new</span> FileInputStream(fin);</span><br><span class="line">        <span class="keyword">int</span> datalength = in.available();</span><br><span class="line">        <span class="keyword">byte</span>[] inbuf = <span class="keyword">new</span> <span class="keyword">byte</span>[datalength];</span><br><span class="line">        in.read(inbuf,<span class="number">0</span>,datalength);</span><br><span class="line">        in.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 长度受限制的输出缓冲区，用于说明finished()方法</span></span><br><span class="line">        <span class="keyword">byte</span>[] outbuf = <span class="keyword">new</span> <span class="keyword">byte</span>[compressorOutputBufferSize];</span><br><span class="line"></span><br><span class="line">        Compressor compressor = <span class="keyword">new</span> BuiltInZlibDeflater(); <span class="comment">// 构造压缩器</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">100</span>; <span class="comment">// 一些计数器</span></span><br><span class="line">        <span class="keyword">int</span> inputPos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> putcount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> getcount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> compressedlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( inputPos &lt; datalength)&#123;</span><br><span class="line">            <span class="comment">// 进行多次setInput()</span></span><br><span class="line">            <span class="keyword">int</span> len = (datalength-inputPos &gt;= step) ? step:datalength-inputPos;</span><br><span class="line">            compressor.setInput(inbuf,inputPos,len);</span><br><span class="line">            putcount++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!compressor.needsInput())&#123;</span><br><span class="line">                compressedlen = compressor.compress(outbuf, <span class="number">0</span>, compressorOutputBufferSize);</span><br><span class="line">                <span class="keyword">if</span> (compressedlen &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    getcount++;  <span class="comment">// 能读到数据</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            inputPos += step;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        compressor.finish();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!compressor.finished()) &#123; <span class="comment">// 压缩器中有数据</span></span><br><span class="line">            getcount++;</span><br><span class="line">            compressor.compress(outbuf, <span class="number">0</span>, compressorOutputBufferSize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Compress "</span>+compressor.getBytesRead()+<span class="string">" byte into "</span>+compressor.getBytesWritten());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"put "</span>+putcount+<span class="string">" times and get "</span>+getcount+<span class="string">" times"</span>);</span><br><span class="line"></span><br><span class="line">        compressor.end(); <span class="comment">// 停止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        compressor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在压缩的过程中，Compressor可以通过getByteRead()和getBytesWritten()方法获得Compressor输入未压缩字节的总数和输出压缩字节的总数。</p>
<p>Compressor和Decompressor的类图如下：</p>
<p><img src="/resource/blog/2016-08/Compressor-Decompressor.png" alt="Compressor-Decompressor"></p>
<p>Compressor.end()方法用于关闭解压缩器并放弃所有未处理的输入；reset()方法用于重置压缩器，以处理新的输入数据集合；reinit()方法更进一步允许使用Hadoop的配置系统，重置并重新配置压缩器。</p>
<h3 id="压缩流和解压缩流"><a href="#压缩流和解压缩流" class="headerlink" title="压缩流和解压缩流"></a>压缩流和解压缩流</h3><p>Java最初版本的输入/输出系统是基于流的，流抽象了任何有能力产出数据的数据源，或者有能力接收数据的接收端。一般来说，通过设计模式的修饰，可以为流添加一些额外的功能，如前面题解的序列化流ObjectInputStream和ObjectOutputStream。</p>
<p>压缩流(CompressionOutputStream)和解压缩流(CompressionInputStream)是hadoop压缩框架中的另一对重要的概念，它提供了基于流的压缩和解压缩能力。这里只分析和压缩相关的代码，即CompressionOutputStream及其子类。</p>
<p>CompressionOutputStream继承自OutputStream，也是个抽象类。CompressionOutputStream实现了OutputStream的close()方法和flush()方法，但用于输出数据的write()方法、用于结束压缩过程并将输入写到底层的finish方法和重置压缩状态的resetState()方法还是抽象方法，需要CompressionOutputStream的子类实现。CompressionOutputStream规定了压缩流的对外接口，可以提供一个通用的、使用压缩器的压缩流实现。CompressorStream使用了压缩器实现了一个通用的压缩流，主要代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompressorStream</span> <span class="keyword">extends</span> <span class="title">CompressionOutputStream</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> Compressor compressor;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">byte</span>[] buffer;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数：底层输出流、压缩器、缓冲区大小</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CompressorStream</span><span class="params">(OutputStream out, Compressor compressor, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(out);</span><br><span class="line">    <span class="comment">// 参数检查</span></span><br><span class="line">    <span class="keyword">if</span> (out == <span class="keyword">null</span> || compressor == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bufferSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal bufferSize"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.compressor = compressor;</span><br><span class="line">    buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CompressorStream</span><span class="params">(OutputStream out, Compressor compressor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(out, compressor, <span class="number">512</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">CompressorStream</span><span class="params">(OutputStream out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(out);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将待压缩的数据写入流中</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Sanity checks</span></span><br><span class="line">    <span class="keyword">if</span> (compressor.finished()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"write beyond end of stream"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((off | len | (off + len) | (b.length - (off + len))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用压缩器的setInput方法进入压缩器</span></span><br><span class="line">    compressor.setInput(b, off, len);</span><br><span class="line">    <span class="comment">// 判断是否需要调用compress方法</span></span><br><span class="line">    <span class="keyword">while</span> (!compressor.needsInput()) &#123;</span><br><span class="line">      compress();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提取数据</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = compressor.compress(buffer, <span class="number">0</span>, buffer.length);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      out.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 结束输入</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!compressor.finished()) &#123;</span><br><span class="line">      compressor.finish();</span><br><span class="line">      <span class="keyword">while</span> (!compressor.finished()) &#123;</span><br><span class="line">        compress();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resetState</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    compressor.reset();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭流</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!closed) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        finish(); <span class="comment">// 结束压缩</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">        out.close();  <span class="comment">// 关闭底层流</span></span><br><span class="line">        closed = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] oneByte = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span>];</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    oneByte[<span class="number">0</span>] = (<span class="keyword">byte</span>)(b &amp; <span class="number">0xff</span>);</span><br><span class="line">    write(oneByte, <span class="number">0</span>, oneByte.length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CompressorStream提供了几个不同的构造函数，用于初始化相关的成员变量。上述代码片段中保留了参数最多的构造函数，其中，CompressorStream需要底层输出流out和压缩时使用的压缩器，都可以作为参数传入构造函数。另一个参数是CompressorStream工作时使用的缓冲区buffer的大小，构造时会利用这个参数分配该缓冲区。</p>
<p>压缩器方法的典型调用顺序：</p>
<p><img src="/resource/blog/2016-08/compress.png" alt="调用顺序"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop源码学习(11)——SequenceFile]]></title>
      <url>http://keyunluo.github.io/2016/08/13/2016-08-13-hadoop-io-7.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>SequenceFile为二进制键值对提供了一个持久数据结构，也可以作为小文件的容器，HDFS和MapReduce是针对大文件优化的，所以通过SequenceFile类型将小文件包装起来，可以获得更高效率的存储和处理。</p>
</blockquote>
<a id="more"></a>
<h2 id="SequenceFile类"><a href="#SequenceFile类" class="headerlink" title="SequenceFile类"></a>SequenceFile类</h2><p>SequenceFile类位于org.apache.hadoop.io包内，类结构如下：</p>
<p><img src="/resource/blog/2016-08/SequenceFile.png" alt="SequenceFile类"></p>
<h2 id="SequenceFile的格式"><a href="#SequenceFile的格式" class="headerlink" title="SequenceFile的格式"></a>SequenceFile的格式</h2><p>SequenceFile文件由文件头和随后的一条或多条记录组成。顺序文件的前三个字节是SEQ，紧随其后的一个字节表示顺序文件的版本号。文件头还包括其他字段，例如键和值类的名称、数据压缩细节、用户定义的元数据以及同步标识。同步标识用于在读取文件时能够从任意位置开始识别边界记录。</p>
<p>记录的内部结构取决于是否启用压缩。如果已经启用，则取决于记录压缩还是数据块压缩。</p>
<p>如果没有启用压缩(默认情况)，那么每条记录则由记录长度(字节数)、键长度、键和值组成。长度字段为4字节长的整数，遵循java.io.DataOutput类中的writeInt()方法的约定，写入顺序文件的类定义Serialization类来实现键和值的序列化。</p>
<p>记录压缩格式与无压缩情况基本相同，只不过值是用文件头定义的codec压缩的，但是键并没有被压缩。</p>
<p><img src="/resource/blog/2016-08/sequencefilewithnocompression.jpg" alt="SequenceFile-无压缩和记录压缩"></p>
<p>块压缩是指一次性压缩多条记录，因为它可以利用记录间的相似性进行压缩，所以相较于单条记录压缩方法，该方法的压缩效率更高，如下图所示。可以不断向数据块中压缩记录，直到块的字节数不小于io.seqfile.compress.blocksize属性中设置的字节数：默认为1MB。每一个新块的开始处都需要插入同步标识。数据块的格式如下：首先是一个指示数据块中字节数的字段；紧接着是4个压缩字段(键长度、键、值长度和值)</p>
<p><img src="/resource/blog/2016-08/sequencefilewithblockcompression.jpg" alt="SequenceFile-块压缩"></p>
<h2 id="SequenceFile写操作"><a href="#SequenceFile写操作" class="headerlink" title="SequenceFile写操作"></a>SequenceFile写操作</h2><p>通过createWriter()静态方法可以创建SequenceFile对象，并返回SequenceFile.Writer实例。该静态方法有多个重载版本，但都需要指定待写入的数据流(FSDataOutputStream或FileSystem对象和Path对象)，Configuration对象，以及键和值的类型，写入的参数信息等。另外，可选参数包括压缩类型以及相应的codec,Progressable回调函数用于通知写入的进度，以及在SequenceFile头文件中存储的Metadata实例。</p>
<p>存储在SequenceFile中的键和值并不一定需要是Writable类型，只要能被Serialization序列化和反序列化，任何类型都可以。</p>
<p>一旦拥有SequenceFile.Writer实例，就可以通过append()方法在文件末尾附加键值对。写完后，可以调用close()方法(SequenceFile.Writer实现了java.io.Closable接口)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.SequenceFile;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IOUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceFileWriteDemo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] DATA = &#123;</span><br><span class="line">    <span class="string">"One, two, buckle my shoe"</span>,</span><br><span class="line">    <span class="string">"Three, four, shut the door"</span>,</span><br><span class="line">    <span class="string">"Five, six, pick up sticks"</span>,</span><br><span class="line">    <span class="string">"Seven, eight, lay them straight"</span>,</span><br><span class="line">    <span class="string">"Nine, ten, a big fat hen"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    String url = args[<span class="number">0</span>];</span><br><span class="line">    Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">    FileSystem fs = FileSystem.get(URI.create(url),conf);</span><br><span class="line">    Path path = <span class="keyword">new</span> Path(url);</span><br><span class="line"></span><br><span class="line">    IntWritable key = <span class="keyword">new</span> IntWritable();</span><br><span class="line">    Text value = <span class="keyword">new</span> Text();</span><br><span class="line">    SequenceFile.Writer writer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        writer = SequenceFile.createWriter(fs,conf,path,key.getClass(),value.getClass());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1024</span>;i++)&#123;</span><br><span class="line">            key.set(<span class="number">1024</span>-i);</span><br><span class="line">            value.set(DATA[i % DATA.length]);</span><br><span class="line">            writer.append(key,value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">        IOUtils.closeStream(writer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译与运行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  project export CLASSPATH=$HADOOP_CLASSPATH:$CLASSPATH</span><br><span class="line">➜  project javac SequenceFileWriteDemo.java</span><br><span class="line">➜  project java SequenceFileWriteDemo numbers.seq</span><br></pre></td></tr></table></figure>
<h2 id="SequenceFile读操作"><a href="#SequenceFile读操作" class="headerlink" title="SequenceFile读操作"></a>SequenceFile读操作</h2><p>从头到尾读取顺序文件不外乎创建SequenceFile.Reader实例后反复调用next()方法迭代读取记录。读取的是哪条记录与你使用的序列化框架有关。如果使用Writable类型，那么通过键和值作为参数的next()方法可以将数据流中的下一条键值对读入变量中。<code>public boolean next(Writable key,Writable val)</code>。对于其他非Writable类型的序列化框架，例如Apache Thrift，则应该使用下面两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">(Object key)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> Object <span class="title">getCurrentValue</span><span class="params">(Object val)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>
<p>在这种情况下，需要确保io.serializations属性已经设置了你想要的序列化框架。如果next()方法返回的是非null对象，则可以从数据流中读取键、值对，并且可以通过getCurrentValue()方法读取该值。否则，如果next()返回null值，表示已经读到文件末尾。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Writable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.SequenceFile;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IOUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.ReflectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceFileReadDemo</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    String url = args[<span class="number">0</span>];</span><br><span class="line">    Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">    FileSystem fs = FileSystem.get(URI.create(url),conf);</span><br><span class="line">    Path path = <span class="keyword">new</span> Path(url);</span><br><span class="line"></span><br><span class="line">    SequenceFile.Reader reader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        reader = <span class="keyword">new</span> SequenceFile.Reader(fs,path,conf);</span><br><span class="line">        Writable key = (Writable) ReflectionUtils.newInstance(reader.getKeyClass(),conf);</span><br><span class="line">        Writable value = (Writable) ReflectionUtils.newInstance(reader.getValueClass(),conf);</span><br><span class="line">        <span class="keyword">long</span> position = reader.getPosition();</span><br><span class="line">        <span class="keyword">while</span> (reader.next(key,value))&#123;</span><br><span class="line">            String syncSeen = reader.syncSeen() ? <span class="string">"*"</span> : <span class="string">" "</span>;</span><br><span class="line">            System.out.printf(<span class="string">"[%s%s]\t%s\t%s\n"</span>,position,syncSeen,key,value);</span><br><span class="line">            position = reader.getPosition();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">        IOUtils.closeStream(reader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过命令行接口显示SequenceFile"><a href="#通过命令行接口显示SequenceFile" class="headerlink" title="通过命令行接口显示SequenceFile"></a>通过命令行接口显示SequenceFile</h2><p>hdfs dfs命令有一个-text选项可以以文本形式显示顺序文件，该选项可以查看文件的代码，由此检测出文件的类型并将其转换成相应的文本。该选项可以识别gzip压缩文件和顺序文件；否则，假设输入为纯文本文件。</p>
<p>对于顺序文件，如果键和值是由具体含义的字符串表示，那么这个命令就非常有用(通过toString()方法定义)，同样，如果有自己定义的键或值的类，则应该确保它们在Hadoop类路径目录下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  project hdfs dfs -text numbers.seq | head</span><br><span class="line"><span class="number">16</span>/<span class="number">08</span>/<span class="number">13</span> <span class="number">16</span>:<span class="number">39</span>:<span class="number">23</span> INFO zlib.ZlibFactory: Successfully loaded &amp; initialized native-zlib library</span><br><span class="line"><span class="number">16</span>/<span class="number">08</span>/<span class="number">13</span> <span class="number">16</span>:<span class="number">39</span>:<span class="number">23</span> INFO compress.CodecPool: Got brand-new decompressor [.deflate]</span><br><span class="line"><span class="number">1024</span>    One, two, buckle my shoe</span><br><span class="line"><span class="number">1023</span>    Three, four, shut the door</span><br><span class="line"><span class="number">1022</span>    Five, six, pick up sticks</span><br><span class="line"><span class="number">1021</span>    Seven, eight, lay them straight</span><br><span class="line"><span class="number">1020</span>    Nine, ten, a big fat hen</span><br><span class="line"><span class="number">1019</span>    One, two, buckle my shoe</span><br><span class="line"><span class="number">1018</span>    Three, four, shut the door</span><br><span class="line"><span class="number">1017</span>    Five, six, pick up sticks</span><br><span class="line"><span class="number">1016</span>    Seven, eight, lay them straight</span><br><span class="line"><span class="number">1015</span>    Nine, ten, a big fat hen</span><br></pre></td></tr></table></figure>
<h2 id="SequenceFile的排序和合并"><a href="#SequenceFile的排序和合并" class="headerlink" title="SequenceFile的排序和合并"></a>SequenceFile的排序和合并</h2><p>MapReduce是对多个顺序文件进行排序或合并的最有效的方法。MapReduce本身是并行的，并且可由用户指定要使用多少个reducer，该数决定这输出分区数。例如，通过指定一个reducer，可以得到一个输出文件。</p>
<p>除了MapReduce实现排序/归并，还有一种方法是使用SequenceFile.Sorter类中的sort()方法和merge()方法。它们比MapReduce更早出现，比MapReduce更底层，为了实现并行，需要手动对数据进行分区，因此不建议使用。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop源码学习(12)——MapFile]]></title>
      <url>http://keyunluo.github.io/2016/08/13/2016-08-13-hadoop-io-8.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>MapFile是已经排过序的SequenceFile，它有索引，所以可以按键查找。可以将MapFile视为java.util.Map的持久化形式(尽管它并没有实现该接口)，它的大小可以超过保存在内存中一个map的大小。</p>
</blockquote>
<a id="more"></a>
<h2 id="MapFile相关类"><a href="#MapFile相关类" class="headerlink" title="MapFile相关类"></a>MapFile相关类</h2><p>与MapFile相关的类共有3个，它们都位于org.apache.hadoop.io包下：</p>
<ul>
<li>ArrayFile：一种稠密的基于文件的从整数到值的映射。整型表示数组元素的索引，值是Writable类型。</li>
<li>BloomMapFile：使用动态Bloom过滤器来提供快速的键之间的测试，并且提供了一个快速的Reader.get(WritableComparable, Writable)操作，尤其在稀疏密度的MapFile中。该实现使用一个动态的布隆过滤器来检测某个给定的键是否在map文件中，这个操作在内存中实现，故而速度比较快，但可能误判。经过布隆过滤器过滤后，如果存在相应的结果，则调用get()方法。</li>
<li>SetFile：一个基于文件的keys集合。用于存储Writable键的集合，键必须按照排好的顺序添加。</li>
</ul>
<p><img src="/resource/blog/2016-08/MapFile.png" alt="MapFile类"></p>
<h2 id="MapFile写操作"><a href="#MapFile写操作" class="headerlink" title="MapFile写操作"></a>MapFile写操作</h2><p>MapFile的写操作类似于SequenceFile的写操作。新建一个MapFile.Writer实例，然后调用append()方法顺序写入文件内容。如果不按顺序写入，就会抛出一个IOException异常。键必须是WritableComparable类型的实例，值必须是Writable类型的实例，这与SequenceFile正好相反，后者可以为其条目使用任意序列化框架。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.MapFile;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IOUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapFileWriteDemo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] DATA = &#123;</span><br><span class="line">    <span class="string">"One, two, buckle my shoe"</span>,</span><br><span class="line">    <span class="string">"Three, four, shut the door"</span>,</span><br><span class="line">    <span class="string">"Five, six, pick up sticks"</span>,</span><br><span class="line">    <span class="string">"Seven, eight, lay them straight"</span>,</span><br><span class="line">    <span class="string">"Nine, ten, a big fat hen"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    String url = args[<span class="number">0</span>];</span><br><span class="line">    Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">    FileSystem fs = FileSystem.get(URI.create(url),conf);</span><br><span class="line"></span><br><span class="line">    IntWritable key = <span class="keyword">new</span> IntWritable();</span><br><span class="line">    Text value = <span class="keyword">new</span> Text();</span><br><span class="line">    MapFile.Writer writer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        writer = <span class="keyword">new</span> MapFile.Writer(conf,fs,url,key.getClass(),value.getClass());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1024</span>;i++)&#123;</span><br><span class="line">            key.set(i+<span class="number">1</span>);</span><br><span class="line">            value.set(DATA[i % DATA.length]);</span><br><span class="line">            writer.append(key,value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">        IOUtils.closeStream(writer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">➜  project export CLASSPATH=$HADOOP_CLASSPATH:$CLASSPATH</span><br><span class="line">➜  project javac MapFileWriteDemo.java</span><br><span class="line">注: MapFileWriteDemo.java使用或覆盖了已过时的 API。</span><br><span class="line">注: 有关详细信息, 请使用 -Xlint:deprecation 重新编译。</span><br><span class="line">➜  project java MapFileWriteDemo  mapfile.map</span><br><span class="line"><span class="number">16</span>/<span class="number">08</span>/<span class="number">13</span> <span class="number">15</span>:<span class="number">07</span>:<span class="number">57</span> WARN util.NativeCodeLoader: Unable to load native-hadoop library <span class="keyword">for</span> your platform... using builtin-java classes where applicable</span><br><span class="line"><span class="number">16</span>/<span class="number">08</span>/<span class="number">13</span> <span class="number">15</span>:<span class="number">07</span>:<span class="number">58</span> INFO compress.CodecPool: Got brand-new compressor [.deflate]</span><br><span class="line"><span class="number">16</span>/<span class="number">08</span>/<span class="number">13</span> <span class="number">15</span>:<span class="number">07</span>:<span class="number">59</span> INFO compress.CodecPool: Got brand-new compressor [.deflate]</span><br><span class="line">➜  project hdfs dfs -ls</span><br><span class="line">Found <span class="number">2</span> items</span><br><span class="line">drwxr-xr-x   - streamer supergroup          <span class="number">0</span> <span class="number">2016</span><span class="number">-05</span><span class="number">-25</span> <span class="number">22</span>:<span class="number">37</span> COPROCESSOR</span><br><span class="line">drwxr-xr-x   - streamer supergroup          <span class="number">0</span> <span class="number">2016</span><span class="number">-08</span><span class="number">-13</span> <span class="number">15</span>:<span class="number">07</span> mapfile.map</span><br><span class="line">➜  project hdfs dfs -text mapfile.map/data | head</span><br><span class="line"><span class="number">16</span>/<span class="number">08</span>/<span class="number">13</span> <span class="number">15</span>:<span class="number">10</span>:<span class="number">20</span> INFO zlib.ZlibFactory: Successfully loaded &amp; initialized native-zlib library</span><br><span class="line"><span class="number">16</span>/<span class="number">08</span>/<span class="number">13</span> <span class="number">15</span>:<span class="number">10</span>:<span class="number">20</span> INFO compress.CodecPool: Got brand-new decompressor [.deflate]</span><br><span class="line"><span class="number">1</span>   One, two, buckle my shoe</span><br><span class="line"><span class="number">2</span>   Three, four, shut the door</span><br><span class="line"><span class="number">3</span>   Five, six, pick up sticks</span><br><span class="line"><span class="number">4</span>   Seven, eight, lay them straight</span><br><span class="line"><span class="number">5</span>   Nine, ten, a big fat hen</span><br><span class="line"><span class="number">6</span>   One, two, buckle my shoe</span><br><span class="line"><span class="number">7</span>   Three, four, shut the door</span><br><span class="line"><span class="number">8</span>   Five, six, pick up sticks</span><br><span class="line"><span class="number">9</span>   Seven, eight, lay them straight</span><br><span class="line"><span class="number">10</span>  Nine, ten, a big fat hen</span><br><span class="line"></span><br><span class="line">➜  project hdfs dfs -text mapfile.map/index</span><br><span class="line"><span class="number">16</span>/<span class="number">08</span>/<span class="number">13</span> <span class="number">15</span>:<span class="number">10</span>:<span class="number">41</span> INFO zlib.ZlibFactory: Successfully loaded &amp; initialized native-zlib library</span><br><span class="line"><span class="number">16</span>/<span class="number">08</span>/<span class="number">13</span> <span class="number">15</span>:<span class="number">10</span>:<span class="number">41</span> INFO compress.CodecPool: Got brand-new decompressor [.deflate]</span><br><span class="line"><span class="number">16</span>/<span class="number">08</span>/<span class="number">13</span> <span class="number">15</span>:<span class="number">10</span>:<span class="number">41</span> INFO compress.CodecPool: Got brand-new decompressor [.deflate]</span><br><span class="line"><span class="number">16</span>/<span class="number">08</span>/<span class="number">13</span> <span class="number">15</span>:<span class="number">10</span>:<span class="number">41</span> INFO compress.CodecPool: Got brand-new decompressor [.deflate]</span><br><span class="line"><span class="number">16</span>/<span class="number">08</span>/<span class="number">13</span> <span class="number">15</span>:<span class="number">10</span>:<span class="number">41</span> INFO compress.CodecPool: Got brand-new decompressor [.deflate]</span><br><span class="line"><span class="number">1</span>   <span class="number">128</span></span><br><span class="line"><span class="number">129</span> <span class="number">6079</span></span><br><span class="line"><span class="number">257</span> <span class="number">12054</span></span><br><span class="line"><span class="number">385</span> <span class="number">18030</span></span><br><span class="line"><span class="number">513</span> <span class="number">24002</span></span><br><span class="line"><span class="number">641</span> <span class="number">29976</span></span><br><span class="line"><span class="number">769</span> <span class="number">35947</span></span><br><span class="line"><span class="number">897</span> <span class="number">41922</span></span><br></pre></td></tr></table></figure></p>
<p>可以发现MapFile包含data和index两个文件，这两个文件都是SequenceFile，data文件包含所有记录，index文件包含一部分键和data文件键到其偏移量的映射。</p>
<p>从输出中可以看见，默认情况下只有每隔128隔键才有一个包含在index文件中，当然也可以调整，调用MapFile.Writer实例的setIndexInterval()方法来设置io.map.index.interval属性即可。增加索引间隔大小可以有效减少MapFile存储索引所需要的内存，但降低了随机访问效率。</p>
<p>因为索引只保留了一部分键，所以整个MapFile无法枚举所有键甚至计算它自己有多少键，唯一的办法是读取整个文件。</p>
<h2 id="MapFile读操作"><a href="#MapFile读操作" class="headerlink" title="MapFile读操作"></a>MapFile读操作</h2><p>在MapFile中依次遍历文件中所有条目的过程类似于SequenceFile中的过程：首先新建一个MapFile.Reader实例，然后调用next()方法，直到返回值为false，表示没有条目返回，因为已经读到文件末尾，通过调用get()方法可以随机访问文件中的数据，返回值用于确定是否在MapFile中找到相应的条目，如果是null，说明指定key没有相应的条目。</p>
<p>getClosest()方法与get()方法类似，只不过它返回的是与指定键匹配的最接近的键，而不是在不匹配时返回null，更准确地说，如果MapFile包含指定的键，则返回对应的条目，否则，返回MapFile中第一个大于(或小于，由相应的boolean参数指定)指定键的键。</p>
<p>大型MapFile的索引会占据大量内存，不要在修改索引间隔之后重建索引，要在读取索引时设置io.mao.index.skip属性来加载一定比例的索引键。该属性通常设置为0，意味着不跳过索引键，如果设置为1，则表示每次跳过索引键中的一个。设置的越大，越节省内存，但会增加搜索时间，因为平均而言，扫描的键更多。</p>
<h2 id="将SequenceFile转换成MapFile"><a href="#将SequenceFile转换成MapFile" class="headerlink" title="将SequenceFile转换成MapFile"></a>将SequenceFile转换成MapFile</h2><p>在MapFile中搜索相当于在加有索引和排过序的SequenceFile中搜索，下面例子显示了对MapFile调用fix()静态方法，将SequenceFile重建索引成MapFile。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.MapFile;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.SequenceFile;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapFileFixer</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    String url = args[<span class="number">0</span>];</span><br><span class="line">    Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">    FileSystem fs = FileSystem.get(URI.create(url),conf);</span><br><span class="line"></span><br><span class="line">    Path map = <span class="keyword">new</span> Path(url);</span><br><span class="line">    Path mapData = <span class="keyword">new</span> Path(map,MapFile.DATA_FILE_NAME);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从sequence 数据文件获得key和value的类型</span></span><br><span class="line">    SequenceFile.Reader reader = <span class="keyword">new</span> SequenceFile.Reader(fs,mapData,conf);</span><br><span class="line">    Class keyClass = reader.getKeyClass();</span><br><span class="line">    Class valueClass = reader.getValueClass();</span><br><span class="line">    reader.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建map索引文件</span></span><br><span class="line">    <span class="keyword">long</span> entries = MapFile.fix(fs,map,keyClass,valueClass,<span class="keyword">false</span>,conf);</span><br><span class="line">    System.out.printf(<span class="string">"创建MapFile %s ,入口是 %d"</span>,map,entries);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Fix()方法通常用于重建已损坏的索引，但它能够从头开始建立新的索引，所以此处我们可以使用此方法满足需求，具体用法如下：</p>
<p>(1) 将名为 numbers.seq的顺序文件排序后，保存到名为number.map的文件夹下，该文件夹就是最终的MapFile(如果顺序文件已经排过序，则可以跳过这一步。只需要把这个文件复制到number.map/data文件，然后直接跳至第三步)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar $HADOOP_HOME/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.6.4.jar sort -r 1 \</span><br><span class="line">-inFormat org.apache.hadoop.mapreduce.lib.input.SequenceFileInputFormat \</span><br><span class="line">-outFormat org.apache.hadoop.mapreduce.lib.output.SequenceFileOutputFormat \</span><br><span class="line">-outKey org.apache.hadoop.io.IntWritable \</span><br><span class="line">-outValue org.apache.hadoop.io.Text \</span><br><span class="line">numbers.seq numbers.map</span><br></pre></td></tr></table></figure>
<p>(2) 将MapReduce的输出重命名为data文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -mv numbers.map/part-r-00000 numbers.map/data</span><br></pre></td></tr></table></figure>
<p>(3) 建立index文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java MapFileFixer numbers.map</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  project java MapFileFixer numbers.map</span><br><span class="line"><span class="number">16</span>/<span class="number">08</span>/<span class="number">13</span> <span class="number">17</span>:<span class="number">45</span>:<span class="number">39</span> WARN util.NativeCodeLoader: Unable to load native-hadoop library <span class="keyword">for</span> your platform... using builtin-java classes where applicable</span><br><span class="line"><span class="number">16</span>/<span class="number">08</span>/<span class="number">13</span> <span class="number">17</span>:<span class="number">45</span>:<span class="number">40</span> INFO compress.CodecPool: Got brand-new compressor [.deflate]</span><br><span class="line">创建MapFile numbers.map ,入口是 <span class="number">1024</span>%</span><br><span class="line">➜  project hdfs dfs -ls numbers.map</span><br><span class="line">Found <span class="number">2</span> items</span><br><span class="line">-rw-r--r--   <span class="number">1</span> streamer supergroup      <span class="number">40403</span> <span class="number">2016</span><span class="number">-08</span><span class="number">-13</span> <span class="number">17</span>:<span class="number">43</span> numbers.map/data</span><br><span class="line">-rw-r--r--   <span class="number">1</span> streamer supergroup        <span class="number">336</span> <span class="number">2016</span><span class="number">-08</span><span class="number">-13</span> <span class="number">17</span>:<span class="number">45</span> numbers.map/index</span><br></pre></td></tr></table></figure>
<p>大功告成。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop源码学习(10)——Avro(2)]]></title>
      <url>http://keyunluo.github.io/2016/08/12/2016-08-12-hadoop-io-6.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>Avro是一个独立于编程语言的数据序列化系统，该项目由Hadoop之父Doug Cutting创建，旨在解决Hadoop中Writable类型的不足：缺乏语言的可移植性。拥有一个可被多种语言(C/C++/C#/Java/PHP/Python/Ruby)处理的数据格式与绑定到单一语言的数据格式相比，前者更容易与公众共享数据。本节学习Avro数据文件、互操作性、模式解析和排列顺序。</p>
</blockquote>
<a id="more"></a>
<h2 id="Avro数据文件"><a href="#Avro数据文件" class="headerlink" title="Avro数据文件"></a>Avro数据文件</h2><p>Avro的对象容器文件格式主要用于存储Avro对象序列，这与Hadoop顺序文件的设计非常类似，主要区别在于Avro数据文件主要是面向跨语言使用而设计的，所以可以用P圆通写入文件，用C语言来读取文件。</p>
<p>数据文件的头部分包含元数据，包括一个Avro模式和一个sync marker同步标志，紧接着是一系列包含序列化Avro对象的数据块(压缩可选)，数据块由sync marker来分隔，它对该文件而言，是唯一的，并且允许在文件中搜索到任意位置之后通过块边界快速地重新进行同步。因此，Avro数据文件是可切分的，适合MapReduce快速处理。</p>
<p>将Avro对象写入数据文件和写到数据流类似，我们使用一个DatumWriter，但没有用Encoder，而是用DatumWriter来创建一个DatumFileWriter实例，然后便可以新建一个数据文件，该文件一般使用.avro扩展名并向它附加新写入的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"data.avro"</span>);</span><br><span class="line">DatumWriter&lt;GenericRecord&gt; writer =</span><br><span class="line"><span class="keyword">new</span> GenericDatumWriter&lt;GenericRecord&gt;(schema);</span><br><span class="line">DataFileWriter&lt;GenericRecord&gt; dataFileWriter =</span><br><span class="line"><span class="keyword">new</span> DataFileWriter&lt;GenericRecord&gt;(writer);</span><br><span class="line">dataFileWriter.create(schema, file);</span><br><span class="line">dataFileWriter.append(datum);</span><br><span class="line">dataFileWriter.close();</span><br></pre></td></tr></table></figure>
<p>从数据文件中读取对象与前面例子中在内存数据流中读取数据非常类似，只有一个重要区别：我们不需要指定模式，因为可以从文件元数据中读取它。事实上，还可以对DataFileReader实例调用getSchema()方法来获取该模式，并验证该模式是否和原始写入对象的模式相同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DatumReader&lt;GenericRecord&gt; reader = <span class="keyword">new</span> GenericDatumReader&lt;GenericRecord&gt;();</span><br><span class="line">DataFileReader&lt;GenericRecord&gt; dataFileReader =</span><br><span class="line"><span class="keyword">new</span> DataFileReader&lt;GenericRecord&gt;(file, reader);</span><br><span class="line">assertThat(<span class="string">"Schema is the same"</span>, schema, is(dataFileReader.getSchema()));</span><br></pre></td></tr></table></figure>
<p>DataFileReader是一个人常规的Java迭代器，由此我们可以调用其hasNext()和next()方法来迭代其数据对象。下面的代码检查是否只有一条记录以及该记录是否有期望的字段值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">assertThat(dataFileReader.hasNext(),is(True));</span><br><span class="line">GenericRecord result = dataFileReader.next();</span><br><span class="line">assertThat(result.get(<span class="string">"left"</span>).toString(),is(<span class="string">"L"</span>));</span><br><span class="line">assertThat(result.get(<span class="string">"right"</span>).toString(),is(<span class="string">"R"</span>));</span><br><span class="line">assertThat(dataFileReader.hasNext(),is(<span class="keyword">false</span>));</span><br></pre></td></tr></table></figure>
<p>但是更合适的做法是使用重载并将返回对象实例作为输入参数(该例中为GenericRecord对象)，而非直接使用next()方法，因为这样可以减少对象分配和垃圾回收所产生的开销，特别是文件中包含有很多对象时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GenericRecord record = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (dataFileReader.hasNext()) &#123;</span><br><span class="line">record = dataFileReader.next(record);</span><br><span class="line"><span class="comment">// process record</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果对象重用不是那么重要，则可以使用如下更简短的形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (GenericRecord record : dataFileReader) &#123;</span><br><span class="line"><span class="comment">// process record</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是一般的从hadoop文件系统中读取文件，可以使用Avro的FsInput对象来指定使用Hadoop Path 对象作为输入对象。事实上，DataFileReader对象提供了对Avro数据文件的随机访问(通过seek()和sync()方法)。但在大多数情况下，如果顺序访问数据流就足够了，则使用DataFileStream对象，DataFileStream对象可以从任意Java InputStream对象读取数据。</p>
<h2 id="互操作性"><a href="#互操作性" class="headerlink" title="互操作性"></a>互操作性</h2><p>为了说明互操作性，我们使用Python语言来写入数据，使用另一种语言来读取这个数据。</p>
<h3 id="关于Python-API"><a href="#关于Python-API" class="headerlink" title="关于Python API"></a>关于Python API</h3><p>下面例子中的程序从标准输入中读取由逗号分隔的字符串，并将它们以StringPair记录的方式写入Avro数据文件。与写数据文件的Java代码类似，我们新建一个DatumWriter对象和一个DataFileWriter对象，注意，我们在代码中嵌入了Avro模式，尽管没有该模式，我们仍然可以从文件中正确读取数据。</p>
<p>Python以目录的形式表示Avro记录，从标准输入中读取的每一行都转换成Dict对象并被附加到DataFileWriter对象末尾。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> avro <span class="keyword">import</span> schema</span><br><span class="line"><span class="keyword">from</span> avro <span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">from</span> avro <span class="keyword">import</span> datafile</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  <span class="keyword">if</span> len(sys.argv) !=<span class="number">2</span>:</span><br><span class="line">    sys.exit(<span class="string">"使用方法：%s &lt;data_file&gt;"</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">  avro_file = sys.argv[<span class="number">1</span>]</span><br><span class="line">  writer = open(avro_file,<span class="string">'wb'</span>)</span><br><span class="line">  datum_writer = io.DatumWriter()</span><br><span class="line">  schema_object = schema.parse(<span class="string">' \</span><br><span class="line">    &#123; "type":"record", \</span><br><span class="line">    "name":"Pair", \</span><br><span class="line">    "doc":"StringPair", \</span><br><span class="line">    "fields":[ \</span><br><span class="line">      &#123;"name":"left","type":"string"&#125;, \</span><br><span class="line">      &#123;"name":"right","type":"string"&#125; \</span><br><span class="line">    ] \</span><br><span class="line">  &#125;'</span>)</span><br><span class="line">  dfw = datafile.DataFileWriter(writer,datum_writer,schema_object)</span><br><span class="line"></span><br><span class="line">  print(<span class="string">"请输入以逗号分隔的数据，Ctrl-d结束"</span>)</span><br><span class="line">  <span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin.readlines():</span><br><span class="line">    (left,right) = string.split(line.strip(),<span class="string">','</span>)</span><br><span class="line">    dfw.append(&#123;<span class="string">'left'</span>:left,<span class="string">'right'</span>:right&#125;);</span><br><span class="line">  dfw.close()</span><br></pre></td></tr></table></figure>
<p>为了运行该程序，我们首先安装Avro：<code>pip install avro</code>,指定文件名pairs.avro,输出结果会被写到这个文件。通过标准的输入发送成对记录，结束文件输入时键入Ctrl-D:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">python avro/write_pairs.py pairs.avro</span><br><span class="line">a,<span class="number">1</span></span><br><span class="line">b,<span class="number">2</span></span><br><span class="line">c,<span class="number">3</span></span><br><span class="line">d,<span class="number">4</span></span><br><span class="line">^D</span><br></pre></td></tr></table></figure>
<h3 id="关于C-API"><a href="#关于C-API" class="headerlink" title="关于C API"></a>关于C API</h3><p>下面转向C API，写程序显示pairs.avro文件的内容，如下示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;avro.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc !=<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"使用：./dump_pairs &lt;data_file&gt;\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *avrofile = argv[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">avro_schema_error_t</span> error;</span><br><span class="line">  <span class="keyword">avro_file_reader_t</span> filereader;</span><br><span class="line">  <span class="keyword">avro_datum_t</span> pair;</span><br><span class="line">  <span class="keyword">avro_datum_t</span> left;</span><br><span class="line">  <span class="keyword">avro_datum_t</span> right;</span><br><span class="line">  <span class="keyword">int</span> rval;</span><br><span class="line">  <span class="keyword">char</span> *p;</span><br><span class="line"></span><br><span class="line">  avro_file_reader(avrofile,&amp;filereader);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">  ravl = avro_file_reader_read(filereader,<span class="literal">NULL</span>, &amp;pair);</span><br><span class="line">  <span class="keyword">if</span> (rval) <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">if</span> ( avro_record_get(pair,<span class="string">"left"</span>,&amp;left) == <span class="number">0</span>)&#123;</span><br><span class="line">    avro_string_get(left,&amp;p);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"%s,"</span>,p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (avro_record_get(pair,<span class="string">"right"</span>,&amp;right) == <span class="number">0</span>)&#123;</span><br><span class="line">    avro_string_get(right,&amp;p);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"%s,"</span>,p);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  avro_file_reader_close(filereader);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用Avro-Tools"><a href="#使用Avro-Tools" class="headerlink" title="使用Avro Tools"></a>使用Avro Tools</h3><p>下面使用Avro Tools(使用Java写的)来显示pairs.avro文件的内容，假定所有的Avro Jar包已经被下载下来，存放在$AVRO_HOME。tojson命令将Avro 数据文件转换成JSON然后在终端中显示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -jar $AVRO_HOME/avro-tools-*.jar tojson pairs.avro</span><br><span class="line">&#123;<span class="string">"left"</span>:<span class="string">"a"</span>,<span class="string">"right"</span>:<span class="string">"1"</span>&#125;</span><br><span class="line">&#123;<span class="string">"left"</span>:<span class="string">"b"</span>,<span class="string">"right"</span>:<span class="string">"2"</span>&#125;</span><br><span class="line">&#123;<span class="string">"left"</span>:<span class="string">"c"</span>,<span class="string">"right"</span>:<span class="string">"3"</span>&#125;</span><br><span class="line">&#123;<span class="string">"left"</span>:<span class="string">"d"</span>,<span class="string">"right"</span>:<span class="string">"4"</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模式的解析"><a href="#模式的解析" class="headerlink" title="模式的解析"></a>模式的解析</h2><p>在选择的时候，读取数据的模式可以不同于我们写入数据的模式，这意味着模式演化。例如，为了便于说明，我们考虑新增一个description字段，形成一个新的模式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"record"</span>,</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"StringPair"</span>,</span><br><span class="line"><span class="attr">"doc"</span>: <span class="string">"A pair of strings with an added field."</span>,</span><br><span class="line"><span class="attr">"fields"</span>: [</span><br><span class="line">&#123;<span class="attr">"name"</span>: <span class="string">"left"</span>, <span class="attr">"type"</span>: <span class="string">"string"</span>&#125;,</span><br><span class="line">&#123;<span class="attr">"name"</span>: <span class="string">"right"</span>, <span class="attr">"type"</span>: <span class="string">"string"</span>&#125;,</span><br><span class="line">&#123;<span class="attr">"name"</span>: <span class="string">"description"</span>, <span class="attr">"type"</span>: <span class="string">"string"</span>, <span class="attr">"default"</span>: <span class="string">""</span>&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用该模式读取前面序列化的数据，因为我们已经为description字段指定了一个默认值(空字符串)共Avro在读取没有字段的记录时使用。如果忽略default属性，在读取旧数据时会报错。</p>
<p>读模式不同于写模式，我们调用GenericDatumReader的构造函数，它取两个模式对象，即读取对象和写入对象，并按照以下顺序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DatumReader&lt;GenericRecord&gt; reader =</span><br><span class="line"><span class="keyword">new</span> GenericDatumReader&lt;GenericRecord&gt;(schema, newSchema);</span><br><span class="line">Decoder decoder = DecoderFactory.get().binaryDecoder(out.toByteArray(),</span><br><span class="line"><span class="keyword">null</span>);</span><br><span class="line">GenericRecord result = reader.read(<span class="keyword">null</span>, decoder);</span><br><span class="line">assertThat(result.get(<span class="string">"left"</span>).toString(), is(<span class="string">"L"</span>));</span><br><span class="line">assertThat(result.get(<span class="string">"right"</span>).toString(), is(<span class="string">"R"</span>));</span><br><span class="line">assertThat(result.get(<span class="string">"description"</span>).toString(), is(<span class="string">""</span>));</span><br></pre></td></tr></table></figure>
<p>对于元数据中存储有写入模式的数据文件，我们只需要显示指定写入模式，具体做法是向写入模式传递null：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DatumReader&lt;GenericRecord&gt; reader =</span><br><span class="line"><span class="keyword">new</span> GenericDatumReader&lt;GenericRecord&gt;(<span class="keyword">null</span>, newSchema);</span><br></pre></td></tr></table></figure>
<p>另一个不同的读取模式的应用是去掉记录中的某些字段，该操作可以被称为投影(projection)。记录中有大量字段但如果只需要读取其中一部分，这种做法非常有用。例如，可以使用这一模式只读取StringPair对象的right字段：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"record"</span>,</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"StringPair"</span>,</span><br><span class="line"><span class="attr">"doc"</span>: <span class="string">"The right field of a pair of strings."</span>,</span><br><span class="line"><span class="attr">"fields"</span>: [</span><br><span class="line">&#123;<span class="attr">"name"</span>: <span class="string">"right"</span>, <span class="attr">"type"</span>: <span class="string">"string"</span>&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模式解析规则可以直接解决模式由一个版本演化到另一个版本时可能产生的问题，Avro规范中对所有Avro类型均有详细说明。下表从类型读写(客户端和服务器端)的角度总结了记录演化规则。</p>
<table>
<thead>
<tr>
<th style="text-align:left">新模式</th>
<th style="text-align:left">写入</th>
<th style="text-align:left">读取</th>
<th style="text-align:left">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">增加的字段</td>
<td style="text-align:left">旧</td>
<td style="text-align:left">新</td>
<td style="text-align:left">通过默认值读取新字段，因为写入时没有该字段</td>
</tr>
<tr>
<td style="text-align:left">增加的字段</td>
<td style="text-align:left">新</td>
<td style="text-align:left">旧</td>
<td style="text-align:left">读取时不知道新写入的字段，所以忽略该字段(投影)</td>
</tr>
<tr>
<td style="text-align:left">删除的字段</td>
<td style="text-align:left">旧</td>
<td style="text-align:left">新</td>
<td style="text-align:left">读取时忽略已删除的字段(投影)</td>
</tr>
<tr>
<td style="text-align:left">删除的字段</td>
<td style="text-align:left">新</td>
<td style="text-align:left">旧</td>
<td style="text-align:left">写入时不写入已删除的字段。如果旧模式对该字段有默认值，那么读取时可以使用该默认值，否则报错。在这种情况下，最好同时更新读取模式或在更新写入模式之前更新读取模式</td>
</tr>
</tbody>
</table>
<p>Avro模式演化的另一个有用的技术是使用别名。别名允许你在读取Avro数据的模式时写入Avro数据的模式中使用不同的名称。例如，下面读取模式可以使用新的字段名称(即first和second)来读取StringPair数据，而非写入数据时使用的字段名称(即left和right)。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"record"</span>,</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"StringPair"</span>,</span><br><span class="line"><span class="attr">"doc"</span>: <span class="string">"A pair of strings with aliased field names."</span>,</span><br><span class="line"><span class="attr">"fields"</span>: [</span><br><span class="line">&#123;<span class="attr">"name"</span>: <span class="string">"first"</span>, <span class="attr">"type"</span>: <span class="string">"string"</span>, <span class="attr">"aliases"</span>: [<span class="string">"left"</span>]&#125;,</span><br><span class="line">&#123;<span class="attr">"name"</span>: <span class="string">"second"</span>, <span class="attr">"type"</span>: <span class="string">"string"</span>, <span class="attr">"aliases"</span>: [<span class="string">"right"</span>]&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，别名的主要作用是将写入模式转换(在读取的时候)为读取模式，但是别名对读取模式程序不是可见的。在上述程序中，读取程序无法再使用字段名left和right，因为他们已经被转换成first和second了。</p>
<h2 id="排列顺序"><a href="#排列顺序" class="headerlink" title="排列顺序"></a>排列顺序</h2><p>Avro定义了对象的排列顺序。Avro大多数类型的排列顺序与用户的期望符合，例如，数值型按照数值的升序进行排列，其他的就没有这么巧妙了，例如枚举通过符号的定义而非符号字符串的值来排序。</p>
<p>除了record之外，所有的类型均按照Avro规范中预先定义的规则来排序，这些规则不能被用户改写。但对于记录，可以指定order属性来控制排列顺序。它有三个值：ascending(默认值)、descending(降序)或ignore(为了比较目的，可以忽略该字段)。</p>
<p>例如，通过将right字段设置为descending,下述模式(SortedStringPair.avsc)定义StringPair记录按降序顺序。为了排序的目的，忽略left字段，但依旧保留在投影中：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"record"</span>,</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"StringPair"</span>,</span><br><span class="line"><span class="attr">"doc"</span>: <span class="string">"A pair of strings, sorted by right field descending."</span>,</span><br><span class="line"><span class="attr">"fields"</span>: [</span><br><span class="line">&#123;<span class="attr">"name"</span>: <span class="string">"left"</span>, <span class="attr">"type"</span>: <span class="string">"string"</span>, <span class="attr">"order"</span>: <span class="string">"ignore"</span>&#125;,</span><br><span class="line">&#123;<span class="attr">"name"</span>: <span class="string">"right"</span>, <span class="attr">"type"</span>: <span class="string">"string"</span>, <span class="attr">"order"</span>: <span class="string">"descending"</span>&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照读取模式中的文档顺序，记录中的字段两两进行比较。这样，通过指定一个恰当的读取模式，便可以对数据记录使用任意顺序。该模式(SwitchedStringPair.avsc)首先定义了一组right字段的顺序，然后是left字段的顺序：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"record"</span>,</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"StringPair"</span>,</span><br><span class="line"><span class="attr">"doc"</span>: <span class="string">"A pair of strings, sorted by right then left."</span>,</span><br><span class="line"><span class="attr">"fields"</span>: [</span><br><span class="line">&#123;<span class="attr">"name"</span>: <span class="string">"right"</span>, <span class="attr">"type"</span>: <span class="string">"string"</span>&#125;,</span><br><span class="line">&#123;<span class="attr">"name"</span>: <span class="string">"left"</span>, <span class="attr">"type"</span>: <span class="string">"string"</span>&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Avro实现了高效的二进制比较，也就是说Avro不需要将二进制对象反序列化成对象就可以实现比较，因为它可以直接对字节流进行操作。在使用StringPair模式的情况下(没有order属性)，Avro按以下方式实现了二进制比较：第一个字段(即left字段)，使用UTF-8编码，由此Avro可以根据字母表顺序进行比较，如果它们的顺序是不确定的，那么Avro可以在该处停止比较。否则，如果这两个字节顺序是相同的，那么它们比较第二个字段(right)，同样在字节尺度上使用字母表排序，因为该字段同样也使用UTF-8编码。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul>
<li><a href="/resource/codes/2016-08-12/AvroTest.java">AvroTest.java</a></li>
<li><a href="/resource/codes/2016-08-12/write_pairs.py">write_pairs.py</a></li>
<li><a href="/resource/codes/2016-08-12/StringPair.avsc">StringPair.avsc</a></li>
<li><a href="/resource/codes/2016-08-12/StringPairNew.avsc">StringPairNew.avsc</a></li>
</ul>
<p>运行：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">javac -cp avro-<span class="number">1.7</span>.7.jar:jackson-core-asl-<span class="number">1.9</span>.13.jar:avro-maven-plugin-<span class="number">1.7</span>.7.jar AvroTest.java</span><br><span class="line">java -classpath jackson-mapper-asl-<span class="number">1.9</span>.13.jar:avro-<span class="number">1.7</span>.7.jar:jackson-core-asl-<span class="number">1.9</span>.13.jar:$CLASSPATH AvroTest</span><br><span class="line">从字节缓冲区中读取对象</span><br><span class="line">读取结果：left:L</span><br><span class="line">读取结果：right:R</span><br><span class="line">从数据文件中读取对象</span><br><span class="line">读取结果：left:L</span><br><span class="line">读取结果：right:R</span><br><span class="line">新模式读取对象</span><br><span class="line">读取结果：left:L</span><br><span class="line">读取结果：right:R</span><br><span class="line">读取结果：description:</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop源码学习(9)——Avro(1)]]></title>
      <url>http://keyunluo.github.io/2016/08/11/2016-08-11-hadoop-io-5.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>Avro是一个独立于编程语言的数据序列化系统，该项目由Hadoop之父Doug Cutting创建，旨在解决Hadoop中Writable类型的不足：缺乏语言的可移植性。拥有一个可被多种语言(C/C++/C#/Java/PHP/Python/Ruby)处理的数据格式与绑定到单一语言的数据格式相比，前者更容易与公众共享数据。本节学习Avro数据序列化系统。</p>
</blockquote>
<a id="more"></a>
<h2 id="Avro特点"><a href="#Avro特点" class="headerlink" title="Avro特点"></a>Avro特点</h2><ul>
<li>Avro数据使用语言无关的模式定义的，代码生成是可选的</li>
<li>Avro模式通常用JSON来写，数据通常采用二进制格式来编码</li>
<li>Avro规范精确定义所有实现都必须支持的二进制格式</li>
<li>Avro有丰富的模式解析能力，支持模式演化，即新模式能够读取旧模式定义的数据，旧模式也能读取新模式的数据同时忽略新模式中新加入的字段</li>
<li>Avro为一系列对象指定了一个对象容器格式——类似于Hadoop的顺序文件，Avro数据文件包含元数据项，使此文件可以自我声明，并且Avro数据支持压缩和可切分</li>
<li>Avro还可以用于RPC</li>
</ul>
<h2 id="Avro数据类型和模式"><a href="#Avro数据类型和模式" class="headerlink" title="Avro数据类型和模式"></a>Avro数据类型和模式</h2><p>Avro定义了少量数据基本类型，它们可用于以写模式的方式来构建应用特定的数据结构，考虑到互操作性，其实现必须支持所有的Avro类型。</p>
<p>Avro的基本类型如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"type"</span>:<span class="string">"null"</span>&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">模式示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">null</td>
<td style="text-align:left">空值</td>
<td style="text-align:left">“null”</td>
</tr>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:left">布尔类型</td>
<td style="text-align:left">“boolean”</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">32位带符号整数</td>
<td style="text-align:left">“int”</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td style="text-align:left">64位带符号整数</td>
<td style="text-align:left">“long”</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">单精度(32-bit) IEEE 754 浮点数</td>
<td style="text-align:left">“float”</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">双精度 (64-bit) IEEE 754 浮点数</td>
<td style="text-align:left">“double”</td>
</tr>
<tr>
<td style="text-align:left">bytes</td>
<td style="text-align:left">8位无符号字节序列</td>
<td style="text-align:left">“bytes”</td>
</tr>
<tr>
<td style="text-align:left">string</td>
<td style="text-align:left">Unicode字符序列</td>
<td style="text-align:left">“string”</td>
</tr>
</tbody>
</table>
<p>Avro复杂类型如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">模式示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">array</td>
<td style="text-align:left">一个排过序的对象集合。特定数组中的所有对象必须模式相同</td>
<td style="text-align:left">{ “type”: “array”,”items”: “long”}</td>
</tr>
<tr>
<td style="text-align:left">map</td>
<td style="text-align:left">未排过序的键值对。键必须是字符串，值可以是任何类型，但一个特定map中所有值必须模式相同</td>
<td style="text-align:left">{“type”: “map”,”values”:”string”}</td>
</tr>
<tr>
<td style="text-align:left">record</td>
<td style="text-align:left">一个任意类型的命名字段集合</td>
<td style="text-align:left">{“type”: “record”,”name”:”WeatherRecord”,”doc”: “A weather reading.”,”fields”: [{“name”:”year”, “type”:”int”},{“name”:”temperature”,”type”: “int”},{“name”:”stationId”,”type”: “string”}]}</td>
</tr>
<tr>
<td style="text-align:left">enum</td>
<td style="text-align:left">一个命名的值集合</td>
<td style="text-align:left">{“type”: “enum”,”name”:”Cutlery”,”doc”: “An eating utensil.”,”symbols”:[“KNIFE”, “FORK”,”SPOON”]}</td>
</tr>
<tr>
<td style="text-align:left">fixed</td>
<td style="text-align:left">一组固定数量的8位无符号字节</td>
<td style="text-align:left">{“type”: “fixed”,”name”:”Md5Hash”,”size”: 16}</td>
</tr>
<tr>
<td style="text-align:left">union</td>
<td style="text-align:left">模式的并集，并集可用JSON数组表示，其中每个元素为一个模式。并集表示的数据必须与其中一个模式相匹配</td>
<td style="text-align:left">[“null”,”string”,{“type”: “map”,”values”: “string”}]</td>
</tr>
</tbody>
</table>
<p>一种语言可能有多种表示或映射。所有的语言都支持动态映射，即使运行前并不知道具体模式，也可以使用动态映射。对此，Java称为通用映射。</p>
<p>另外，Java和C++实现可以自动生成代码来表示符合某种Avro模式的数据。代码生成(code generation，Java中称为“特殊映射”)能优化数据处理，如果读写数据之前就有一个模式备份。那么，为用户代码生成的类和通用代码生成的类相比，前者提供的API更贴近问题域。</p>
<p>Java拥有第三类映射，即自反映射(reflect mapping,将Avro类型映射到已有的Java类型)，它的速度比通用映射和特殊映射都慢，所以不推荐在新应用中使用。</p>
<p>特殊映射与通用映射仅在record，enum，fixed是那个类型方面有区别，其他所有类型均有自动生成的类(类名由name属性和可选的namespace属性决定)。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Avro类型</th>
<th style="text-align:left">通用Java映射</th>
<th style="text-align:left">特殊Java映射</th>
<th style="text-align:left">Java自反映射</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">null</td>
<td style="text-align:left">null type</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">int</td>
<td style="text-align:left"></td>
<td style="text-align:left">byte, short, int</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td style="text-align:left">long</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">float</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">double</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">bytes</td>
<td style="text-align:left">java.nio.ByteBuffer</td>
<td style="text-align:left"></td>
<td style="text-align:left">字节数组</td>
</tr>
<tr>
<td style="text-align:left">string</td>
<td style="text-align:left">org.apache.avro.util.Utf8(高效，优先使用) or java.lang.String</td>
<td style="text-align:left"></td>
<td style="text-align:left">java.lang.String</td>
</tr>
<tr>
<td style="text-align:left">array</td>
<td style="text-align:left">org.apache.avro.generic.GenericArray</td>
<td style="text-align:left"></td>
<td style="text-align:left">数组或 java.util.Collection</td>
</tr>
<tr>
<td style="text-align:left">map</td>
<td style="text-align:left">java.util.Map</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">record</td>
<td style="text-align:left">org.apache.avro.generic.GenericRecord</td>
<td style="text-align:left">生成实现org.apache.avro.specific.SpecificRecord 类的实现</td>
<td style="text-align:left">具有零参数构造函数的任意用户类，继承了所有不传递的实例字段</td>
</tr>
<tr>
<td style="text-align:left">enum</td>
<td style="text-align:left">java.lang.String</td>
<td style="text-align:left">生成Java enum类型</td>
<td style="text-align:left">任意Java enum类型</td>
</tr>
<tr>
<td style="text-align:left">fixed</td>
<td style="text-align:left">org.apache.avro. generic.GenericFixed</td>
<td style="text-align:left">生成实现org.apache.avro.specific.SpecificFixed</td>
<td style="text-align:left">org.apache.avro.generic.genericFixed</td>
</tr>
<tr>
<td style="text-align:left">union</td>
<td style="text-align:left">java.lang.Object</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h2 id="内存中的序列化和反序列化"><a href="#内存中的序列化和反序列化" class="headerlink" title="内存中的序列化和反序列化"></a>内存中的序列化和反序列化</h2><p>Avro为序列化和反序列化提供了API，如果想把Avro集成到现有系统(比如已定义帧格式的消息系统)，这些API函数就很有用。其他情况，请考虑使用Avro的数据文件格式。</p>
<h3 id="通用API"><a href="#通用API" class="headerlink" title="通用API"></a>通用API</h3><p>让我们写一个Java程序从数据流读写Avro数据。首先以一个简单的Avro模式为例，它用于表示以记录形式出现的一对字符串：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"type"</span>: <span class="string">"record"</span>,</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"StringPair"</span>,</span><br><span class="line"><span class="attr">"doc"</span>: <span class="string">"A pair of strings."</span>,</span><br><span class="line"><span class="attr">"fields"</span>: [</span><br><span class="line">&#123;<span class="attr">"name"</span>: <span class="string">"left"</span>, <span class="attr">"type"</span>: <span class="string">"string"</span>&#125;,</span><br><span class="line">&#123;<span class="attr">"name"</span>: <span class="string">"right"</span>, <span class="attr">"type"</span>: <span class="string">"string"</span>&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这一模式存储在类路径下一个名为StringPair.avsc的文件中吗，我们可以通过下面两行代码进行加载：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Schema.Parser parser = <span class="keyword">new</span> Schema.Parser();</span><br><span class="line">Schema schema = parser.parse(getClass().getResourceAsStream(<span class="string">"StringPair.avsc"</span>));</span><br></pre></td></tr></table></figure>
<p>我们可以使用以下通用API新建一个Avro记录的实例：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GenericRecord datum = <span class="keyword">new</span> GenericData.Record(schema);</span><br><span class="line">datum.put(<span class="string">"left"</span>,<span class="keyword">new</span> Utf8(<span class="string">"L"</span>));</span><br><span class="line">datum.put(<span class="string">"right"</span>,<span class="keyword">new</span> Utf8(<span class="string">"R"</span>));</span><br></pre></td></tr></table></figure></p>
<p>接下来，将记录序列化到输出流中：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">DatumWriter&lt;GenericRecord&gt; writer =</span><br><span class="line"><span class="keyword">new</span> GenericDatumWriter&lt;GenericRecord&gt;(schema);</span><br><span class="line">Encoder encoder = EncoderFactory.get().binaryEncoder(out, <span class="keyword">null</span>);</span><br><span class="line">writer.write(datum, encoder);</span><br><span class="line">encoder.flush();</span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure></p>
<p>这里有两个重要的对象：DatumWriter和Encoder。DatumWriter对象将数据对象翻译成Encoder对象可以理解的模型，然后由后者写入到输出流。这里，我们使用GenericDatumWriter对象，它将GenericRecord字段的值传递给Encoder对象。我们将null传给encoder工厂，因为我们这里没有重用先前构建的encoder。</p>
<p>我们可以使用反向的处理过程从字节缓冲区中读回对象：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DatumReader&lt;GenericRecord&gt; reader =</span><br><span class="line"><span class="keyword">new</span> GenericDatumReader&lt;GenericRecord&gt;(schema);</span><br><span class="line">Decoder decoder = DecoderFactory.get().binaryDecoder(out.toByteArray(),</span><br><span class="line"><span class="keyword">null</span>);</span><br><span class="line">GenericRecord result = reader.read(<span class="keyword">null</span>, decoder);</span><br><span class="line">assertThat(result.get(<span class="string">"left"</span>).toString(), is(<span class="string">"L"</span>));</span><br><span class="line">assertThat(result.get(<span class="string">"right"</span>).toString(), is(<span class="string">"R"</span>));</span><br></pre></td></tr></table></figure></p>
<p>我们需要传递空值(null)并调用binaryDecoder()和read()方法，因为这里没有重用对象(分别是decoder或记录)。</p>
<p>由result.get(“left”)和result.get(“right”)的输出对象是Utf8类型，因此我们需要通过调用toString()方法将他们转型为Java String类型。</p>
<h3 id="特定API"><a href="#特定API" class="headerlink" title="特定API"></a>特定API</h3><p>通过使用Avro的Maven插件编译模式，我们可以根据模式文件生成StringPair类，以下是与Maven Project Object Model(POM)相关的部分：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.avro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>avro-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;avro.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>schemas<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-sources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">goal</span>&gt;</span>schema<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>StringPair.avsc<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">stringType</span>&gt;</span>String<span class="tag">&lt;/<span class="name">stringType</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/generated-sources/java</span><br><span class="line">              <span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在序列化和反序列化的代码中，我们构建一个StringPair实例来替代GenericRecord对象(使用SpecificDatumWriter类将该对象写入数据流),并使用SpecificDatumRecorder类读回数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">StringPair datum = <span class="keyword">new</span> StringPair();</span><br><span class="line">datum.setLeft(<span class="string">"L"</span>);</span><br><span class="line">datum.setRight(<span class="string">"R"</span>);</span><br><span class="line">ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">DatumWriter&lt;StringPair&gt; writer =</span><br><span class="line"><span class="keyword">new</span> SpecificDatumWriter&lt;StringPair&gt;(StringPair.class);</span><br><span class="line">Encoder encoder = EncoderFactory.get().binaryEncoder(out, <span class="keyword">null</span>);</span><br><span class="line">writer.write(datum, encoder);</span><br><span class="line">encoder.flush();</span><br><span class="line">out.close();</span><br><span class="line">DatumReader&lt;StringPair&gt; reader =</span><br><span class="line"><span class="keyword">new</span> SpecificDatumReader&lt;StringPair&gt;(StringPair.class);</span><br><span class="line">Decoder decoder = DecoderFactory.get().binaryDecoder(out.toByteArray(),</span><br><span class="line"><span class="keyword">null</span>);</span><br><span class="line">StringPair result = reader.read(<span class="keyword">null</span>, decoder);</span><br><span class="line">assertThat(result.getLeft(), is(<span class="string">"L"</span>));</span><br><span class="line">assertThat(result.getRight(), is(<span class="string">"R"</span>));</span><br></pre></td></tr></table></figure>
<p>从Avro1.6.0版本开始，生成的Java代码中包含有get()和set()方法，因此不用再写datum.setLeft(“L”)和result.getLeft()方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop源码学习(8)——序列化]]></title>
      <url>http://keyunluo.github.io/2016/08/10/2016-08-10-hadoop-io-4.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>序列化是指将结构化对象转换成字节流以便在网络上传输或写到磁盘进行永久存储的过程。序列化在分布式数据处理的两大领域经常出现：进程间通信和永久存储。本节学习Hadoop序列化的实现机制。</p>
</blockquote>
<a id="more"></a>
<h2 id="Java内建序列化机制"><a href="#Java内建序列化机制" class="headerlink" title="Java内建序列化机制"></a>Java内建序列化机制</h2><p>序列化用途：</p>
<ul>
<li>作为一种持久化格式：一个对象被序列化后，它的编码可以被存储在磁盘上，供以后反序列化使用。</li>
<li>作为一种数据通信格式：序列化结果可以从一个正在运行的虚拟机，通过网络传输到另一个虚拟机上。</li>
<li>作为一种拷贝机制：将对象序列化到内存的缓冲区中，然后通过反序列化，可以得到一个对已存在对象进行深拷贝的新对象。</li>
</ul>
<p>Java序列化机制将对象转换成连续的byte数据，使用时只需要在类声明中加入implements Serializable即可。序列化的结果中包含了大量与类相关的信息，父类的信息也会递归的保存下来，导致序列化结果膨胀，对于需要保存和处理大规模数据的Hadoop来说，需要一个新的序列化机制。</p>
<h2 id="Hadoop序列化机制"><a href="#Hadoop序列化机制" class="headerlink" title="Hadoop序列化机制"></a>Hadoop序列化机制</h2><p>和Java序列化机制不同(在对象流ObjectOutputStream对象上调用writeObject()方法)，Hadoop的序列化机制通过调用对象的write()方法(它带有一个类型为DataOutput的参数)，将对象序列化到流中，反序列化则通过readFields()方法从流中读取数据，并且用户可以复用同一个对象得到多个反序列化的结果。</p>
<h2 id="Hadoop序列化机制的特征"><a href="#Hadoop序列化机制的特征" class="headerlink" title="Hadoop序列化机制的特征"></a>Hadoop序列化机制的特征</h2><ul>
<li>紧凑：充分利用数据中心的带宽</li>
<li>快速：在进程间通信时会大量使用到序列化机制，因此必须减少序列化和反序列化的开销</li>
<li>可扩展：序列化机制要支持系统间通信协议的升级后和类的定义变化</li>
<li>互操作：可以支持不同开发语言间的通信，如C++和Java，这样的通信可以通过文件或IPC机制实现</li>
</ul>
<p>Java的序列化机制虽然强大，却不符合上面这些要求，Java Serialization将每个对象的类名写入输出流中，导致要占用比原来对象更多的空间，同时，为了减少数据量，同一个类的对象的序列化结果只输出一份元数据，并通过某种形式的引用来共享元数据。引用导致对序列化后的流进行处理时需要保持一些状态。在一些场景中，有一个上百G的文件中，反序列化某个对象，需要访问文件中前面的某一个元数据，这将导致这个文件不能被切割，并通过MapReduce处理。</p>
<h2 id="Hadoop序列化框架"><a href="#Hadoop序列化框架" class="headerlink" title="Hadoop序列化框架"></a>Hadoop序列化框架</h2><h3 id="相关项目"><a href="#相关项目" class="headerlink" title="相关项目"></a>相关项目</h3><p>大部分的MapReduce程序都使用Writable键-值对作为输入输出，但这并不是Hadoop API指定的，其他的序列化机制也能和Hadoop配合，并应用于MapReduce中。如：Hadoop Avro,Apache Thrift和Google Protocol Buffer。</p>
<ul>
<li>Avro:数据序列化系统，用于支持大批量数据交换的应用，它的主要特点是：支持二进制序列化方式，可以便捷、快速的处理大批量数据，动态语言支持良好，Avro提供的机制时动态语言可以很方便地处理Avro数据。</li>
<li>Thrift:是一个可伸缩的、跨语言的服务开发框架，由FaceBook贡献给开源社区。基于Thrift的跨平台能力封装的Hadoop文件系统Thrift API提供了不同开发语言开发的系统访问HDFS的能力。</li>
<li>Protocol Buffer：是Google内部的混合语言数据标准，提供了一种轻便高效的结构化数据存储方式，目前提供了C++/Java/Python三种语言的API，广泛应用于Google内部的通信协议、数据存储等领域。</li>
</ul>
<h3 id="Serialization序列化框架"><a href="#Serialization序列化框架" class="headerlink" title="Serialization序列化框架"></a>Serialization序列化框架</h3><p>Hadoop提供了一个简单的序列化框架API，用于集成各种序列化实现，该框架由Serialization实现(在org.apache.hadoop.io.serializer包中)。</p>
<p>Serialization是一个接口，使用抽象工厂的设计模式，提供了一系列和序列化相关并相互依赖对象的接口。通过Serialization应用可以获得类型的Serializer实例，即将一个对象转换为一个字节流的实现实例，Deserializer实例和Serializer实例相反，它用于将一个字节流转换成一个对象。很明显，Serializer和Deserializer相互依赖，所以必须通过抽象工厂Serialization，才能获得对应的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serialization</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 客户端用于判断序列化实现是否支持该类对象</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(Class&lt;?&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获得用于序列化对象的Serialization实现</span></span><br><span class="line">  <span class="function">Serializer&lt;T&gt; <span class="title">getSerializer</span><span class="params">(Class&lt;T&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获得用于反序列化对象的Deserializer实现</span></span><br><span class="line">  <span class="function">Deserializer&lt;T&gt; <span class="title">getDeserializer</span><span class="params">(Class&lt;T&gt; c)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要使用Serializer来执行序列化，一般需要通过open()方法打开Serializer，open()方法传入一个底层的流对象，然后就可以使用serialize()方法序列化对象到底层的流中。最后序列化结束时，通过close()方法关闭Serializer，Serializer接口的相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 为输出(序列化)对象做准备</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将对象序列化到底层的流中</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">serialize</span><span class="params">(T t)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 序列化结束，清理</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Hadoop目前支持两个Serialization实现：支持Writable的WritableSerialization和支持Java序列化的JavaSerialization。通过JavaSerialization可以在MapReduce程序中方便地使用标准的Java类型，如int，String等，但Java的ObjectSerialization不如Hadoop序列化机制有效，不推荐使用。</p>
<h3 id="使用序列化框架"><a href="#使用序列化框架" class="headerlink" title="使用序列化框架"></a>使用序列化框架</h3><p>将io.serializations属性设置为一个由逗号分隔的类名列表，即可以注册Serialization实现。它的默认值包括org.apache.hadoop.io.serializer.WritableSerialization和Avro指定序列化和反序列化类，这意味着只有Writable对象和Avro对象才可以在外部序列化和反序列化。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop源码学习(7)——Writable(2)]]></title>
      <url>http://keyunluo.github.io/2016/08/10/2016-08-10-hadoop-io-3.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>Writable是Hadoop的核心，Hadoop通过它定义了Hadoop中基本的数据类型及其操作，它是实现序列化的基础，本节学习其中的几个重要的工具类的实现。</p>
</blockquote>
<a id="more"></a>
<h2 id="WritableUtils"><a href="#WritableUtils" class="headerlink" title="WritableUtils"></a>WritableUtils</h2><table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">返回值</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">readCompressedByteArray</td>
<td style="text-align:left">DataInput in</td>
<td style="text-align:left">byte []</td>
<td style="text-align:left">读取压缩的GZIP字节数组</td>
</tr>
<tr>
<td style="text-align:left">skipCompressedByteArray</td>
<td style="text-align:left">DataInput in</td>
<td style="text-align:left">void</td>
<td style="text-align:left">跳过压缩的字节数组</td>
</tr>
<tr>
<td style="text-align:left">writeCompressedByteArray</td>
<td style="text-align:left">DataOutput out , byte[] bytes</td>
<td style="text-align:left">int</td>
<td style="text-align:left">写入压缩的字节数组</td>
</tr>
<tr>
<td style="text-align:left">readCompressedString</td>
<td style="text-align:left">DataInput in</td>
<td style="text-align:left">String</td>
<td style="text-align:left">读取压缩的字符串</td>
</tr>
<tr>
<td style="text-align:left">writeCompressedString</td>
<td style="text-align:left">DataOutput out , String s</td>
<td style="text-align:left">int</td>
<td style="text-align:left">写入压缩的字符串</td>
</tr>
<tr>
<td style="text-align:left">writeString</td>
<td style="text-align:left">DataOutput out ,String s</td>
<td style="text-align:left">void</td>
<td style="text-align:left">写字符串</td>
</tr>
<tr>
<td style="text-align:left">readString</td>
<td style="text-align:left">DataInput in</td>
<td style="text-align:left">String</td>
<td style="text-align:left">读字符串</td>
</tr>
<tr>
<td style="text-align:left">writeStringArray</td>
<td style="text-align:left">DataOutput out ,String[] s</td>
<td style="text-align:left">void</td>
<td style="text-align:left">写字符串数组</td>
</tr>
<tr>
<td style="text-align:left">writeCompressedStringArray</td>
<td style="text-align:left">DataOutput out ,String[] s</td>
<td style="text-align:left">void</td>
<td style="text-align:left">写压缩字符串数组</td>
</tr>
<tr>
<td style="text-align:left">readStringArray</td>
<td style="text-align:left">DataInput in</td>
<td style="text-align:left">String</td>
<td style="text-align:left">读字符串数组</td>
</tr>
<tr>
<td style="text-align:left">readCompressedStringArray</td>
<td style="text-align:left">DataInput in</td>
<td style="text-align:left">String []</td>
<td style="text-align:left">读压缩字符串数组</td>
</tr>
<tr>
<td style="text-align:left">displayByteArray</td>
<td style="text-align:left">byte[] record</td>
<td style="text-align:left">void</td>
<td style="text-align:left">显示ByteArray</td>
</tr>
<tr>
<td style="text-align:left">clone</td>
<td style="text-align:left">T orig,Configuration conf</td>
<td style="text-align:left">&lt; T extends Writable> T</td>
<td style="text-align:left">使用序列化拷贝一个writable object到buffer中</td>
</tr>
<tr>
<td style="text-align:left">cloneInto</td>
<td style="text-align:left">Writable dst , Writable src</td>
<td style="text-align:left">void</td>
<td style="text-align:left">已经弃用的方法，功能同上面拷贝一样</td>
</tr>
<tr>
<td style="text-align:left">writeVInt</td>
<td style="text-align:left">DataOutput stream, int i</td>
<td style="text-align:left">void</td>
<td style="text-align:left">写VInt型数据</td>
</tr>
<tr>
<td style="text-align:left">writeVLong</td>
<td style="text-align:left">DataOutput stream, long i</td>
<td style="text-align:left">void</td>
<td style="text-align:left">写VLong型数据</td>
</tr>
<tr>
<td style="text-align:left">readLong</td>
<td style="text-align:left">DataInput stream</td>
<td style="text-align:left">void</td>
<td style="text-align:left">读Long型数据</td>
</tr>
<tr>
<td style="text-align:left">readVInt</td>
<td style="text-align:left">DataInput stream</td>
<td style="text-align:left">int</td>
<td style="text-align:left">读VInt型数据</td>
</tr>
<tr>
<td style="text-align:left">readVIntInRange</td>
<td style="text-align:left">DataInput stream,int lower,int upper</td>
<td style="text-align:left">int</td>
<td style="text-align:left">读VInt型数据,验证其处于[lower,upper]之间</td>
</tr>
<tr>
<td style="text-align:left">isNegativeVInt</td>
<td style="text-align:left">byte value</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">判断byte第一位是否为负</td>
</tr>
<tr>
<td style="text-align:left">decodeVIntSize</td>
<td style="text-align:left">byte value</td>
<td style="text-align:left">int</td>
<td style="text-align:left">通过第一位返回bytes大小</td>
</tr>
<tr>
<td style="text-align:left">getVIntSize</td>
<td style="text-align:left">long i</td>
<td style="text-align:left">int</td>
<td style="text-align:left">获得变长存储的整数编码长度</td>
</tr>
<tr>
<td style="text-align:left">readEnum</td>
<td style="text-align:left">DataInput in,Class<t> enumType</t></td>
<td style="text-align:left">&lt; T extends Enum &lt; T &gt;&gt; T</td>
<td style="text-align:left">从DataInput中读取枚举值</td>
</tr>
<tr>
<td style="text-align:left">writeEnum</td>
<td style="text-align:left">DataOutput out,Enum &lt; ?&gt; enumVal</td>
<td style="text-align:left">void</td>
<td style="text-align:left">把字符串类型的枚举值写入DataOutput</td>
</tr>
<tr>
<td style="text-align:left">skipFully</td>
<td style="text-align:left">DataInput in, int len</td>
<td style="text-align:left">void</td>
<td style="text-align:left">在输入流中跳过len长度的字节</td>
</tr>
<tr>
<td style="text-align:left">toByteArray</td>
<td style="text-align:left">Wriatble… writables</td>
<td style="text-align:left">byte[]</td>
<td style="text-align:left">把Writable转换成byte array</td>
</tr>
<tr>
<td style="text-align:left">readStringSafely</td>
<td style="text-align:left">DataInput in,int maxLength</td>
<td style="text-align:left">String</td>
<td style="text-align:left">读取字符串，但是检查正确性</td>
</tr>
</tbody>
</table>
<h2 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h2><ul>
<li>encode：将String使用UTF-8编码成字节bytes,如果replace参数为true，那么难看的输入将会被替换的字母U+FFFD代替，否则抛出一个MalformedInputException</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">encode</span><span class="params">(String string, <span class="keyword">boolean</span> replace)</span></span><br><span class="line">    <span class="keyword">throws</span> CharacterCodingException </span>&#123;</span><br><span class="line">    CharsetEncoder encoder = ENCODER_FACTORY.get();</span><br><span class="line">    <span class="keyword">if</span> (replace) &#123;</span><br><span class="line">      encoder.onMalformedInput(CodingErrorAction.REPLACE);</span><br><span class="line">      encoder.onUnmappableCharacter(CodingErrorAction.REPLACE);</span><br><span class="line">    &#125;</span><br><span class="line">    ByteBuffer bytes =</span><br><span class="line">      encoder.encode(CharBuffer.wrap(string.toCharArray()));</span><br><span class="line">    <span class="keyword">if</span> (replace) &#123;</span><br><span class="line">      encoder.onMalformedInput(CodingErrorAction.REPORT);</span><br><span class="line">      encoder.onUnmappableCharacter(CodingErrorAction.REPORT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>decode：将byte array使用UTF-8编码成字符串String,如果replace参数为true，那么难看的输入将会被替换的字母U+FFFD代替，否则抛出一个MalformedInputException</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">decode</span><span class="params">(ByteBuffer utf8, <span class="keyword">boolean</span> replace)</span></span><br><span class="line">  <span class="keyword">throws</span> CharacterCodingException </span>&#123;</span><br><span class="line">  CharsetDecoder decoder = DECODER_FACTORY.get();</span><br><span class="line">  <span class="keyword">if</span> (replace) &#123;</span><br><span class="line">    decoder.onMalformedInput(</span><br><span class="line">        java.nio.charset.CodingErrorAction.REPLACE);</span><br><span class="line">    decoder.onUnmappableCharacter(CodingErrorAction.REPLACE);</span><br><span class="line">  &#125;</span><br><span class="line">  String str = decoder.decode(utf8).toString();</span><br><span class="line">  <span class="comment">// set decoder back to its default value: REPORT</span></span><br><span class="line">  <span class="keyword">if</span> (replace) &#123;</span><br><span class="line">    decoder.onMalformedInput(CodingErrorAction.REPORT);</span><br><span class="line">    decoder.onUnmappableCharacter(CodingErrorAction.REPORT);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>readString：从输入流中读取UTF8 编码的String，附加最大尺寸</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readString</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> readString(in, Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readString</span><span class="params">(DataInput in, <span class="keyword">int</span> maxLength)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> length = WritableUtils.readVIntInRange(in, <span class="number">0</span>, maxLength);</span><br><span class="line">  <span class="keyword">byte</span> [] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">  in.readFully(bytes, <span class="number">0</span>, length);</span><br><span class="line">  <span class="keyword">return</span> decode(bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ObjectWritable"><a href="#ObjectWritable" class="headerlink" title="ObjectWritable"></a>ObjectWritable</h2><p>针对Java基本类型、字符串、枚举、Writable、空值、Writable的其他子类，ObjectWritable提供了一个封装，适用于字段需要使用多种类型。ObjectWritable可用于Hadoop的远程调用中参数的序列化和反序列化。ObjectWritable的另一个典型应用是在需要序列化不同类型的对象到某一个字段，如在一个SequenceFile的值保存不同类型的对象时，可以将该值声明为ObjectWritable。</p>
<p>ObjectWritable包含三个成员变量：被封装的对象实例instance、该对象运行时类的class对象declaredClass、Configuration对象conf。</p>
<p>ObjectWritable的write方法调用的是静态方法ObjectWritable.writeObject(),该方法可以向DataOutput接口中写入各种Java对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    readObject(in, <span class="keyword">this</span>, <span class="keyword">this</span>.conf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    writeObject(out, instance, declaredClass, conf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(DataOutput out, Object instance,</span><br><span class="line">                                 Class declaredClass,</span><br><span class="line">                                 Configuration conf)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    writeObject(out, instance, declaredClass, conf, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(DataOutput out, Object instance,</span><br><span class="line">        Class declaredClass, Configuration conf, <span class="keyword">boolean</span> allowCompactArrays)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                       <span class="comment">// null</span></span><br><span class="line">      instance = <span class="keyword">new</span> NullInstance(declaredClass, conf);</span><br><span class="line">      declaredClass = Writable.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Special case: must come before writing out the declaredClass.</span></span><br><span class="line">    <span class="comment">// If this is an eligible array of primitives,</span></span><br><span class="line">    <span class="comment">// wrap it in an ArrayPrimitiveWritable$Internal wrapper class.</span></span><br><span class="line">    <span class="keyword">if</span> (allowCompactArrays &amp;&amp; declaredClass.isArray()</span><br><span class="line">        &amp;&amp; instance.getClass().getName().equals(declaredClass.getName())</span><br><span class="line">        &amp;&amp; instance.getClass().getComponentType().isPrimitive()) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> ArrayPrimitiveWritable.Internal(instance);</span><br><span class="line">      declaredClass = ArrayPrimitiveWritable.Internal.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写出declaredClass的规范名</span></span><br><span class="line">    UTF8.writeString(out, declaredClass.getName()); <span class="comment">// always write declared</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (declaredClass.isArray()) &#123;     <span class="comment">// non-primitive or non-compact array</span></span><br><span class="line">      <span class="keyword">int</span> length = Array.getLength(instance);</span><br><span class="line">      out.writeInt(length);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        writeObject(out, Array.get(instance, i),</span><br><span class="line">            declaredClass.getComponentType(), conf, allowCompactArrays);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (declaredClass == ArrayPrimitiveWritable.Internal.class) &#123;</span><br><span class="line">      ((ArrayPrimitiveWritable.Internal) instance).write(out);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (declaredClass == String.class) &#123;   <span class="comment">// String</span></span><br><span class="line">      UTF8.writeString(out, (String)instance);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (declaredClass.isPrimitive()) &#123;     <span class="comment">// primitive type</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (declaredClass == Boolean.TYPE) &#123;        <span class="comment">// boolean</span></span><br><span class="line">        out.writeBoolean(((Boolean)instance).booleanValue());</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (declaredClass == Character.TYPE) &#123; <span class="comment">// char</span></span><br><span class="line">        out.writeChar(((Character)instance).charValue());</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (declaredClass == Byte.TYPE) &#123;    <span class="comment">// byte</span></span><br><span class="line">        out.writeByte(((Byte)instance).byteValue());</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (declaredClass == Short.TYPE) &#123;   <span class="comment">// short</span></span><br><span class="line">        out.writeShort(((Short)instance).shortValue());</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (declaredClass == Integer.TYPE) &#123; <span class="comment">// int</span></span><br><span class="line">        out.writeInt(((Integer)instance).intValue());</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (declaredClass == Long.TYPE) &#123;    <span class="comment">// long</span></span><br><span class="line">        out.writeLong(((Long)instance).longValue());</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (declaredClass == Float.TYPE) &#123;   <span class="comment">// float</span></span><br><span class="line">        out.writeFloat(((Float)instance).floatValue());</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (declaredClass == Double.TYPE) &#123;  <span class="comment">// double</span></span><br><span class="line">        out.writeDouble(((Double)instance).doubleValue());</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (declaredClass == Void.TYPE) &#123;    <span class="comment">// void</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Not a primitive: "</span>+declaredClass);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (declaredClass.isEnum()) &#123;         <span class="comment">// enum</span></span><br><span class="line">      UTF8.writeString(out, ((Enum)instance).name());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Writable.class.isAssignableFrom(declaredClass)) &#123; <span class="comment">// Writable</span></span><br><span class="line">      UTF8.writeString(out, instance.getClass().getName());</span><br><span class="line">      ((Writable)instance).write(out);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Message.class.isAssignableFrom(declaredClass)) &#123;</span><br><span class="line">      ((Message)instance).writeDelimitedTo(</span><br><span class="line">          DataOutputOutputStream.constructOutputStream(out));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Can't write: "</span>+instance+<span class="string">" as "</span>+declaredClass);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">readObject</span><span class="params">(DataInput in, Configuration conf)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readObject(in, <span class="keyword">null</span>, conf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">readObject</span><span class="params">(DataInput in, ObjectWritable objectWritable, Configuration conf)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String className = UTF8.readString(in);</span><br><span class="line">    Class&lt;?&gt; declaredClass = PRIMITIVE_NAMES.get(className);</span><br><span class="line">    <span class="keyword">if</span> (declaredClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">      declaredClass = loadClass(conf, className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object instance;</span><br><span class="line"></span><br><span class="line">    Writable writable = WritableFactories.newInstance(instanceClass, conf);</span><br><span class="line">    writable.readFields(in);</span><br><span class="line">    instance = writable;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>writeObject()方法首先输出对象的类名(通过对象对应的Class对象的getName()方法获得)，然后根据传入对象的模型，分情况序列化对象到输出流中。在ObjectWritable.writeObject()的逻辑中，需要分别处理null、Java数组、字符串、Java基本类型、枚举和Writable的子类6种情况，由于类的继承，处理Writable时，序列化的结果包含对象类名，对象实际类名和对象序列化结果三部分。</p>
<p>需要对象实际类名：根据Java的单根继承规则，ObjectWritable中传入的declaredClass，可以是传入instance对象对应的类的对象，也可以是instance对象的父类的类对象。但是在序列化和反序列化时，往往不能使用父类的序列化方法(如write方法)来序列化子类对象，所以在序列化结果重必须记住对象的实际类名。</p>
<p>和输出对应，ObjectWritable的readFields()方法调用的是静态方法ObjectWritable.readObject(),该方法的实现和writeObject()类似，但其依赖于WritableFactories类。WritableFactories类允许非公有的Writable子类定义一个对象工厂，有该工厂创建Writable对象，如在上面的readObject()代码中，通过WritableFactories的静态方法newInstance()，可以创建类型为instanceClass的Writable子对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存了类型和WritableFactory工厂的对应关系</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class, WritableFactory&gt; CLASS_TO_FACTORY =</span><br><span class="line">    <span class="keyword">new</span> ConcurrentHashMap&lt;Class, WritableFactory&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setFactory</span><span class="params">(Class c, WritableFactory factory)</span> </span>&#123;</span><br><span class="line">    CLASS_TO_FACTORY.put(c, factory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WritableFactory <span class="title">getFactory</span><span class="params">(Class c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CLASS_TO_FACTORY.get(c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Writable <span class="title">newInstance</span><span class="params">(Class&lt;? extends Writable&gt; c, Configuration conf)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据输入类型查找对应的工厂对象</span></span><br><span class="line">    WritableFactory factory = WritableFactories.getFactory(c);</span><br><span class="line">    <span class="keyword">if</span> (factory != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Writable result = factory.newInstance();</span><br><span class="line">      <span class="comment">// 如果该对象是可配置的，newInstance会通过对象的setConf()方法配置对象</span></span><br><span class="line">      <span class="keyword">if</span> (result <span class="keyword">instanceof</span> Configurable) &#123;</span><br><span class="line">        ((Configurable) result).setConf(conf);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 采用传统的反射工具ReflectionUtils创建对象</span></span><br><span class="line">      <span class="keyword">return</span> ReflectionUtils.newInstance(c, conf);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一个定义的工厂创建一个类的新实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Writable <span class="title">newInstance</span><span class="params">(Class&lt;? extends Writable&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> newInstance(c, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>WritableFactories提供注册机制，使得这些Writable的子类可以将该工厂登记到WritableFactories的静态成员变量CLASS_TO_FACTORY中。</p>
<h2 id="GenericWritable"><a href="#GenericWritable" class="headerlink" title="GenericWritable"></a>GenericWritable</h2><p>ObjectWritable作为一种通用机制，相当浪费资源，它需要为每一个输出写入封装类型的名字，如果类型的数量不是很多，而且可以事先知道，则可以使用一个静态类型数组来提高效率，并使用数组索引作为类型的序列化引用。为此，引入了GenericWritable。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericWritable</span> <span class="keyword">implements</span> <span class="title">Writable</span>, <span class="title">Configurable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> NOT_SET = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span> type = NOT_SET;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Writable instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Configuration conf = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Set the instance that is wrapped.</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> obj</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Writable obj)</span> </span>&#123;</span><br><span class="line">    instance = obj;</span><br><span class="line">    Class&lt;? extends Writable&gt; instanceClazz = instance.getClass();</span><br><span class="line">    Class&lt;? extends Writable&gt;[] clazzes = getTypes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clazzes.length; i++) &#123;</span><br><span class="line">      Class&lt;? extends Writable&gt; clazz = clazzes[i];</span><br><span class="line">      <span class="keyword">if</span> (clazz.equals(instanceClazz)) &#123;</span><br><span class="line">        type = (<span class="keyword">byte</span>) i;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"The type of instance is: "</span></span><br><span class="line">                               + instance.getClass() + <span class="string">", which is NOT registered."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Return the wrapped instance.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Writable <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"GW["</span> + (instance != <span class="keyword">null</span> ? (<span class="string">"class="</span> + instance.getClass().getName() +</span><br><span class="line">        <span class="string">",value="</span> + instance.toString()) : <span class="string">"(null)"</span>) + <span class="string">"]"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    type = in.readByte();</span><br><span class="line">    Class&lt;? extends Writable&gt; clazz = getTypes()[type &amp; <span class="number">0xff</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      instance = ReflectionUtils.newInstance(clazz, conf);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Cannot initialize the class: "</span> + clazz);</span><br><span class="line">    &#125;</span><br><span class="line">    instance.readFields(in);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == NOT_SET || instance == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"The GenericWritable has NOT been set correctly. type="</span></span><br><span class="line">                            + type + <span class="string">", instance="</span> + instance);</span><br><span class="line">    out.writeByte(type);</span><br><span class="line">    instance.write(out);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Return all classes that may be wrapped.  Subclasses should implement this</span><br><span class="line">   * to return a constant array of classes.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">protected</span> Class&lt;? extends Writable&gt;[] getTypes();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Configuration <span class="title">getConf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> conf;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConf</span><span class="params">(Configuration conf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.conf = conf;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当两个具有相同类型的key但是值类型不同的sequence file在map阶段结束到reduce阶段时，多种类型的值类型是不被允许的。在这种情况下，这个类能够帮助你包装不同类型的实例。</p>
<p>和ObjectWritable相比，这个类效率更加高，因为ObjectWritable会在每一个Key-Value键值对中追加类声明到输出文件中。</p>
<ul>
<li><p>使用GenericWritable类的一般方法</p>
<ul>
<li>写自定义的class，例如GenericObject，它继承自GenericWritable</li>
<li>实现抽象方法 getTypes(),定义在应用中在GenericObject里将要包装的类。注意：在getTypes()方法里定义的类必须实现Writable接口。</li>
</ul>
</li>
</ul>
<p>一个简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericObject</span> <span class="keyword">extends</span> <span class="title">GenericWritable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Class[] CLASSES = &#123;</span><br><span class="line">               ClassType1.class,</span><br><span class="line">               ClassType2.class,</span><br><span class="line">               ClassType3.class,</span><br><span class="line">               &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span> Class[] getTypes() &#123;</span><br><span class="line">       <span class="keyword">return</span> CLASSES;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop源码学习(6)——Writable(1)]]></title>
      <url>http://keyunluo.github.io/2016/08/09/2016-08-09-hadoop-io-2.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>Writable是Hadoop的核心，Hadoop通过它定义了Hadoop中基本的数据类型及其操作，它是实现序列化的基础，本节学习其中的Writable接口和Java基础类型包装。</p>
</blockquote>
<a id="more"></a>
<h2 id="Writable接口"><a href="#Writable接口" class="headerlink" title="Writable接口"></a>Writable接口</h2><p>Writable接口作为所有可序列化对象必须实现的接口，定义了如下接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Writable</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 输出序列化对象到流中.</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> out DataOuput 流，序列化的结果保存在流中.</span><br><span class="line">   * <span class="doctag">@throws</span> IOException</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput out)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 从流中读取反序列化对象</span><br><span class="line">   * 为了效率，请尽可能复用现有对象</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> in DataInput流，从该流中读取数据.</span><br><span class="line">   * <span class="doctag">@throws</span> IOException</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Writable.write()方法用于将对象状态写入二进制的DataOutput中，反序列化的过程由readFields()从DataInput流中读取状态完成。</p>
<h2 id="WritableComparable和RawComparator"><a href="#WritableComparable和RawComparator" class="headerlink" title="WritableComparable和RawComparator"></a>WritableComparable和RawComparator</h2><h3 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h3><ul>
<li>WritableComparable : 它提供了类型比较的能力</li>
<li>WritableComparator : WritableComparator是WritableComparable的比较器，它是RawComparator针对WritableComparator类的一个通用实现。首先，提供了一个RawComparator的compare()默认实现，该实现从数据流中反序列化要比较的对象，然后调用对象的compare()方法进行比较；其次，它充当了RawComparator实例的一个工厂方法，例如，可以通过如下代码获得IntWritable的RawComparator：<code>RawComparator&lt;IntWritable&gt; comparator = WritableComparator.get(IntWritable.class)</code></li>
<li>RawComparator ： 允许执行者比较流中读取的未被序列化为对象的记录，从而省去了创建对象的开销</li>
</ul>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="/resource/blog/2016-08/Comparator.png" alt="Comparator"></p>
<p>Hadoop将很多Writable类归入org.apache.hadoop.io包中，在这些类中比较重要的有Java基本类型类、Text、Writable集合、ObjectWritable等。</p>
<h2 id="Java基本类型的Writable封装"><a href="#Java基本类型的Writable封装" class="headerlink" title="Java基本类型的Writable封装"></a>Java基本类型的Writable封装</h2><h3 id="Java基本类型封装对照"><a href="#Java基本类型封装对照" class="headerlink" title="Java基本类型封装对照"></a>Java基本类型封装对照</h3><table>
<thead>
<tr>
<th style="text-align:left">Java基本类型</th>
<th style="text-align:left">Writable</th>
<th style="text-align:left">序列化后长度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">布尔型(boolean)</td>
<td style="text-align:left">BooleanWritable</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">字节型(byte)</td>
<td style="text-align:left">ByteWritable</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">整型(int)</td>
<td style="text-align:left">IntWritable/VIntWritable</td>
<td style="text-align:left">4/1~5</td>
</tr>
<tr>
<td style="text-align:left">浮点型(float)</td>
<td style="text-align:left">FloatWritable</td>
<td style="text-align:left">4</td>
</tr>
<tr>
<td style="text-align:left">长整型long()</td>
<td style="text-align:left">LongWritable/VLongWritable</td>
<td style="text-align:left">8/1~9</td>
</tr>
<tr>
<td style="text-align:left">双精度浮点型(double)</td>
<td style="text-align:left">DoubleWritable</td>
<td style="text-align:left">8</td>
</tr>
</tbody>
</table>
<p>对整型(int、long)进行编码的时候,有固定长度格式(IntWritable、LongWritable)和可变长度格式(VIntWritable、VLongWritable)两种选择。固定长度格式的整型序列化后的数据是定长的，而可变长度格式对于数值比较小的整型往往比较节省空间。同时，由于VIntWritable和VLongWritable的编码规则一致，所以VIntWritable的输出可以用VLongWritable读入。</p>
<h3 id="Writable的基本类封装"><a href="#Writable的基本类封装" class="headerlink" title="Writable的基本类封装"></a>Writable的基本类封装</h3><p>下面以VIntWritable为例，了解其封装。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VIntWritable</span> <span class="keyword">implements</span> <span class="title">WritableComparable</span>&lt;<span class="title">VIntWritable</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">VIntWritable</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">VIntWritable</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; set(value); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 设置VIntWritable的值 */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; <span class="keyword">this</span>.value = value; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 获取VIntWritable的值*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现writable里面的接口readFields和write方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    value = WritableUtils.readVInt(in);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    WritableUtils.writeVInt(out, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 判断VIntWritable的值是否相等*/</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> VIntWritable))</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    VIntWritable other = (VIntWritable)o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value == other.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 比较两个VIntWritables. */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(VIntWritable o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thisValue = <span class="keyword">this</span>.value;</span><br><span class="line">    <span class="keyword">int</span> thatValue = o.value;</span><br><span class="line">    <span class="keyword">return</span> (thisValue &lt; thatValue ? -<span class="number">1</span> : (thisValue == thatValue ? <span class="number">0</span> : <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.toString(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>VIntWritable通过调用VWritable工具类中提供的readVInt()和writeVInt()来读写数据，方法readVInt()和writeVInt()只是简单调用了readVLong()和writeVLong()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeVLong</span><span class="params">(DataOutput stream, <span class="keyword">long</span> i)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    处于[-<span class="number">112</span>,<span class="number">127</span>]的整数，直接写入</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= -<span class="number">112</span> &amp;&amp; i &lt;= <span class="number">127</span>) &#123;</span><br><span class="line">      stream.writeByte((<span class="keyword">byte</span>)i);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算情况2的第一个字节</span></span><br><span class="line">    <span class="keyword">int</span> len = -<span class="number">112</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      i ^= -<span class="number">1L</span>; <span class="comment">// take one's complement'</span></span><br><span class="line">      len = -<span class="number">120</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> tmp = i;</span><br><span class="line">    <span class="keyword">while</span> (tmp != <span class="number">0</span>) &#123;</span><br><span class="line">      tmp = tmp &gt;&gt; <span class="number">8</span>;</span><br><span class="line">      len--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stream.writeByte((<span class="keyword">byte</span>)len);</span><br><span class="line"></span><br><span class="line">    len = (len &lt; -<span class="number">120</span>) ? -(len + <span class="number">120</span>) : -(len + <span class="number">112</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出后续字节</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> idx = len; idx != <span class="number">0</span>; idx--) &#123;</span><br><span class="line">      <span class="keyword">int</span> shiftbits = (idx - <span class="number">1</span>) * <span class="number">8</span>;</span><br><span class="line">      <span class="keyword">long</span> mask = <span class="number">0xFFL</span> &lt;&lt; shiftbits;</span><br><span class="line">      stream.writeByte((<span class="keyword">byte</span>)((i &amp; mask) &gt;&gt; shiftbits));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>writeVLong()方法实现了对整型数值的变长编码，它的编码规则如下：</p>
<p>如果输入的整数大于会等于-112并且小于或等于127，那么编码需要1字节，否则，序列化结果的第一个字节，保存了输入整数的符号和后续编码的字节数。符号和后续字节数依据下面的编码规则：</p>
<ul>
<li>如果是正数，则编码值范围落在-113和-120之间(闭区间)，后续字节数可以通过-(v+112)计算</li>
<li>如果是负数，则编码值范围落在-121和-128之间(闭区间)，后续字节数可以通过-(v+120)计算</li>
</ul>
<p>后续编码将高位在前，写入输入的整数(除去前面的全0字节)</p>
<h2 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h2><p>Text类型是针对UTF-8序列的Writable类，一般可认为它等价于java.lang.String的Writable。Text替代了UTF8类,但这并不是一个很好的替代，一者因为不支持对字节数超过32767的字符串进行编码，二者因为它使用的是Java的UTF-8修订版。</p>
<p>Text类使用整型(通过边长编码的方式)来存储字符串编码中所需要的字节数，因此该最大值为2GB。另外Text使用标准的UTF-8编码，这使得能够更加简便的与其他理解UTF-8编码的工具进行交互操作。</p>
<p>Text类型与String类型的主要差别如下：</p>
<ul>
<li>String的长度定义为String包含的字符个数；Text的长度定义为UTF-8编码的字节数</li>
<li>String类的indexOf()方法返回的是char类型字符的索引，比如字符串”1234”,字符3的位置是2；而Text的find()方法返回的是字节偏移量。</li>
<li>String的CharAt()方法返回的是指定位置的char字符，而Text的charAT()方法需要指定偏移量</li>
</ul>
<p>另外，在Text类中定义了一个方法toString(),它用于将Text类型转换成String类型。</p>
<h2 id="BytesWritable"><a href="#BytesWritable" class="headerlink" title="BytesWritable"></a>BytesWritable</h2><p>它是一个二进制数据数组的封装，其序列化格式为一个指定锁包含数据字节的整数域(4字节)，后跟数据内容本身。例如，长度为2的字节数组包含数值3和5，序列化形成为一个4字节的整数(00000002)和该数组中的两个字节(03和05)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BytesWritable b = <span class="keyword">new</span> BytesWritable( <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123;<span class="number">3</span>,<span class="number">5</span>&#125;);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = serialize(b);</span><br><span class="line">assertThat(StringUtils.byteToHexString(bytes),is(<span class="string">"000000020305"</span>));</span><br></pre></td></tr></table></figure>
<p>BytesWritable是可变的，其值可以通过set()方法进行修改。和Text相似，BytesWritable类的getBytes()方法返回的字节数组长度——容量可能无法体现BytesWritable所存储数据的实际大小。可以通过getLength()方法来确定BytesWritable的大小。</p>
<h2 id="NullWritable"><a href="#NullWritable" class="headerlink" title="NullWritable"></a>NullWritable</h2><p>这是一个占位符，它的序列化长度为零，没有数值从流中读出或者是写入流中。这个类型不可以与其他类型比较，在MapReduce中，如果不需要使用键或值的序列化地址，就可以将键或值声明为NullWritable，结果是高效的存储常量空值。如果希望存储一系列数值，与键/值对相对，NullWritable也可以用作在SequenceFile中的键，它是一个不可变的单实例类型，通过调用NullWritable.get()方法可以获取这个实例。</p>
<h2 id="ObjectWritable和GenericWritable"><a href="#ObjectWritable和GenericWritable" class="headerlink" title="ObjectWritable和GenericWritable"></a>ObjectWritable和GenericWritable</h2><p>ObjectWritable是对Java基本类型(String,enum,Writable,null或这些类型组成的数组)的一个通用封装，它在Hadoop RPC中用于对方法的参数和返回类型进行封装和解封装。</p>
<p>当一个字段中包含多个类型时，ObjectWritable非常有用：例如，如果SequenceFile中的值包含多个类型，就可以将值类型声明为ObjectWritable，并将每个类型封装在一个ObjectWritable中。作为一个通用的机制，每次序列化都写封装类型的名称将非常浪费空间。如果封装的类型数量比较少并且能够提前知道，那么可以通过使用静态类型的数组，并使用对序列化后的类型的引用加入位置索引来提高性能。GenericWritable类采取的就是这种方式，所以你得在继承的子类中指定支持什么类型。</p>
<h2 id="Writable集合类"><a href="#Writable集合类" class="headerlink" title="Writable集合类"></a>Writable集合类</h2><p>org.apache.hadoop.io软件包中一共有6隔Writable集合类：ArrayWritable、ArrayPrimitiveWritable、TwoDArrayWritable、MapWritable、SortedMapWritable和EnumMapWritable。</p>
<p>ArrayWritable和TwoDArrayWritable是对Writable的数组和二维数组的实现。ArrayWritable或TwoDArrayWritable中的所有元素必须是同一类的实例(在构造函数中指定)：<code>ArrayWritable writable = new ArrayWritable(Text.class)</code>
如果Writable根据类型来定义，例如SequenceFile的键或值，或更多时候作为MapReduce的输入，则需要继承ArrayWritable(或相应的TwoDArrayWritable类)并设置静态类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextArrayWritable</span> <span class="keyword">extends</span> <span class="title">ArrayWritable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextArrayWritable</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(Text.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayWritable和TwoDArrayWritable都有get()、set()和toArray()方法。toArray()方法用于新建该数组(或二维数组)的一个“浅拷贝”。</p>
<p>ArrayPrimitiveWritable是对Java基本数组类型的一个封装。调用set()方法时，可以识别相应组件类型，因此无需通过继承该类来设置类型。</p>
<p>MapWritable和SortedMapWritable分别实现了java.util.Map<writable,writable>和java.util.SortedMap<writablecomparator,writable>。每个键值对字段使用的类型是相应字段序列化形式的一部分。类型存储为单个字节(充当类型数组的索引)。在org.apache.hadoop.io包中，数组经常与标准类型结合使用，而定制的Writable类型也通常结合使用，但对于非标准类型，则需要在包头指明所使用的数组类型。根据实现，MapWritable类和SortedMapWritable类通过正byte值来指示定制的类型，所以在MapWritable和SortedMapWritable实例中最多可使用127隔不同的非标准Writable类。下面显示使用了不同键和值类型的MapWritable实例：</writablecomparator,writable></writable,writable></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MapWritable src = <span class="keyword">new</span> MapWritable();</span><br><span class="line">src.put(<span class="keyword">new</span> IntWritable(<span class="number">1</span>),<span class="keyword">new</span> Text(<span class="string">"cat"</span>));</span><br><span class="line">src.put(<span class="keyword">new</span> VIntWritable(<span class="number">2</span>),<span class="keyword">new</span> LongWritable(<span class="number">163</span>));</span><br><span class="line"></span><br><span class="line">MapWritable dest = <span class="keyword">new</span>  MapWritable();</span><br><span class="line">WritableUtils.cloneInto(dest , src);</span><br><span class="line">assertThat((Text) dest.get(<span class="keyword">new</span> IntWritable(<span class="number">1</span>)),is(<span class="keyword">new</span> Text(<span class="string">"cat"</span>)));</span><br><span class="line">assertThat((LongWritable) dest.get(<span class="keyword">new</span> VIntWritable(<span class="number">2</span>)),is(<span class="keyword">new</span> LongWritable(<span class="number">163</span>)));</span><br></pre></td></tr></table></figure>
<p>显然，可以通过Writable集合类来实现集合和列表。可以使用MapWritable类型(或针对排序集合，使用SortedMapWritable)来枚举集合中的元素，用NullWritable类型枚举值。对集合的枚举类型可采用EnumSetWritable。对于单类型的Writable列表，使用ArrayWritable就足够了，但如果需要把不同的Writable类型存储在单个列表中，可以用GenericWritable将元素封装在一个ArrayWritable中。另一个可选方案是借鉴MapWritable的思路写一个通用的ListWritable。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中的NIO2]]></title>
      <url>http://keyunluo.github.io/2016/08/08/2016-08-08-java-nio2.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>Java7对原有的NIO进行了重大改进，提供了全面的文件IO和文件系统的访问支持，基于异步Channel的IO。</p>
</blockquote>
<a id="more"></a>
<h2 id="Path、Paths和Files核心API"><a href="#Path、Paths和Files核心API" class="headerlink" title="Path、Paths和Files核心API"></a>Path、Paths和Files核心API</h2><p>早起的JAVA只提供了一个File类来访问文件系统，功能有限并且性能低下。NIO.2引入了一个Path接口，Path接口代表一个平台无关的平台路径，此外，NIO.2还提供了Files和Paths两个工具类，其中Files包含了大量的静态的工具方法来操作文件，Paths则包含了两个返回Path的静态工厂方法。</p>
<h3 id="Path接口的功能和用法"><a href="#Path接口的功能和用法" class="headerlink" title="Path接口的功能和用法"></a>Path接口的功能和用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioPath</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 以当前路径来创建Path对象</span></span><br><span class="line">        Path path = Paths.get(<span class="string">"/home/streamer/tmp/NioPath.java"</span>);</span><br><span class="line">        System.out.println(<span class="string">"path里包含的路径数量:"</span>+path.getNameCount());</span><br><span class="line">        System.out.println(<span class="string">"path的根路径:"</span>+path.getRoot());</span><br><span class="line">        <span class="comment">// 获取path对应的绝对路径</span></span><br><span class="line">        Path absolutePath = path.toAbsolutePath();</span><br><span class="line">        System.out.println(<span class="string">"path的绝对路径:"</span>+absolutePath);</span><br><span class="line">        <span class="comment">// 获取绝对路径的根路径</span></span><br><span class="line">        System.out.println(<span class="string">"绝对路径的根路径:"</span>+absolutePath.getRoot());</span><br><span class="line">        <span class="comment">// 获取绝对路径所包含的路径数量</span></span><br><span class="line">        System.out.println(<span class="string">"绝对路径包含的路径数量:"</span>+absolutePath.getNameCount());</span><br><span class="line">        System.out.println(<span class="string">"绝对路径第三层路径:"</span>+absolutePath.getName(<span class="number">3</span>));</span><br><span class="line">        <span class="comment">// 以多个String来构建Path对象</span></span><br><span class="line">        Path path2= Paths.get(<span class="string">"/usr"</span>,<span class="string">"local"</span>,<span class="string">"anaconda3"</span>);</span><br><span class="line">        System.out.println(<span class="string">"构建的PATH:"</span>+path2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示的如下结果：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">path里包含的路径数量:<span class="number">4</span></span><br><span class="line">path的根路径:/</span><br><span class="line">path的绝对路径:/home/streamer/tmp/NioPath.java</span><br><span class="line">绝对路径的根路径:/</span><br><span class="line">绝对路径包含的路径数量:<span class="number">4</span></span><br><span class="line">绝对路径第三层路径:NioPath.java</span><br><span class="line">构建的PATH:/usr/local/anaconda3</span><br></pre></td></tr></table></figure></p>
<h3 id="Files类的用法"><a href="#Files类的用法" class="headerlink" title="Files类的用法"></a>Files类的用法</h3><p>Files是一个操作文件的工具类，它提供了大量便捷的工具方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.FileStore;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioFile</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 复制文件</span></span><br><span class="line">        Files.copy(Paths.get(<span class="string">"NioFile.java"</span>),<span class="keyword">new</span> FileOutputStream(<span class="string">"NioFile.txt"</span>));</span><br><span class="line">        <span class="comment">// 判断NioFile.java是否为隐藏文件</span></span><br><span class="line">        System.out.println(<span class="string">"NioFile.java是否为隐藏文件:"</span>+Files.isHidden(Paths.get(<span class="string">"NioFile.java"</span>)));</span><br><span class="line">        <span class="comment">// 一次性读取NioFile.java文件的所有行</span></span><br><span class="line">        List&lt;String&gt; lines = Files.readAllLines(Paths.get(<span class="string">"NioFile.java"</span>),Charset.forName(<span class="string">"UTF-8"</span>));</span><br><span class="line">        System.out.println(lines);</span><br><span class="line">        <span class="comment">// 判断指定文件的大小</span></span><br><span class="line">        System.out.println(<span class="string">"NioFile.java文件的大小："</span>+Files.size(Paths.get(<span class="string">"NioFile.java"</span>)));</span><br><span class="line">        <span class="comment">// 直接将多个字符串写入到指定文件中</span></span><br><span class="line">        List&lt;String&gt; poem = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        poem.add(<span class="string">"水晶潭底银鱼跃"</span>);</span><br><span class="line">        poem.add(<span class="string">"清徐风中碧竿横"</span>);</span><br><span class="line">        Files.write(Paths.get(<span class="string">"poem.txt"</span>),poem,Charset.forName(<span class="string">"gbk"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Java8新增的Stream API列出当前目录下所有文件和子目录</span></span><br><span class="line">        Files.list(Paths.get(<span class="string">"."</span>)).forEach(path -&gt; System.out.println(path));</span><br><span class="line">        <span class="comment">// 使用Java8新增的Stream API读取文件内容</span></span><br><span class="line">        Files.lines(Paths.get(<span class="string">"poem.txt"</span>),Charset.forName(<span class="string">"gbk"</span>)).forEach(line -&gt; System.out.println(line));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断/data的总空间、可用空间</span></span><br><span class="line">        FileStore cStore = Files.getFileStore(Paths.get(<span class="string">"/data/"</span>));</span><br><span class="line">        System.out.println(<span class="string">"/data:共有空间："</span>+cStore.getTotalSpace());</span><br><span class="line">        System.out.println(<span class="string">"/data:可用空间："</span>+cStore.getUsableSpace());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用FileVisitor遍历文件和目录"><a href="#使用FileVisitor遍历文件和目录" class="headerlink" title="使用FileVisitor遍历文件和目录"></a>使用FileVisitor遍历文件和目录</h2><p>Files类提供了如下两个方法来遍历文件和子目录：</p>
<ul>
<li>walkFileTree(Path start,FileVisitor&lt;? super Path&gt; visitor):遍历start目录下的所有文件和子目录</li>
<li>walkFileTree(Path start,Set<filevisitoption> options,int maxDepth,FileVisitor&lt;? super Path&gt; visitor):与上一个方法类似，该方法最多遍历maxDepth深度的文件</filevisitoption></li>
</ul>
<p>上面两个方法都需要FileVisitor参数，FileVisitor代表一个文件访问器，walkFileTree()方法会自动遍历start路径下的所有文件和子目录，遍历文件和子目录都会触发FileVisitor中的相应方法。FileVisitor中定义了如下四种方法：</p>
<ul>
<li>FileVisitResult postVisitDirectory(T dir,IOException exc):访问子目录之后触发该方法</li>
<li>FileVisitResult preVisitDirectory(T dir,BasicFileAttributes attrs):访问子目录之前触发该方法</li>
<li>FileVisitResult visitFile(T dir,BasicFileAttributes attrs):访问file文件时触发该方法</li>
<li>FileVisitResult visitFileFailed(T dir,IOException exc):访问file文件失败时触发该方法</li>
</ul>
<p>上面4个方法都返回一个FileVisitResult对象，它是一个枚举类，代表访问之后的后续行为，FileVisitResult定义了如下几种后续行为：</p>
<ul>
<li>CONTINUE:代表”继续访问”的后续行为</li>
<li>SKIP_SIBLINGS:代表”继续访问”的后续行为,但不访问该文件或目录的兄弟文件或目录</li>
<li>SKIP_SUBTREE:代表”继续访问”的后续行为,但不访问该文件或目录的子目录树</li>
<li>TERMINATE:代表”终止访问”的后续行为</li>
</ul>
<p>实际编程时没必要为FileVisitor的四个方法都提供实现，可以通过继承SimpleFileVisitor(FileVisitor的实现类)来实现自己的”文件访问器”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.FileVisitor;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.SimpleFileVisitor;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.FileVisitResult;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.BasicFileAttributes;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioFileVisitor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 遍历/usr/local/anaconda3/include 目录下的所有文件和子目录</span></span><br><span class="line">        Files.walkFileTree(Paths.get(<span class="string">"/usr"</span>,<span class="string">"local"</span>,<span class="string">"anaconda3"</span>,<span class="string">"include"</span>), <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">            <span class="comment">// 访问文件时触发该方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"正在访问："</span>+file+<span class="string">"文件"</span>);</span><br><span class="line">                <span class="comment">// 找到了Python.h文件</span></span><br><span class="line">                <span class="keyword">if</span> (file.endsWith(<span class="string">"Python.h"</span>))&#123;</span><br><span class="line">                    System.out.println(<span class="string">"--已经找到目标文件--"</span>);</span><br><span class="line">                    <span class="keyword">return</span> FileVisitResult.TERMINATE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始访问目录时触发该方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">preVisitDirectory</span><span class="params">(Path dir,BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"正在访问:"</span>+dir+<span class="string">"路径"</span>);</span><br><span class="line">                <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用WatchService监控文件变化"><a href="#使用WatchService监控文件变化" class="headerlink" title="使用WatchService监控文件变化"></a>使用WatchService监控文件变化</h2><p>NIO.2的Path类提供了如下方法来监听文件系统的变化：</p>
<ul>
<li>register(WatchService watcher,WatchEvent.Kind&lt;?&gt; … events):用watcher监听该path代表的目录下的文件变化，events参数指定要监听哪些类型的事件。</li>
</ul>
<p>一旦使用register()方法完成注册后，接下来就可以调用WatchService的如下三个方法来获取被监听目录的文件变化事件。</p>
<ul>
<li>WatchKey poll():获取下一个WatchKey，如果没有WatchKey发生就立即返回null</li>
<li>WatchKey poll(long timeout,TimeUnit unit):尝试等待timeout时间去获取下一个WatchKey</li>
<li>WatchKey take():获取下一个WatchKey，如果没有WatchKey发生就一直等待</li>
</ul>
<p>如果程序需要一直监控，则应该选择使用take()方法；如果程序只需要监控指定时间，择可以考虑使用poll方法，下面的程序使用WatchService来监控/data根目录下文件的变化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.WatchKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.WatchEvent;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.WatchService;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.StandardWatchEventKinds;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.FileSystems;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioWatchService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 获取文件系统的WatchService对象</span></span><br><span class="line">        WatchService watchService = FileSystems.getDefault().newWatchService();</span><br><span class="line">        <span class="comment">// 为/data根路径注册监听</span></span><br><span class="line">        Paths.get(<span class="string">"/data/"</span>).register(watchService</span><br><span class="line">                , StandardWatchEventKinds.ENTRY_CREATE</span><br><span class="line">                , StandardWatchEventKinds.ENTRY_MODIFY</span><br><span class="line">                , StandardWatchEventKinds.ENTRY_DELETE);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 获取下一个文件变化事件</span></span><br><span class="line">            WatchKey key = watchService.take();</span><br><span class="line">            <span class="keyword">for</span> (WatchEvent&lt;?&gt; event : key.pollEvents())&#123;</span><br><span class="line">                System.out.println(event.context()+ <span class="string">" 文件发生了 "</span>+ event.kind() +<span class="string">"事件!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重设WatchKey</span></span><br><span class="line">            <span class="keyword">boolean</span> valid = key.reset();</span><br><span class="line">            <span class="comment">// 如果重设失败，退出监听</span></span><br><span class="line">            <span class="keyword">if</span> (!valid) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件:
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  data touch test.txt</span><br><span class="line">➜  data echo <span class="string">"test"</span> &gt;&gt; test.txt</span><br><span class="line">➜  data rm test.txt</span><br></pre></td></tr></table></figure></p>
<p>结果：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test.txt 文件发生了 ENTRY_CREATE事件!</span><br><span class="line">test.txt 文件发生了 ENTRY_MODIFY事件!</span><br><span class="line">test.txt 文件发生了 ENTRY_MODIFY事件!</span><br><span class="line">test.txt 文件发生了 ENTRY_DELETE事件!</span><br></pre></td></tr></table></figure></p>
<h2 id="访问文件属性"><a href="#访问文件属性" class="headerlink" title="访问文件属性"></a>访问文件属性</h2><p>Java7的NIO.2在java.nio.file.attribute包下提供了大量的工具类，通过这些工具类，开发者可以非常简单地读取、修改文件属性，这些工具类主要分为如下两类：</p>
<ul>
<li>XxxAttributeView：代表某种文件属性的视图</li>
<li>XxxAttributes:代表某种文件属性的集合，程序一般通过XxxAttributeView对象来获取XxxAttributes</li>
</ul>
<p>在这些工具类中，FileAttributeView是其他XxxAttributeView的父接口</p>
<table>
<thead>
<tr>
<th style="text-align:left">View</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AclFileAttributeView</td>
<td style="text-align:left">开发者可以为特定文件设置ACL(Access Control List) 及文件所有者属性，它的getAcl()方法返回List<aclentry>对象，该返回值代表了该文件的权限集，通过setAcl(List)方法可以修改该文件的ACL</aclentry></td>
</tr>
<tr>
<td style="text-align:left">BasicFileAttributeView</td>
<td style="text-align:left">它可以获取或修改文件的基本属性，包括文件的最后修改时间、最后访问时间、创建时间、大小、是否为目录、是否为符号链接等，它的readAttribute方法返回一个BasicFileAttribute对象，对文件夹基本属性的修改是通过BasicFileAttribute对象完成的。</td>
</tr>
<tr>
<td style="text-align:left">DosFileAttributeView</td>
<td style="text-align:left">主要用于获取或修改文件DOS相关属性，如文件是否只读、隐藏，是否为系统文件、存档文件等</td>
</tr>
<tr>
<td style="text-align:left">FileOwnerAttributeView</td>
<td style="text-align:left">获取或修改文件的所有者</td>
</tr>
<tr>
<td style="text-align:left">PosixFileAttributeView</td>
<td style="text-align:left">用于获取或修改POSIX属性，它的readAttribute()方法返回一个PosixFileAttribute对象，该对象可用于获取或修改文件的所有者、组所有者和访问权限信息，仅在*nx系统上有用</td>
</tr>
<tr>
<td style="text-align:left">UserDefinedFileAttributeView</td>
<td style="text-align:left">让开发者为文件设置一些自定义属性</td>
</tr>
</tbody>
</table>
<p>下面程序示范了如何读取、修改文件的属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.FileSystems;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.BasicFileAttributeView;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.BasicFileAttributes;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.FileOwnerAttributeView;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.UserPrincipal;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.UserDefinedFileAttributeView;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.PosixFileAttributeView;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.PosixFileAttributes;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioAttributeView</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 获取将要操作的文件</span></span><br><span class="line">        Path path = Paths.get(<span class="string">"NioAttributeView.java"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取访问基本属性的BasicFileAttributeView</span></span><br><span class="line">        BasicFileAttributeView basicView = Files.getFileAttributeView(path,BasicFileAttributeView.class);</span><br><span class="line">        <span class="comment">// 获取访问基本属性的BasicFileAttributes</span></span><br><span class="line">        BasicFileAttributes basicAttr = basicView.readAttributes();</span><br><span class="line">        <span class="comment">// 访问文件的基本属性</span></span><br><span class="line">        System.out.println(<span class="string">"创建时间："</span>+ <span class="keyword">new</span> Date(basicAttr.creationTime().toMillis()));</span><br><span class="line">        System.out.println(<span class="string">"最后访问时间："</span>+ <span class="keyword">new</span> Date(basicAttr.lastAccessTime().toMillis()));</span><br><span class="line">        System.out.println(<span class="string">"最后修改时间："</span>+ <span class="keyword">new</span> Date(basicAttr.lastModifiedTime().toMillis()));</span><br><span class="line">        System.out.println(<span class="string">"文件大小："</span>+ basicAttr.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取访问文件属主属性的FileOwnerAttributeView</span></span><br><span class="line">        FileOwnerAttributeView ownerView = Files.getFileAttributeView(path,FileOwnerAttributeView.class);</span><br><span class="line">        <span class="comment">// 获取该文件所属用户</span></span><br><span class="line">        System.out.println(<span class="string">"所有者："</span>+ ownerView.getOwner());</span><br><span class="line">        <span class="comment">// 获取系统中streamer对应的用户</span></span><br><span class="line">        UserPrincipal user = FileSystems.getDefault().getUserPrincipalLookupService().lookupPrincipalByName(<span class="string">"streamer"</span>);</span><br><span class="line">        <span class="comment">// 修改用户</span></span><br><span class="line">        ownerView.setOwner(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取访问自定义属性的FileOwnerAttributeView</span></span><br><span class="line">        UserDefinedFileAttributeView userView = Files.getFileAttributeView(path,UserDefinedFileAttributeView.class);</span><br><span class="line">        <span class="comment">// 添加一个自定义属性</span></span><br><span class="line">        userView.write(<span class="string">"发行版"</span>,Charset.defaultCharset().encode(<span class="string">"streamer"</span>));</span><br><span class="line">        userView.write(<span class="string">"编辑器"</span>,Charset.defaultCharset().encode(<span class="string">"vim/gedit"</span>));</span><br><span class="line">        List&lt;String&gt; attrNames = userView.list();</span><br><span class="line">        <span class="comment">// 遍历所有的自定义属性</span></span><br><span class="line">        <span class="keyword">for</span> (String name : attrNames)&#123;</span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(userView.size(name));</span><br><span class="line">        userView.read(name,buf);</span><br><span class="line">        buf.flip();</span><br><span class="line">        String value = Charset.defaultCharset().decode(buf).toString();</span><br><span class="line">        System.out.println(name + <span class="string">"-----&gt;"</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取访问Posix属性的PosixFileAttributeView</span></span><br><span class="line">        PosixFileAttributeView posixView = Files.getFileAttributeView(path,PosixFileAttributeView.class);</span><br><span class="line">        <span class="comment">// 获取访问基本属性的PosixFileAttributes</span></span><br><span class="line">        PosixFileAttributes posixAttr = posixView.readAttributes();</span><br><span class="line">        <span class="comment">// 访问文件的基本属性</span></span><br><span class="line">        System.out.println(<span class="string">"创建者："</span>+ posixAttr.owner().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  tmp sudo chown root:root NioAttributeView.java</span><br><span class="line">➜  tmp sudo chmod 777 NioAttributeView.java</span><br><span class="line">➜  tmp javac NioAttributeView.java</span><br><span class="line">➜  tmp sudo java NioAttributeView</span><br><span class="line">创建时间：Mon Aug 08 18:14:40 UTC 2016</span><br><span class="line">最后访问时间：Mon Aug 08 18:15:04 UTC 2016</span><br><span class="line">最后修改时间：Mon Aug 08 18:14:40 UTC 2016</span><br><span class="line">文件大小：3211</span><br><span class="line">所有者：root</span><br><span class="line">发行版-----&gt;streamer</span><br><span class="line">编辑器-----&gt;vim/gedit</span><br><span class="line">创建者：streamer</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中的NIO块]]></title>
      <url>http://keyunluo.github.io/2016/08/08/2016-08-08-java-nio.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>Java中的IO的输入流和输出流都是阻塞式的，如果没有读到有效数据则程序会在此处阻塞该线程的执行，并且，传统的输入流、输出流都是通过字节的移动来处理的，通常效率不高，新的IO(NIO)从JDK1.4版本开始，新增了许多用于处理输入/输出的类。</p>
</blockquote>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>新IO采用内存映射文件的方式来处理输入/输出，新IO将文件或文件的一段区域映射到内存中，这样就可以像访问内存一样访问文件，速度要快的多。</p>
<p>Java中与新IO相关的包如下：</p>
<ul>
<li>java.nio包：包含了各种与Buffer相关的类</li>
<li>java.nio.channels包：主要包含了与Channel和Selector相关的类</li>
<li>java.nio.charset包：主要包含与字符集相关的类</li>
<li>java.nio.channels.spi包：主要包含与Channel相关的服务提供者编程接口</li>
<li>java.nio.charset.spi包：主要包含与字符集相关的服务提供者编程接口</li>
</ul>
<p>Channel(通道)和Buffer(缓冲)是新IO中的两个核心对象，Channel是对传统的输入输出系统的模拟，在新IO中，所有的数据都要通过通道传输，与传统的输入输出流相比，主要在于它提供了一个map()方法，通过该map()方法可以将”一块数据”映射到内存中。</p>
<p>Buffer可以被理解为一个容器，它的本质是一个数组，发送到Channel中的所有对象都必须首先放在Buffer中，Buffer可以到Channel中取数据，也允许使用Channel直接将文件的某块数据映射成Buffer。</p>
<p>除了Channel和Buffer之外，新IO还提供了用于将Unicode字符串映射成字节序列以及逆映射操作的Charset类，也提供了用于支持费非阻塞式输入输出的Selector类。</p>
<h2 id="使用Buffer"><a href="#使用Buffer" class="headerlink" title="使用Buffer"></a>使用Buffer</h2><p>Buffer可以保存多个类型相同的数据，它是一个抽象类，最常用的子类是ByteBuffer，其他基本类型Boolean除外，都有相应的Buffer类：CharBuffer、ShortBuffer、IntBuffer、FloatBuffer、DoubleBuffer。</p>
<p>比较常用的是ByteBuffer和CharBuffer，通过<code>static XxxBuffer allocate(int capacity)</code>创建一个容量为capacity的XxxBuffer对象。其中ByteBuffer类还有一个子类：MappedByteBuffer，它哟关于表示Channel将磁盘文件的部分或全部内容映射到内存中后得到的结果，通常MappedByteBuffer对象由Channel的map()方法返回。</p>
<p>Buffer中有三个重要的概念：容量(capacity)、界限(limit)和位置(position):</p>
<ul>
<li>容量：该Buffer的最大数据容量，创建后不能更改</li>
<li>界限：第一个不能被读写的缓冲区位置索引</li>
<li>位置：下一个可以被读出或者写入的缓冲区的位置索引</li>
</ul>
<p>除此之外，Buffer里还支持一个可选的标记mark，Buffer允许直接将position定位到该mark处，这些值满足如下大小关系：<code>0=&lt;mark=&lt;position=&lt;limit=&lt;capacity</code>.</p>
<p>Buffer的主要作用就是装入数据(put)，然后输出数据(get)，几个重要的方法：</p>
<ul>
<li>flip():将limit设置为position所在位置，并将position设为0，为输出数据做准备</li>
<li>clear():将position置为0，将limit置为capacity，为装入数据做准备</li>
</ul>
<h2 id="使用Channel"><a href="#使用Channel" class="headerlink" title="使用Channel"></a>使用Channel</h2><p>Channel类似于传统的流对象，但有两个显著的差别：</p>
<ul>
<li>Channel可以直接将指定文件的部分或全部直接映射成Buffer</li>
<li>程序不能直接访问Channel中数据，Channel只能与Buffer进行交互</li>
</ul>
<p>Java为Channel接口提供了DatagramChannel(UDP网络通信)、FileChannel、Pipe.SinkChannel(线程间通信管道)、Pipe.SourceChannel、SelectableChannel、ServerSocketChannel(TCP网络通信)、SocketChannel等实现类。</p>
<p>所有的Channel都不应该通过构造器直接创建，而是通过传统的节点InputStream、outputStream的getChannel()方法来返回对应的Channel。</p>
<p>Channel中最常见的三类方法是map()、read()、write()。map()方法的方法签名为：<code>MappedByteBuffer map(FileChannel.MapMode mode,long position,long size)</code>,第一个参数执行映射的模式：只读、读写，而第二个、第三个参数用于控制将Channel的哪些数据映射成ByteBuffer。</p>
<h3 id="例子1-Channel读写"><a href="#例子1-Channel读写" class="headerlink" title="例子1:Channel读写"></a>例子1:Channel读写</h3><p>直接将FileChannel的全部数据映射成ByteBuffer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.MappedByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.CharBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.CharsetDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannelTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"FileChannelTest.java"</span>);</span><br><span class="line">        <span class="keyword">try</span>(FileChannel inChannel = <span class="keyword">new</span> FileInputStream(file).getChannel();</span><br><span class="line">            FileChannel outChannel = <span class="keyword">new</span> FileOutputStream(<span class="string">"out.txt"</span>).getChannel())&#123;</span><br><span class="line">            <span class="comment">// 将FileChannel里的全部数据映射成ByteBuffer</span></span><br><span class="line">            MappedByteBuffer buffer = inChannel.map(FileChannel.MapMode.READ_ONLY,<span class="number">0</span>,file.length());</span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="comment">// 直接将buffer里面的数据全部取出</span></span><br><span class="line">            outChannel.write(buffer);</span><br><span class="line">            <span class="comment">// 再次调用buffer的clear()方法，复原limit、position的位置</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="comment">// 使用UTF-8的字符集来创建解码器</span></span><br><span class="line">            Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line">            <span class="comment">// 创建解码器(CharsetDecoder)对象</span></span><br><span class="line">            CharsetDecoder decoder = charset.newDecoder();</span><br><span class="line">            <span class="comment">// 使用解码器将ByteBuffer转换成CharBuffer</span></span><br><span class="line">            CharBuffer charBuffer = decoder.decode(buffer);</span><br><span class="line">            <span class="comment">// CharBuffer的toString方法可以获取对应的字符串</span></span><br><span class="line">            System.out.println(charBuffer.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不仅InputStream、OutputStream包含了getChannel()方法，在RandomAccessFile中也包含了该方法，RandomAccessFile返回的FileChannel()是只读的还是读写的，取决于RandomAccessFile打开文件的模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">FileChannel randomChannel = <span class="keyword">new</span> RandomAccessFile(file,<span class="string">"rw"</span>).getChannel();</span><br><span class="line">ByteBuffer buffer = randomChannel.map(FileChannel.MapMode.READ_ONLY,<span class="number">0</span>,file.length());</span><br><span class="line">randomChannel.position(file.length());</span><br><span class="line">randomChannel.write(buffer);</span><br></pre></td></tr></table></figure>
<h3 id="例子2-多次map"><a href="#例子2-多次map" class="headerlink" title="例子2:多次map"></a>例子2:多次map</h3><p>如果channel对应的文件过大，一次性将所有的文件内容映射到内存引起性能下降，可以多次映射</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.CharBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.CharsetDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadFile</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">    <span class="comment">// 创建文件输入流</span></span><br><span class="line">    FileInputStream fin = <span class="keyword">new</span> FileInputStream(<span class="string">"ReadFile.java"</span>);</span><br><span class="line">    <span class="comment">// 创建一个FileChannel</span></span><br><span class="line">    FileChannel fch = fin.getChannel()</span><br><span class="line">    )&#123;</span><br><span class="line">    <span class="comment">// 定义一个ByteBuffer对象</span></span><br><span class="line">    ByteBuffer bbuf = ByteBuffer.allocate(<span class="number">256</span>);</span><br><span class="line">    <span class="comment">// 将FileChannel中的数据放入ByteBuffer中</span></span><br><span class="line">    <span class="keyword">while</span> (fch.read(bbuf) != -<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 锁定Buffer的空白区</span></span><br><span class="line">    bbuf.flip();</span><br><span class="line">    <span class="comment">// 创建Charset对象</span></span><br><span class="line">    Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line">    <span class="comment">// 创建解码器对象</span></span><br><span class="line">    CharsetDecoder decoder = charset.newDecoder();</span><br><span class="line">    <span class="comment">// 将ByteBuffer的内容转码</span></span><br><span class="line">    CharBuffer cbuf = decoder.decode(bbuf);</span><br><span class="line">    System.out.println(cbuf);</span><br><span class="line">    <span class="comment">// 将Buffer初始化，为下一次读取数据作准备</span></span><br><span class="line">    bbuf.clear();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符集和Charset"><a href="#字符集和Charset" class="headerlink" title="字符集和Charset"></a>字符集和Charset</h2><p>编码：将明文的字符序列转换成计算机中的二进制序列</p>
<p>解码：将二进制序列转换成字符序列</p>
<p>比较常用的字符编码：</p>
<ul>
<li>GBK: 简体中文字符集</li>
<li>BIG5: 繁体中文字符集</li>
<li>ISO-8859-1/ISO-LATIN-1: 拉丁字母表</li>
<li>UTF-8: 8位UCS转换格式</li>
<li>UTF-16BE: 16位UCS转换格式，大端字节(最低位地址存放高位字节)字母顺序</li>
<li>UTF-16LE: 16位UCS转换格式，小端字节(最低位地址存放低位字节)字母顺序</li>
<li>UTF-16: 16位UCS转换格式，字节顺序由可选的字节顺序标记来标识</li>
</ul>
<p>一旦知道了字符集的别名后，程序就可以调用Charset的forName()方法来创建对应的Charset对象，然后通过该对象的newDecoder/newEncoder这两个方法分别返回CharsetDecoder和CharsetEncoder对象，调用CharsetDecoder的decode方法就可以将ByteBuffer转换成CharBuffer，调用CharsetEncoder的encode方法就可以将CharBuffer或String转换成ByteBuffer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Charset cn = Charset.forName(<span class="string">"GBK"</span>);</span><br><span class="line">CharsetEncoder cnEncoder = cn.newEncoder();</span><br><span class="line">CharsetDecoder cnDecoder = cn.newDecoder();</span><br><span class="line"></span><br><span class="line">CharBuffer cbuf = CharBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">cbuf.put(<span class="string">'孙'</span>);</span><br><span class="line">cbuf.put(<span class="string">'悟'</span>);</span><br><span class="line">cbuf.put(<span class="string">'空'</span>);</span><br><span class="line">cbuf.flip();</span><br><span class="line">ByteBuffer bbuf = cnEncoder.encode(cbuf);</span><br><span class="line">System.out.println(cnDecoder.decode(bbuf));</span><br></pre></td></tr></table></figure>
<p>Charset类提供了如下三个方法：</p>
<ul>
<li>CharBuffer decode(ByteBuffer bb): 将ByteBuffer中的字节序列转换成字符序列的便捷方法</li>
<li>ByteBuffer encode(CharBuffer cb):将CharBuffer中的字符序列转换成字节序列的便捷方法</li>
<li>ByteBuffer encode(String str): 将String中的字符序列转换成字节序列的便捷方法</li>
</ul>
<p>在获取了Charset对象后，如果仅仅需要进行简单的编码、解码操作，无需创键CharsetEncoder和CharsetDecoder对象，直接调用Charset的encode()和decode()方法进行编码、解码即可。</p>
<p>String类里面也提供了一个getBytes(String charset)方法，该方法返回byte[],也可以使用指定的字符集将字符串转换成字节序列。</p>
<h2 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h2><p>在NIO中，Java提供了FileLock来支持文件锁定功能，在FileChannel中提供的lock()/tryLock()方法可以获得文件锁FileLock对象，从而锁定文件(排它锁)。lock()尝试锁定文件时，如果无法获得文件锁，程序将抑制阻塞，而tryLock则返回null。</p>
<p>如果FileChannel只想锁定部分内容，择可以使用如下的方法：</p>
<ul>
<li>lock(long position,long size,boolean shared):对文件从position开始，长度为size的内容加锁，该方法是阻塞式的。</li>
<li>tryLock(long position,long size,boolean shared):对文件从position开始，长度为size的内容加锁，该方法是非阻塞式的。</li>
</ul>
<p>当参数shared是true时，表明该锁是一个共享锁，它将允许多个进程来读取该文件，但阻止其他进程获得对该文件的排它锁。当shared为false时，表明该锁是一个排它锁，它将锁住对该文件的读写。程序通过调用FileLock的isShared来判断它获得的锁是否为共享锁。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中的序列化]]></title>
      <url>http://keyunluo.github.io/2016/08/07/2016-08-07-java-serialize.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>对象序列化的目标是将对象保存在磁盘中，或允许网络直接传输对象。对象序列化的机制允许把内存中的java对象转换成平台无关的二进制流，其他程序一旦获取了这种二进制流，则就可以将其恢复成原来的Java对象。</p>
</blockquote>
<a id="more"></a>
<h2 id="序列化的含义和意义"><a href="#序列化的含义和意义" class="headerlink" title="序列化的含义和意义"></a>序列化的含义和意义</h2><p>序列化机制允许将实现序列化的Java对象转换成字节序列，这些字节序列可以保存在磁盘上，或者通过网络传输。</p>
<p>对象的序列化(Serialize)指将一个Java对象写入IO流，于此对应的是，对象的反序列化(Deserialize)则是指从IO流中恢复该Java对象。</p>
<p>为了让某个对象支持序列化机制，该类必须实现如下两个接口之一：</p>
<ul>
<li>Serializable</li>
<li>Externalizable</li>
</ul>
<p>Java的很多类已经实现了Serializable接口，该接口是一个标记接口，实现该接口无须实现任何方法，它只是表明该类的实例是可序列化的。</p>
<p>所有可能在网络上传输的对象的类、所有需要保存到磁盘里的对象的类都必须可序列化。</p>
<h2 id="使用对象流实现序列化"><a href="#使用对象流实现序列化" class="headerlink" title="使用对象流实现序列化"></a>使用对象流实现序列化</h2><p>一旦某个类实现了Serializable接口，该类的对象就是可序列化的：</p>
<ul>
<li>创建一个ObjectOutputStream，这个输出流是一个处理流，所以必须建立在其他节点流的基础之上：<code>ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;object.txt&quot;))</code>;</li>
<li>调用ObjectOutputStream对象的writeObject()方法输出可序列化对象：<code>oos.writeObject(per)</code>;</li>
</ul>
<p>如果希望从二进制流中恢复Java对象，则需要使用反序列化：</p>
<ul>
<li>创建一个ObjectInputStream输入流，必须建立在其他节点流的基础之上：<code>ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;object.txt&quot;));</code></li>
<li>调用ObjectInputStream对象的readObject()方法读取流中的对象，该方法返回一个Object类型的java对象，如果知道该对象的类型，则可以将该对象强制转换成其真实的类型：<code>Person p = (Person)ois.readObject();</code></li>
</ul>
<p>反序列化读取的仅仅是Java对象的数据，而不是Java类，因此采用反序列化恢复Java对象时，必须提供该Java对象所属类的class文件，否则引发ClassNotFoundException异常。</p>
<h2 id="对象引用的序列化"><a href="#对象引用的序列化" class="headerlink" title="对象引用的序列化"></a>对象引用的序列化</h2><p>如果某个类的成员变量的类型不是基本类型或String类型，而是另一个引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型的成员变量的类也是不可序列化的。</p>
<p>为了防止引用对象不一致的情况，Java序列化机制采用了一种特殊的序列化算法：</p>
<ul>
<li>所有保存到磁盘中的对象都有一个序列化编号。</li>
<li>当程序试图序列化一个对象时，程序将先检查该对象是否已经被序列化过，只有该对象从未(在本次虚拟机中)被序列化过，系统才会将该对象转换成字节序列并输出。</li>
<li>如果某个对象已经序列化过，程序将只是直接输出一个序列化编号，而不是再次重新序列化该对象。</li>
</ul>
<p>当然，这种机制也有一种潜在的问题：当程序序列化一个可变对象时，只有第一次使用writeObject()方法输出时才会将该对象转换成字节序列输出，当后面该对象的实例变量值改变后，当程序再次调用writeObject()方法时，也只是输出前面的序列化编号。</p>
<h2 id="自定义序列化1"><a href="#自定义序列化1" class="headerlink" title="自定义序列化1"></a>自定义序列化1</h2><p>在一些特殊的场景下，如果一个类里面包含的某些实例变量是敏感信息，这时不希望将该实例变量进行序列化，或者某个实力变量的类型是不可序列化的，因此不希望对该变量进行递归序列化，以免引发java.io.NotSerializableException异常。</p>
<p>通过在实例变量前面使用transient关键字修饰，可以指定Java序列化时无须理会该实例变量，反序列化是该变量的值为0。方法和静态变量也不会被序列化。</p>
<p>使用transient关键字修饰实例变量虽然简单、方便，但该变量将被完全隔离在序列化机制之外，这样导致在反序列化恢复Java对象时无法取得该实例变量值。Java还提供了一种自定义序列化机制，可以让程序控制如何序列化各实例变量，甚至完全不序列化某些实例变量(与使用transient关键字的效果相同)。</p>
<p>在序列化和反序列化过程中需要特殊处理的类应该提供如下特殊签名的方法，这些特殊的方法可以实现自定义序列化：</p>
<ul>
<li>private void writeObject(java.io.ObjectOutputStream out) throws IOException</li>
<li>private void readObject(java.io.ObjectInputStream in) throws IOException,ClassNotFoundException;</li>
<li>private void readObjectNoData() throws ObjectStreamException;</li>
</ul>
<p>当序列化流不完整时，readObjectNoData()方法可以用来正确地初始化反序列化的对象。</p>
<ul>
<li>例子</li>
</ul>
<p>Person类提供了writeObject()和readObject()两个方法，其中writeObject()方法在保存Person对象时将其name实例变量包装成StringBuffer，并将其字符序列反转后写入；在readObject()方法中处理name的策略与此对应——先将读取的数据强制转换成StringBuffer，再将其反转后赋给name实例变量。</p>
<p>还有一种更加彻底的自定义机制，它甚至可以在序列化对象时将该对象替换成其它对象，使用特殊方法：<code>writeReplace</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 注意：此处没有提供无参数的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name , <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"有参数的构造器"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age  = age ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> name;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> age;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123; <span class="keyword">this</span>.name = name;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;<span class="keyword">this</span>.age  = age ;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        out.writeObject(<span class="keyword">new</span> StringBuffer(name).reverse());</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = ((StringBuffer)in.readObject()).reverse().toString();</span><br><span class="line">        <span class="keyword">this</span>.age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonReplace</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 注意：此处没有提供无参数的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonReplace</span><span class="params">(String name , <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"有参数的构造器"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age  = age ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> name;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> age;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123; <span class="keyword">this</span>.name = name;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;<span class="keyword">this</span>.age  = age ;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">writeReplace</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">        ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">        list.add(name);</span><br><span class="line">        list.add(age);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializePerson</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==测试自定义序列化=="</span>);</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            <span class="comment">// 创建一个ObjectOutputStream输出值</span></span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"serialize.txt"</span>));</span><br><span class="line">            <span class="comment">// 创建一个ObjectInputStream输入流</span></span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"serialize.txt"</span>)))&#123;</span><br><span class="line">            Person per = <span class="keyword">new</span> Person(<span class="string">"孙悟空"</span>,<span class="number">500</span>);</span><br><span class="line">            oos.writeObject(per);</span><br><span class="line">            Person p = (Person)ois.readObject();</span><br><span class="line">            System.out.println(<span class="string">"姓名:"</span>+p.getName()+<span class="string">",年龄:"</span>+p.getAge());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)&#123;ex.printStackTrace();&#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"============"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"==测试writeReplace序列化=="</span>);</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            <span class="comment">// 创建一个ObjectOutputStream输出值</span></span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"serialize-replace.txt"</span>));</span><br><span class="line">            <span class="comment">// 创建一个ObjectInputStream输入流</span></span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"serialize-replace.txt"</span>)))&#123;</span><br><span class="line">            PersonReplace per = <span class="keyword">new</span> PersonReplace(<span class="string">"孙悟空"</span>,<span class="number">500</span>);</span><br><span class="line">            oos.writeObject(per);</span><br><span class="line">            <span class="comment">// 反序列化读取ArrayList</span></span><br><span class="line">            ArrayList list = (ArrayList)ois.readObject();</span><br><span class="line">            System.out.println(<span class="string">"姓名:"</span>+list.get(<span class="number">0</span>)+<span class="string">",年龄:"</span>+list.get(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)&#123;ex.printStackTrace();&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与writeReplace()方法相对，序列化机制里还有一个特殊的方法，它可以实现保护性复制整个对象：<code>readResolve()</code>,这个方法会紧接着readObject()之后被调用，该方法的返回值将替代原来的反序列化的对象，而原来的readObject()反序列化的对象将会被立即丢弃。</p>
<h2 id="自定义序列化2"><a href="#自定义序列化2" class="headerlink" title="自定义序列化2"></a>自定义序列化2</h2><p>Java还提供了另一种序列化机制：Externalizable，这种序列化机制完全由程序员决定存储和恢复对象数据。该接口定义了如下两个方法：</p>
<ul>
<li>void readExternal(ObjectInput in):需要序列化的类实现readExternal()方法来实现反序列化。该方法调用DataInput(它是ObjectInput的父接口)的方法来恢复基本类型的实例变量值，调用ObjectInput的readObject()方法来恢复引用类型的实例变量值。</li>
<li>void writeExternal(ObjectOutput out):需要序列化的类实现writeExternal()方法来实现序列化。该方法调用DataOutput(它是ObjectOutput的父接口)的方法来保存基本类型的实例变量值，调用ObjectOutput的writeObject()方法来保存引用类型的实例变量值。</li>
</ul>
<p>Externalizable的接口强制自定义序列化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Externalizable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"有参数的构造器"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age  = age ;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">// 将name实例变量值反转后写入二进制流</span></span><br><span class="line">        out.writeObject(<span class="keyword">new</span> StringBuffer(name).reverse());</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        <span class="comment">// 将读取的字符串反转后赋给name实例变量</span></span><br><span class="line">        <span class="keyword">this</span>.name = ((StringBuffer)in.readObject()).reverse().toString();</span><br><span class="line">        <span class="keyword">this</span>.age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果程序需要序列化实现Externalizable接口的对象，一样调用ObjectOutputStream的writeObject()方法输出该对象即可；反序列化该对象，则调用ObjectInputStream的readObject()方法。</p>
<h2 id="版本兼容性"><a href="#版本兼容性" class="headerlink" title="版本兼容性"></a>版本兼容性</h2><p>Java序列化机制允许为序列化的类提供一个private static final的serialVersionUID值，该类变量的值用于标识该Java类的序列化版本，如果一个类升级后，它的serialVersionUID类变量值保持不变，序列化机制也会把它们当成同一个序列化版本。</p>
<p>分配serialVersionUID:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="comment">//为该类指定一个serialVersionUID类变量值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">512L</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，即使在某个对象被序列化后，它所对应的类被修改了，该对象也依然可以被正确的反序列化。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中的IO流(2)]]></title>
      <url>http://keyunluo.github.io/2016/08/07/2016-08-07-java-io-2.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>本节学习输入输出重定向，Java虚拟机读取进程数据以及随机访问文件等IO内容。</p>
</blockquote>
<a id="more"></a>
<h2 id="重定向标准输入-输出"><a href="#重定向标准输入-输出" class="headerlink" title="重定向标准输入/输出"></a>重定向标准输入/输出</h2><p>Java的标准输入输出分别通过System.in和System.out代表，在默认情况下它们分表代表键盘和显示器，在System类里提供了如下三个重定向标准输入输出的方法：</p>
<ul>
<li>static void setErr(PrintStream err): 重定向”标准”错误输出流</li>
<li>static void setIn(InputStream in):重定向”标准”输入流</li>
<li>static void setOut(PrintStream out):重定向”标准”输出流</li>
</ul>
<p>简单的输出输入重定向：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出重定向</span></span><br><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"out.txt"</span>));</span><br><span class="line">System.setOut(ps)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入重定向</span></span><br><span class="line">FileInputStream fin = <span class="keyword">new</span> FileInputStream(<span class="string">"RedirectIn.java"</span>);</span><br><span class="line">System.setIn(fin)</span><br></pre></td></tr></table></figure>
<h2 id="Java虚拟机读取其他进程数据"><a href="#Java虚拟机读取其他进程数据" class="headerlink" title="Java虚拟机读取其他进程数据"></a>Java虚拟机读取其他进程数据</h2><p>Java使用Runtime对象的exec()方法可以运行平台上的其他程序，该方法产生一个Process对象，Process对象代表由该Java程序启动的子进程，Process类提供了如下三个方法，用于让程序和其子进程进行通信：</p>
<ul>
<li>InputStream getErrorStream（）：获取子进程的错误流</li>
<li>InputStream getInputStream():获取子进程的输入流</li>
<li>OutputStream getOutputStream():获取子进程的输出流</li>
</ul>
<p>此处的输入流和输出流是相对于Java程序而言的，如果是试图让子进程读取程序中的数据，则是输出流。</p>
<h3 id="输入流例子："><a href="#输入流例子：" class="headerlink" title="输入流例子："></a>输入流例子：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadFromProcess</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">//运行javac命令，返回运行该命令的子进程</span></span><br><span class="line">        Process p = Runtime.getRuntime().exec(<span class="string">"javac"</span>);</span><br><span class="line">        <span class="keyword">try</span>(<span class="comment">// 以p进程的错误流创建BufferedReader对象</span></span><br><span class="line">            <span class="comment">// 这个错误流对本程序是输入流，对p进程则是输出流</span></span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(p.getErrorStream())))&#123;</span><br><span class="line">            String buff = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 采用循环方式来读取p进程的错误输出</span></span><br><span class="line">            <span class="keyword">while</span> ((buff = br.readLine()) != <span class="keyword">null</span>) System.out.println(buff);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果将输出javac命令的提示。</p>
<h3 id="输出流例子"><a href="#输出流例子" class="headerlink" title="输出流例子"></a>输出流例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteToProcess</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">// 运行java ReadStandard命令，返回运行该命令的子进程</span></span><br><span class="line">        Process p = Runtime.getRuntime().exec(<span class="string">"java ReadStandard"</span>);</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            <span class="comment">// 以进程p的输出流创建PrintStream对象</span></span><br><span class="line">            <span class="comment">// 这个输出流对本程序是输出流，对p进程则是输入流</span></span><br><span class="line">            PrintStream ps = <span class="keyword">new</span> PrintStream(p.getOutputStream()))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 向ReadStandard程序写入内容，这些内容将被ReadStandard读取</span></span><br><span class="line">                ps.println(<span class="string">"普通字符串"</span>);</span><br><span class="line">                ps.println(<span class="keyword">new</span> WriteToProcess());</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个ReadStandard类，该类可以接收标准输入</span></span><br><span class="line"><span class="comment">// 并将标准输入写入out.txt</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadStandard</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            <span class="comment">// 使用System.in创建Scanner对象，用于获取标准输入</span></span><br><span class="line">            Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            PrintStream ps = <span class="keyword">new</span> PrintStream(</span><br><span class="line">            <span class="keyword">new</span> FileOutputStream(<span class="string">"out.txt"</span>)))&#123;</span><br><span class="line">            <span class="comment">// 增加下面一行只把回车作为分隔符</span></span><br><span class="line">             sc.useDelimiter(<span class="string">"\n"</span>);</span><br><span class="line">            <span class="comment">// 判断是否还有下一个输入项</span></span><br><span class="line">            <span class="keyword">while</span>(sc.hasNext()) ps.println(<span class="string">"键盘的输入内容是："</span>+sc.next());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由WriteToProcess类运行ReadStandard类。</p>
<h2 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h2><p>RandomAccessFile提供了众多的方法来访问文件内容，它既可以读取文件内容，也可以向文件中输出内容，并且支持“随机访问”的方式，程序可以直接跳转到任意位置读写数据。如果程序需要向已存在的文件后面追加内容，则应该使用RandomAccessFile。</p>
<p>RandomAccessFile包含了如下两个方法来操作文件记录指针：</p>
<ul>
<li>long getFilePointer():返回文件记录指针的当前位置</li>
<li>void seek(long pos):将文件记录指针定位到pos位置</li>
</ul>
<p>RandomAccessFile的构造器第一个参数是文件名，第二个参数是指定RandomAccessFile的访问模式：</p>
<ul>
<li>“r”:以只读的方式打开指定文件，如果尝试写入，则抛出IOException异常。</li>
<li>“rw”:以读、写方式打开指定文件，如果文件尚不存在，则尝试创建该文件。</li>
<li>“rws”:以读、写方式打开指定文件，相对于”rw”模式，还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备。</li>
<li>“rwd”:以读、写方式打开指定文件，相对于”rw”模式，还要求对文件内容的每个更新都同步写入到底层存储设备。</li>
</ul>
<h3 id="例子：插入内容"><a href="#例子：插入内容" class="headerlink" title="例子：插入内容"></a>例子：插入内容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertContent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String fileName, <span class="keyword">long</span> pos , String insertContent)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        File tmp = File.createTempFile(<span class="string">"tmp"</span>,<span class="keyword">null</span>);</span><br><span class="line">        tmp.deleteOnExit();</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(fileName,<span class="string">"rw"</span>);</span><br><span class="line">            <span class="comment">// 使用临时文件来保存插入点后的数据</span></span><br><span class="line">            FileOutputStream tmpOut = <span class="keyword">new</span> FileOutputStream(tmp);</span><br><span class="line">            FileInputStream tmpIn = <span class="keyword">new</span> FileInputStream(tmp))&#123;</span><br><span class="line">            raf.seek(pos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面的代码将插入点后的内容读入临时文件中保存</span></span><br><span class="line">            <span class="keyword">byte</span>[] bbuf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span>];</span><br><span class="line">            <span class="comment">// 用于保存实际读取的字节数</span></span><br><span class="line">            <span class="keyword">int</span> hasRead =<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((hasRead = raf.read(bbuf)) &gt; <span class="number">0</span>) tmpOut.write(bbuf,<span class="number">0</span>,hasRead);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面代码用于插入内容</span></span><br><span class="line">            <span class="comment">//把文件记录指针重新定位到pos位置</span></span><br><span class="line">            raf.seek(pos);</span><br><span class="line">            <span class="comment">// 追加需要插入的内容</span></span><br><span class="line">            raf.write(insertContent.getBytes());</span><br><span class="line">            <span class="comment">//追加临时文件中的内容</span></span><br><span class="line">            <span class="keyword">while</span> ((hasRead = tmpIn.read(bbuf)) &gt; <span class="number">0</span>) raf.write(bbuf,<span class="number">0</span>,hasRead);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        insert(<span class="string">"InsertContent.java"</span>,<span class="number">50</span>,<span class="string">"\n/*新插入的内容!*/\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中使用File的CreateTempFile(String prefix,String suffix)方法创建一个临时文件，用以保存被插入文件的插入点后面的内容。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中的IO流(1)]]></title>
      <url>http://keyunluo.github.io/2016/08/06/2016-08-06-java-io-1.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>Java中的IO流是实现输入输出的基础，在Java中把不同的输入/输出源(键盘、文件、网络连接等)抽象表述为“流(stream)”,通过流的方式Java可以使用相同的方式来访问不同的输入/输出源。stream是从起源(source)到接受(sink)的有序数据。</p>
</blockquote>
<a id="more"></a>
<h2 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h2><ol>
<li><p>输入流和输出流 (按流的流向来分)</p>
<p> 输入流：InputStream和Reader作为基类</p>
<p> 输出流：OutputStream和Writer作为基类</p>
</li>
<li><p>字节流和字符流 (操作的数据大小)</p>
<p> 字节流：8位字节，由InputStream和OutputStream作为基类</p>
<p> 字符流：16位字符，主要由Reader和Writer作为基类</p>
</li>
<li><p>节点流和处理流 (流的角色)</p>
<p> 节点流：可以从/向一个特定的IO设备(磁盘、网络)读写数据的流，也被称为低级流</p>
<p> 处理流：对一个已经存在的流进行连接或封装，通过封装后的流来实现数据的读写功能，也被称为高级流</p>
</li>
<li><p>处理流的功能</p>
<ul>
<li>性能的提高：以增加缓冲的方式来提高输入/输出的效率</li>
<li>操作的便捷：一次性输入/输出大批量的内容</li>
<li>屏蔽了设备无关性：代码书写更加简洁</li>
</ul>
</li>
</ol>
<h2 id="InputStream和Reader"><a href="#InputStream和Reader" class="headerlink" title="InputStream和Reader"></a>InputStream和Reader</h2><p>InputStream和Reader是所有输入流的抽象基类,本身不能创建实例，但它们分别有一个用于读取文件的输入流:FileInputStream和FileReader，它们都是节点流——会和指定文件关联。</p>
<ul>
<li><p>InputStream
主要包含下面三个方法：</p>
<ul>
<li><strong>int read()</strong>:从输入流中读取单个字节，返回所读取的字节数据(字节数据可以直接转换成int类型)</li>
<li><strong>int read(byte[] b)</strong>:从输入流中最多读取b.length个字节的数据，并将其存储在字节数组b中，返回实际读取的字节数</li>
<li><strong>int read(byte[] b,int off ,int len)</strong>:从输入流中最多读取len个字节的数据，并将其存储在数组b中，放入数组b中时，并不是从数组起点开始，而是从off位置开始，返回实际读取的字节数</li>
</ul>
</li>
<li><p>Reader
主要包含下面三个方法：</p>
<ul>
<li><strong>int read()</strong>:从输入流中读取单个字符，返回所读取的字符数据(字符数据可以直接转换成int类型)</li>
<li><strong>int read(char[] cbuf)</strong>:从输入流中最多读取cbuf.length个字符的数据，并将其存储在字符数组cbuf中，返回实际读取的字符数</li>
<li><strong>int read(char[] cbuf,int off ,int len)</strong>:从输入流中最多读取len个字符的数据，并将其存储在字符数组cbuf中，放入数组cbuf中时，并不是从数组起点开始，而是从off位置开始，返回实际读取的字符数</li>
</ul>
</li>
<li><p>一个简单的例子-FileInputStream：读取源文件本身</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInput</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">// 创建字节输入流</span></span><br><span class="line">        FileInputStream fin = <span class="keyword">new</span> FileInputStream(<span class="string">"FileInput.java"</span>);</span><br><span class="line">        <span class="comment">// 创建一个长度为1024的缓冲</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 用于保存实际读取的字节数</span></span><br><span class="line">        <span class="keyword">int</span> hasRead = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 使用循环来重复读取</span></span><br><span class="line">        <span class="keyword">while</span> ((hasRead = fin.read(buf)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 读取字节，将字节数组转换成字符串输入</span></span><br><span class="line">            System.out.print(<span class="keyword">new</span> String(buf,<span class="number">0</span>,hasRead));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭文件输入流，放在finally块里面更加安全</span></span><br><span class="line">        fin.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序最后使用了fin.close()来关闭该文件输入流，与JDBC编程一样，程序打开的文件IO资源不属于内存里的资源，垃圾回收机制无法回收该资源。Java7改写了所有的IO资源类，它们都实现了AutoCloseable接口，因此都可以通过自动关闭资源的try语句来关闭这些IO流。</p>
<ul>
<li>一个简单的例子-FileReader：读取源文件本身</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReaderInput</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 创建字符输入流</span></span><br><span class="line">        FileReader fre = <span class="keyword">new</span> FileReader(<span class="string">"FileReaderInput.java"</span>);</span><br><span class="line">        <span class="comment">// 创建一个长度为32的缓冲</span></span><br><span class="line">        <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="comment">// 用于保存实际读取的字符数</span></span><br><span class="line">        <span class="keyword">int</span> hasRead = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 使用循环来重复读取</span></span><br><span class="line">        <span class="keyword">while</span> ((hasRead = fre.read(buf)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 读取字符，将字符数组转换成字符串输入</span></span><br><span class="line">            System.out.print(<span class="keyword">new</span> String(buf,<span class="number">0</span>,hasRead));</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>输入流移动记录指针</p>
<ul>
<li>void mark(int readAheadLimit):在记录指针当前位置记录一个标记(mark)</li>
<li>boolean markSupported():判断此输入流是否支持mark()操作</li>
<li>void reset():将此流的记录指针重新定位到上一次记录标记(mark)的位置</li>
<li>long skip(long n):记录指针向前移动n个字节/字符</li>
</ul>
</li>
</ul>
<h2 id="OutputStream和Writer"><a href="#OutputStream和Writer" class="headerlink" title="OutputStream和Writer"></a>OutputStream和Writer</h2><h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><p>OutputStream和Writer也非常类似，两个流都提供了如下三个方法：</p>
<ul>
<li>void write(int c):将指定的字节/字符输出到输出流中，其中c既可以表示字节，也可以表示字符</li>
<li>void write(byte[]/char[] buf):将字节数组/字符数组中的数据输出到指定输出流中</li>
<li>void write(byte[]/char[] buf,int off,int len):将字节数组/字符数组从off位置开始，长度为len的字节/字符输出到输出流中</li>
</ul>
<p>因为字符流直接以字符作为操作单位，所以Writer可以用字符串来代替字符数组，即以String对象作为参数，Writer里还包含如下两个方法：</p>
<ul>
<li>void write(String str):将str字符串里包含的字符输出到指定输出流中</li>
<li>void write(String str,int off,int len):将str字符串里从off位置开始，长度为len的字符输出到指定输出流中</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>从FileInputStream输入，使用FileOutputStream输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputOutput</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 创建字节输入流</span></span><br><span class="line">        FileInputStream fin = <span class="keyword">new</span> FileInputStream(<span class="string">"FileInputOutput.java"</span>);</span><br><span class="line">        <span class="comment">// 创建字符输出流</span></span><br><span class="line">        FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(<span class="string">"FileInputOutput-new.txt"</span>);</span><br><span class="line">        <span class="comment">// 创建一个长度为32的缓冲</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="comment">// 用于保存实际读取的字符数</span></span><br><span class="line">        <span class="keyword">int</span> hasRead = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 使用循环来重复读取</span></span><br><span class="line">        <span class="keyword">while</span> ((hasRead = fin.read(buf)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 读取字符，将字符数组转换成字符串输入</span></span><br><span class="line">            fout.write(buf,<span class="number">0</span>,hasRead);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h2><p>使用处理流的典型思路是，使用处理流来包装节点流，程序通过处理流来执行输入/输出功能，让节点流与底层的IO设备交互。</p>
<p>例如，使用PrintStream处理流来包装OutputStream，使用处理流后在输出时更加方便：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintStreamTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(<span class="string">"test.txt"</span>);</span><br><span class="line">            PrintStream ps = <span class="keyword">new</span> PrintStream(fout))&#123;</span><br><span class="line">            <span class="comment">// 使用PrintStream执行输出</span></span><br><span class="line">            ps.println(<span class="string">"普通字符串"</span>);</span><br><span class="line">            <span class="comment">// 直接使用PrintStream输出对象</span></span><br><span class="line">            ps.println(<span class="keyword">new</span> PrintStreamTest());</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输入-输出流体系"><a href="#输入-输出流体系" class="headerlink" title="输入/输出流体系"></a>输入/输出流体系</h2><p>Java的输入/输出流体系提供了将近40个类，这些类的常用分类如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">字节输入流</th>
<th style="text-align:left">字节输出流</th>
<th style="text-align:left">字符输入流</th>
<th style="text-align:left">字符输出流</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">节点流抽象基类</td>
<td style="text-align:left">InputStream</td>
<td style="text-align:left">OutputStream</td>
<td style="text-align:left">Reader</td>
<td style="text-align:left">Writer</td>
</tr>
<tr>
<td style="text-align:left">访问文件</td>
<td style="text-align:left">FileInputStream</td>
<td style="text-align:left">FileOutputStream</td>
<td style="text-align:left">FileReader</td>
<td style="text-align:left">FileWriter</td>
</tr>
<tr>
<td style="text-align:left">访问数组</td>
<td style="text-align:left">ByteArrayInputStream</td>
<td style="text-align:left">ByteArrayOutputStream</td>
<td style="text-align:left">CharArrayReader</td>
<td style="text-align:left">CharArrayWriter</td>
</tr>
<tr>
<td style="text-align:left">访问管道</td>
<td style="text-align:left">PipedInputStream</td>
<td style="text-align:left">PipedOutputStream</td>
<td style="text-align:left">PipedReader</td>
<td style="text-align:left">PipedWriter</td>
</tr>
<tr>
<td style="text-align:left">访问字符串</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">StringReader</td>
<td style="text-align:left">StringWriter</td>
</tr>
<tr>
<td style="text-align:left">缓冲流</td>
<td style="text-align:left">BufferedInputStream</td>
<td style="text-align:left">BufferedOutputStream</td>
<td style="text-align:left">BufferedReader</td>
<td style="text-align:left">BufferedWriter</td>
</tr>
<tr>
<td style="text-align:left">转换流</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">InputStreamReader</td>
<td style="text-align:left">OutputStreamWriter</td>
</tr>
<tr>
<td style="text-align:left">对象流</td>
<td style="text-align:left">ObjectInputStream</td>
<td style="text-align:left">ObjectOutputStream</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">处理流抽象基类</td>
<td style="text-align:left">FilterInputStream</td>
<td style="text-align:left">FilterOutputStream</td>
<td style="text-align:left">FilterReader</td>
<td style="text-align:left">FilterWriter</td>
</tr>
<tr>
<td style="text-align:left">打印流</td>
<td style="text-align:left"></td>
<td style="text-align:left">PrintStream</td>
<td style="text-align:left"></td>
<td style="text-align:left">PrintWriter</td>
</tr>
<tr>
<td style="text-align:left">推回输入流</td>
<td style="text-align:left">PushbackInputStream</td>
<td style="text-align:left"></td>
<td style="text-align:left">PushbackReader</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">特殊流</td>
<td style="text-align:left">DataInputStream</td>
<td style="text-align:left">DataOutputStream</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>转换流实现将字节流转换为字符流，其中InputStreamReader将字节输入流转换成字符输入流，OutputStreamWriter将字节输出流转换成字符输出流。</p>
<p>例子：Java使用System.in代表标准输入，即键盘输入，但这个标准输入流是InputStream类的实例，考虑到键盘输入内容都是文本内容，所以可以使用InputStreamReader将其转换为字符输入流，将普通的Reader包装成BufferedReader，利用BufferedReader的readLine()方法可以一次读取一行内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIn</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            <span class="comment">// 将System.in对象转换为Reader对象</span></span><br><span class="line">            InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">            <span class="comment">// 将普通的Reader包装成BufferedReader</span></span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(reader))&#123;</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 采用循环的方式逐行读取</span></span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) !=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 如果读取的是“exit”，则程序退出</span></span><br><span class="line">                <span class="keyword">if</span> (line.equals(<span class="string">"exit"</span>))&#123;</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 打印读取的内容</span></span><br><span class="line">                System.out.println(<span class="string">"输入内容为："</span>+line);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="推回输入流"><a href="#推回输入流" class="headerlink" title="推回输入流"></a>推回输入流</h2><p>在输入/输出流体系中，有两个流与众不同，就是PushbackInputStream和PushbackReader，它们都提供了如下三个方法：</p>
<ul>
<li>void unread(byte[]/char[] buf)：将一个字节/字符数组内容推回到推回缓冲区里面，从而允许重复读取刚刚读取的内容。</li>
<li>void unread(byte[]/char[] buf , int off ,int len):将一个字节/字符数组里从off开始，长度为len字节/字符的内容推回到推回缓冲区里，从而允许重复读取刚刚读取的内容。</li>
<li>void unread(int b):将一个字节/字符内容推回到推回缓冲区里面，从而允许重复读取刚刚读取的内容。</li>
</ul>
<p>当程序差创建一个推回输入流时，需要指定推回缓冲区的大小，默认的推回缓冲区大小是1，如果程序中的退回到退回缓冲区的内容超过了退回缓冲区的大小，将会引发Pushback buffer overflow的IOException异常。</p>
<p>例子：程序试图找出程序中的”new PushbackReader”字符串，当找到该字符串时，程序只打印目标字符串之前的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PushBackStream</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            <span class="comment">// 创键一个PushbackReader对象，指定推回缓冲区的大小为64</span></span><br><span class="line">            PushbackReader pr = <span class="keyword">new</span> PushbackReader(<span class="keyword">new</span> FileReader(<span class="string">"PushBackStream.java"</span>),<span class="number">64</span>))&#123;</span><br><span class="line">            <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">32</span>];</span><br><span class="line">            <span class="comment">// 用以保存上次读取的字符串内容</span></span><br><span class="line">            String lastContent = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">int</span> hasRead = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((hasRead = pr.read(buf)) &gt;<span class="number">0</span>)&#123;</span><br><span class="line">                String content = <span class="keyword">new</span> String(buf,<span class="number">0</span>,hasRead);</span><br><span class="line">                <span class="keyword">int</span> targetIndex = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 将上次读取的字符串和本次读取的字符串拼接起来</span></span><br><span class="line">                <span class="comment">// 查看是否包含目标字符串，如果包含目标字符串</span></span><br><span class="line">                <span class="keyword">if</span> ((targetIndex = (lastContent + content).indexOf(<span class="string">"new PushbackReader"</span>)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 将本次内容和上次内容一起推回缓冲区</span></span><br><span class="line">                    pr.unread((lastContent+content).toCharArray());</span><br><span class="line">                    <span class="comment">// 重新定义一个长度为targetIndex的char数组</span></span><br><span class="line">                    <span class="keyword">if</span> (targetIndex &gt; <span class="number">32</span>) buf = <span class="keyword">new</span> <span class="keyword">char</span>[targetIndex];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//再次读取指定长度的内容(就是目标字符串之前的内容)</span></span><br><span class="line">                    pr.read(buf, <span class="number">0</span> ,targetIndex);</span><br><span class="line">                    <span class="comment">//打印读取的内容</span></span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(buf , <span class="number">0</span> ,targetIndex));</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 打印上次读取的内容</span></span><br><span class="line">                    System.out.println(lastContent);</span><br><span class="line">                    <span class="comment">// 将本次内容设置为上次内容</span></span><br><span class="line">                    lastContent = content;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop源码学习(5)——Hadoop-Common-IO]]></title>
      <url>http://keyunluo.github.io/2016/08/06/2016-08-06-hadoop-io-1.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>本节学习Hadoop-Common-Project中的hadoop-common-io模块，该模块由传统的I/O系统发展而来，但又有些不同，Hadoop需要处理P、T级别的数据，所以在org.apache.hadoop.io包中包含了一些面向海量数据处理的基本输入输出工具，本节主要学习IOUtils类。</p>
</blockquote>
<a id="more"></a>
<h2 id="Hadoop-IO-目录结构"><a href="#Hadoop-IO-目录结构" class="headerlink" title="Hadoop-IO 目录结构"></a>Hadoop-IO 目录结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── AbstractMapWritable.java</span><br><span class="line">├── ArrayFile.java</span><br><span class="line">├── ArrayPrimitiveWritable.java</span><br><span class="line">├── ArrayWritable.java</span><br><span class="line">├── BinaryComparable.java</span><br><span class="line">├── BloomMapFile.java</span><br><span class="line">├── BooleanWritable.java</span><br><span class="line">├── BoundedByteArrayOutputStream.java</span><br><span class="line">├── ByteBufferPool.java</span><br><span class="line">├── BytesWritable.java</span><br><span class="line">├── ByteWritable.java</span><br><span class="line">├── Closeable.java</span><br><span class="line">├── compress</span><br><span class="line">├── CompressedWritable.java</span><br><span class="line">├── DataInputBuffer.java</span><br><span class="line">├── DataInputByteBuffer.java</span><br><span class="line">├── DataOutputBuffer.java</span><br><span class="line">├── DataOutputByteBuffer.java</span><br><span class="line">├── DataOutputOutputStream.java</span><br><span class="line">├── DefaultStringifier.java</span><br><span class="line">├── DoubleWritable.java</span><br><span class="line">├── ElasticByteBufferPool.java</span><br><span class="line">├── EnumSetWritable.java</span><br><span class="line">├── FastByteComparisons.java</span><br><span class="line">├── file</span><br><span class="line">├── FloatWritable.java</span><br><span class="line">├── GenericWritable.java</span><br><span class="line">├── InputBuffer.java</span><br><span class="line">├── IntWritable.java</span><br><span class="line">├── IOUtils.java</span><br><span class="line">├── LongWritable.java</span><br><span class="line">├── MapFile.java</span><br><span class="line">├── MapWritable.java</span><br><span class="line">├── MD5Hash.java</span><br><span class="line">├── MultipleIOException.java</span><br><span class="line">├── nativeio</span><br><span class="line">├── NullWritable.java</span><br><span class="line">├── ObjectWritable.java</span><br><span class="line">├── OutputBuffer.java</span><br><span class="line">├── package.html</span><br><span class="line">├── RawComparator.java</span><br><span class="line">├── ReadaheadPool.java</span><br><span class="line">├── retry</span><br><span class="line">├── SecureIOUtils.java</span><br><span class="line">├── SequenceFile.java</span><br><span class="line">├── serializer</span><br><span class="line">├── SetFile.java</span><br><span class="line">├── ShortWritable.java</span><br><span class="line">├── SortedMapWritable.java</span><br><span class="line">├── Stringifier.java</span><br><span class="line">├── Text.java</span><br><span class="line">├── TwoDArrayWritable.java</span><br><span class="line">├── UTF8.java</span><br><span class="line">├── VersionedWritable.java</span><br><span class="line">├── VersionMismatchException.java</span><br><span class="line">├── VIntWritable.java</span><br><span class="line">├── VLongWritable.java</span><br><span class="line">├── WritableComparable.java</span><br><span class="line">├── WritableComparator.java</span><br><span class="line">├── WritableFactories.java</span><br><span class="line">├── WritableFactory.java</span><br><span class="line">├── Writable.java</span><br><span class="line">├── WritableName.java</span><br><span class="line">└── WritableUtils.java</span><br><span class="line"></span><br><span class="line">5 directories, 59 files</span><br></pre></td></tr></table></figure>
<p>Hadoop 提供了一些如下一些与IO相关的类：</p>
<ul>
<li>org.apache.hadoop.io (基础类型读写)</li>
<li>org.apache.hadoop.io.compress (数据压缩，减少文件所需的存储空间，加快数据传输速度)</li>
<li>org.apache.hadoop.io.file.tfile (TFile文件类型)</li>
<li>org.apache.hadoop.io.nativeio (JNI包装的本地IO接口)</li>
<li>org.apache.hadoop.io.retry (RPC重试)</li>
<li>org.apache.hadoop.io.serializer (序列化)</li>
<li>org.apache.hadoop.io.serializer.avro  (为Avro提供数据序列化操作)</li>
</ul>
<h2 id="org-apache-hadoop-io"><a href="#org-apache-hadoop-io" class="headerlink" title="org.apache.hadoop.io"></a>org.apache.hadoop.io</h2><p>该包下的类提供了一些基础类型的读写，包括Writable机制、Comparable机制、数据类型(Int、Byte、Bytes、Long、Double、Float、Boolean、Text、Map)、基于文件的数据结构(SequenceFile、MapFile)、Buffer机制(InputBuffer、OutputBuffer)、线程池(Pool)、IO操作工具等。</p>
<h2 id="IOUtils类详细学习"><a href="#IOUtils类详细学习" class="headerlink" title="IOUtils类详细学习"></a>IOUtils类详细学习</h2><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="/resource/blog/2016-08/hadoop-common-io-ioutils.png" alt="IOUtils"></p>
<p>从类图中可以看出，主要由字节流拷贝、字节流读取出错包装、读取指定位置的全部字节、跳过指定位置的全部字节、关闭可关闭对象/流/Socket、空输出流写、全部输出流写等。</p>
<h3 id="字节流拷贝"><a href="#字节流拷贝" class="headerlink" title="字节流拷贝"></a>字节流拷贝</h3><p>该方法有五种形式，核心方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyBytes</span><span class="params">(InputStream in, OutputStream out, <span class="keyword">int</span> buffSize)</span></span><br><span class="line">  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否是处理流：PrintStream</span></span><br><span class="line">  PrintStream ps = out <span class="keyword">instanceof</span> PrintStream ? (PrintStream)out : <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">byte</span> buf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[buffSize];</span><br><span class="line">  <span class="keyword">int</span> bytesRead = in.read(buf);</span><br><span class="line">  <span class="comment">// 循环写</span></span><br><span class="line">  <span class="keyword">while</span> (bytesRead &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    out.write(buf, <span class="number">0</span>, bytesRead);</span><br><span class="line">    <span class="keyword">if</span> ((ps != <span class="keyword">null</span>) &amp;&amp; ps.checkError()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unable to write to output stream."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    bytesRead = in.read(buf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及copy指定大小的数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyBytes</span><span class="params">(InputStream in, OutputStream out, <span class="keyword">long</span> count,</span><br><span class="line">    <span class="keyword">boolean</span> close)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 缓冲区大小</span></span><br><span class="line">  <span class="keyword">byte</span> buf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">  <span class="comment">// 需要拷贝的数据大小</span></span><br><span class="line">  <span class="keyword">long</span> bytesRemaining = count;</span><br><span class="line">  <span class="keyword">int</span> bytesRead;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (bytesRemaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> bytesToRead = (<span class="keyword">int</span>)</span><br><span class="line">        (bytesRemaining &lt; buf.length ? bytesRemaining : buf.length);</span><br><span class="line"></span><br><span class="line">      bytesRead = in.read(buf, <span class="number">0</span>, bytesToRead);</span><br><span class="line">      <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      out.write(buf, <span class="number">0</span>, bytesRead);</span><br><span class="line">      bytesRemaining -= bytesRead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭读写指针</span></span><br><span class="line">    <span class="keyword">if</span> (close) &#123;</span><br><span class="line">      out.close();</span><br><span class="line">      out = <span class="keyword">null</span>;</span><br><span class="line">      in.close();</span><br><span class="line">      in = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭流</span></span><br><span class="line">    <span class="keyword">if</span> (close) &#123;</span><br><span class="line">      closeStream(out);</span><br><span class="line">      closeStream(in);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读取全部字节"><a href="#读取全部字节" class="headerlink" title="读取全部字节"></a>读取全部字节</h3><p>从输入流中读取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFully</span><span class="params">(InputStream in, <span class="keyword">byte</span> buf[],</span><br><span class="line">    <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> toRead = len;</span><br><span class="line">  <span class="keyword">while</span> (toRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret = in.read(buf, off, toRead);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException( <span class="string">"Premature EOF from inputStream"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    toRead -= ret;</span><br><span class="line">    off += ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[统计学习方法——感知机]]></title>
      <url>http://keyunluo.github.io/2016/08/05/2016-08-05-statical-learning-2.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>感知机(perceptron)是二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别取+1和-1二值，感知机对应于输入空间(特征空间)中将实例划分为正负两类的分离超平面，本节对应于统计学习方法第二章的内容。</p>
</blockquote>
<a id="more"></a>
<h2 id="感知机模型"><a href="#感知机模型" class="headerlink" title="感知机模型"></a>感知机模型</h2><ol>
<li><p>定义</p>
<p> 假设输入空间(特征空间)是 $ \mathcal{X} \subseteq \mathcal{R}^n $ ,输出空间是$\mathcal{y} = \{+1,-1\}$. 输入$x \in \mathcal{X}$表示实例的特征向量，对应于输入空间(特征空间)的点；输出$y \in \mathcal{Y}$表示实例的类别。由输入空间到输出空间的如下函数：</p>
<p> $$f(x)=sign(w \cdot x+b)$$</p>
<p> 被称为感知机，其中，$w$和$b$称为感知机模型参数，$w \in \mathcal{R}^n $称为权值或权值向量，$b \in \mathcal{R} $叫做偏置，$w \cdot x $ 表示$w$和$x$的内积，$sign$是符号函数，即：</p>
<p> $$
 f(x)=
 \begin{cases}
 +1&amp; \text{x &gt;= 0} \\
 -1&amp; \text{x &lt; 0}
 \end{cases}
 $$</p>
<p> 感知机是一种线性分类模型，属于判别模型，感知机模型的架设空间是定义在特征空间中的所有线性分类模型l(linear classification model)或线性分类器(linear classifier)，即函数集合$\{f \mid f(x)=w \cdot x+b \}$</p>
</li>
<li><p>感知机的几何解释</p>
<p> 线性方程 $ w \cdot x +b =0 $ 所代表的超平面将特征空间划分为正负两个部分。</p>
<p> <img src="/resource/blog/2016-08/perceptron.jpg" alt="感知机模型"></p>
<p> 这个平面（2维时退化为直线）称为分离超平面。</p>
</li>
</ol>
<h2 id="感知机学习策略"><a href="#感知机学习策略" class="headerlink" title="感知机学习策略"></a>感知机学习策略</h2><ol>
<li><p>数据集的线性可分性</p>
<p> 给定一个数据集： $T = \{(x_1,y_1),(x_2,y_2),\cdots ,(x_N,y_N)\}$,其中，$x_i \in \mathcal{X} = \mathcal{R}^n , y_i \in \mathcal{Y} = \{+1,-1\}, i = 1,2,\cdots ,N$,如果存在某个超平面$S$ : $w \cdot x + b =0$ 能够将数据集的正实例点和负实例点完全正确的划分到超平面的两侧，则称数据集$T$为线性可分数据集,否则称数据集$T$线性不可分。</p>
</li>
<li><p>感知机的学习策略</p>
<p> 假定数据集线性可分，我们希望找到一个合理的损失函数。</p>
<p> 一个朴素的想法是采用误分类点的总数，但是这样的损失函数不是参数$w，b$的连续可导函数，不可导自然不能把握函数的变化，也就不易优化（不知道什么时候该终止训练，或终止的时机不是最优的）。</p>
<p> 另一个想法是选择所有误分类点到超平面S的总距离。为此，先定义点$x_0$到平面$S$的距离：</p>
<p> $$\frac{1}{\Vert w \Vert} \vert w \cdot x_0 + b \vert $$</p>
<p> 其中，$\Vert w \Vert$是$w$的$L_2$范数。</p>
<p> 考虑到误分类时-y&gt;0,去掉绝对值符号，得到误分类点到超平面S的距离公式：</p>
<p> $$-\frac{1}{\Vert w \Vert} y_i ( w \cdot x_i + b)$$</p>
<p> 假设所有误分类点构成集合M，那么所有误分类点到超平面S的总距离为:</p>
<p> $$-\frac{1}{\Vert w \Vert} \sum_{x_i \in M}y_i ( w \cdot x_i + b)$$</p>
<p> 不考虑系数，得到感知机$sign(w \cdot x +b$学习的损失函数：</p>
<p> $$L(w,b)= - \sum_{x_i \in M} y_i(w \cdot x_i +b)$$</p>
<p> 其中$M$为误分类点的集合，这个损失函数就是感知机学习的经验风险函数。</p>
</li>
</ol>
<h2 id="感知机学习算法的原始形式"><a href="#感知机学习算法的原始形式" class="headerlink" title="感知机学习算法的原始形式"></a>感知机学习算法的原始形式</h2><ol>
<li><p>概述</p>
<p> 感知机学习算法是对以下最优化问题的算法,求参数$w,b$，使损失函数极小化：</p>
<p> $$min_{w,b} L(w,b)= - \sum_{x_i \in M} y_i(w \cdot x_i +b)$$</p>
<p> 感知机学习算法是误分类驱动的，先随机选取一个超平面，然后用随机梯度下降法(Stochastic Gradient Decent)不断极小化上述损失函数。损失函数的梯度由：</p>
<p> $$ \nabla_w L(w,b) = - \sum_{x_i \in M} y_ix_i $$</p>
<p> $$ \nabla_b L(w,b) = - \sum_{x_i \in M} y_i $$</p>
<p> 给出，所谓梯度，是一个向量，指向的是标量场增长最快的方向，长度是最大变化率。所谓标量场，指的是空间中任意一个点的属性都可以用一个标量表示的场。</p>
<p> 随机选择一个误分类点$(x_i,y_i)$，对$w,b$进行更新：</p>
<p> $$
 w \leftarrow w + \eta y_ix_i \\
 b \leftarrow b+ \eta y_i
 $$</p>
<p> $\eta(0&lt;\eta \leq 1)$是步长，在统计学习中称为学习率。损失函数的参数加上梯度上升的反方向，于是就梯度下降了。所以，上述迭代可以使损失函数不断减小，直到为0。</p>
</li>
<li><p>感知器学习算法</p>
<p> 输入：训练数据集$T=\{(x_1,y_1),(x_2,y_2), \cdots , (x_N,y_N)\},其中x_i \in \mathcal{X} = \mathcal{R}^n,y_i \in \mathcal{Y} = \{+1,-1 \},i=1,2,\cdots ,N;学习率\eta(0&lt;\eta \leq 1);$</p>
<p> 输出：$w,b; 感知机模型 f(x) = sign(w \cdot x +b)$</p>
<p> (1) 选取初值 $w_0,b_0$</p>
<p> (2) 在训练集中选取数据$(x_i,y_i)$</p>
<p> (3) 如果$y_i(w \cdot x_i +b) \leq 0 $</p>
<p> $$
 w \leftarrow w + \eta y_ix_i  \\
 b \leftarrow b+ \eta y_i
 $$</p>
<p> (4) 转至(2)，直到训练集中没有误分类点</p>
</li>
<li><p>一个例子</p>
<p> 如下图所示的训练数据集，其正实例点是$x_1=(3,3)^T,x_2=(4,3)^T$,负实例点是$x_3=(1,1)^T$，试用感知机学习算法的原始形式求解感知机模型$f(x)=sign(w \cdot x +b),其中w = (w^{(1)},w^{(2)})^T,x = (x^{(1)},x^{(2)})^T$</p>
<p> <img src="/resource/blog/2016-08/perceptronexample.jpg" alt="感知机实例"></p>
<p> 解： 构建最优化问题,按照上述算法求解$w,b,\eta = 1$</p>
<p> (1) 取初值$w_0=0,b_0 =0$</p>
<p> (2) 对$x_1=(3,3)^T,y_1(w_0 \cdot x_1 +b_0) = 0$,未能被正确分类，更新$w,b$:</p>
<p> $$
 w_1 = w_0 +y_1x_1=(3,3)^T  \\
 b_1 = b_0 +y_1 = 1
 $$</p>
<p> 得到线性模型</p>
<p> $$w_1 \cdot x + b_1 = 3x^{(1)}+3x^{(2)}+1$$</p>
<p> (3) 对$x_1,x_2，显然有y_i(w_1 \cdot x_i +b_1)&gt;0，被正确分类，不修改w,b;对于x_3=(1,1)^T,y_3(w_1 \cdot x_3 +b_1)&lt;0，被误分类，更新w,b:$</p>
<p> $$
 w_2 = w_1 +y_3x_3=(2,2)^T \\
 b_2 = b_1 + y_3 = 0
 $$</p>
<p> 得到线性模型： $w_2 \cdot x + b_2 = 2x^{(1)}+2x^{(2)}$</p>
<p> 如此继续下去，直到：</p>
<p> $$
 w_7 =(1,1)^T ,b_7=-3
 $$</p>
<p> 对于所有的点都没有误分类点，损失函数达到极小。</p>
</li>
<li><p>Python代码实现</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> animation</span><br><span class="line"></span><br><span class="line">training_set = [[(<span class="number">3</span>, <span class="number">3</span>), <span class="number">1</span>], [(<span class="number">4</span>, <span class="number">3</span>), <span class="number">1</span>], [(<span class="number">1</span>, <span class="number">1</span>), <span class="number">-1</span>]]</span><br><span class="line">w = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">b = <span class="number">0</span></span><br><span class="line">eta = <span class="number">1</span></span><br><span class="line">history = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新变量:w,b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> w, b, eta , history</span><br><span class="line">    w[<span class="number">0</span>] += eta * item[<span class="number">1</span>] * item[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    w[<span class="number">1</span>] += eta * item[<span class="number">1</span>] * item[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    b += eta * item[<span class="number">1</span>]</span><br><span class="line">    print(w, b)</span><br><span class="line">    history.append([copy.copy(w), b])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算y(w*xi+b)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal</span><span class="params">(item)</span>:</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(item[<span class="number">0</span>])):</span><br><span class="line">        res += item[<span class="number">0</span>][i] * w[i]</span><br><span class="line">    res += b</span><br><span class="line">    res *= item[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断超平面是否正确</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">()</span>:</span></span><br><span class="line">    flag = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> training_set:</span><br><span class="line">        <span class="keyword">if</span> cal(item) &lt;= <span class="number">0</span>:</span><br><span class="line">            flag = <span class="keyword">True</span></span><br><span class="line">            update(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">        print(<span class="string">"RESULT: w: "</span> + str(w) + <span class="string">" b: "</span> + str(b))</span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> check(): <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># first set up the figure, the axis, and the plot element we want to animate</span></span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = plt.axes(xlim=(<span class="number">0</span>, <span class="number">4</span>), ylim=(<span class="number">-2</span>, <span class="number">2</span>))</span><br><span class="line">    line, = ax.plot([], [], <span class="string">'g'</span>, lw=<span class="number">2</span>)</span><br><span class="line">    label = ax.text([], [], <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># initialization function: plot the background of each frame</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">()</span>:</span></span><br><span class="line">        line.set_data([], [])</span><br><span class="line">        x, y, x_, y_ = [], [], [], []</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> training_set:</span><br><span class="line">            <span class="comment"># 正实例</span></span><br><span class="line">            <span class="keyword">if</span> p[<span class="number">1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                x.append(p[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">                y.append(p[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 负实例</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x_.append(p[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">                y_.append(p[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        plt.plot(x,y,<span class="string">'bo'</span>)</span><br><span class="line">        plt.plot(x_,y_,<span class="string">'rx'</span>)</span><br><span class="line">        plt.legend([<span class="string">'超平面'</span>,<span class="string">'正实例'</span>, <span class="string">'负实例'</span>], loc=<span class="string">'upper left'</span>)</span><br><span class="line">        plt.axis([<span class="number">-1</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">5</span>])</span><br><span class="line">        plt.grid(<span class="keyword">True</span>)</span><br><span class="line">        plt.xlabel(<span class="string">'x'</span>)</span><br><span class="line">        plt.ylabel(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">        plt.title(<span class="string">'感知机算法实验——原始形式'</span>)</span><br><span class="line">        <span class="keyword">return</span> line, label</span><br><span class="line"></span><br><span class="line">    <span class="comment"># animation function.  this is called sequentially</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">animate</span><span class="params">(i)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> history, ax, line, label</span><br><span class="line"></span><br><span class="line">        w = history[i][<span class="number">0</span>]</span><br><span class="line">        b = history[i][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        hyperplane = <span class="string">"&#123;0&#125;*x1+&#123;1&#125;*x2+&#123;2&#125;=0"</span>.format(w[<span class="number">0</span>],w[<span class="number">1</span>],b)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> w[<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">            line.set_data([<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">            label.set_text(<span class="string">"第%d次运算:"</span>%(i+<span class="number">1</span>)+<span class="string">"超平面:"</span>+hyperplane)</span><br><span class="line">            label.set_position([<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> line, label</span><br><span class="line">        x1 = <span class="number">-6</span></span><br><span class="line">        y1 = -(b + w[<span class="number">0</span>] * x1) / w[<span class="number">1</span>]</span><br><span class="line">        x2 = <span class="number">6</span></span><br><span class="line">        y2 = -(b + w[<span class="number">0</span>] * x2) / w[<span class="number">1</span>]</span><br><span class="line">        line.set_data([x1, x2], [y1, y2])</span><br><span class="line">        x1 = <span class="number">0</span></span><br><span class="line">        y1 = -(b + w[<span class="number">0</span>] * x1) / w[<span class="number">1</span>]</span><br><span class="line">        label.set_text(<span class="string">"第%d次运算:"</span>%(i+<span class="number">1</span>)+<span class="string">"超平面:"</span>+hyperplane)</span><br><span class="line">        label.set_position([x1, y1])</span><br><span class="line">        <span class="keyword">return</span> line, label</span><br><span class="line"></span><br><span class="line">    print(history)</span><br><span class="line">    anim = animation.FuncAnimation(fig, animate, init_func=init, frames=len(history), interval=<span class="number">1000</span>, repeat=<span class="keyword">True</span>,blit=<span class="keyword">True</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    anim.save(<span class="string">'perceptron-animate.gif'</span>, fps=<span class="number">2</span>, writer=<span class="string">'imagemagick'</span>)</span><br></pre></td></tr></table></figure>
<p>动画显示如下：
<img src="/resource/blog/2016-08/perceptron-animate.gif" alt="perceptron-animate"></p>
<h2 id="感知机学习算法的对偶形式"><a href="#感知机学习算法的对偶形式" class="headerlink" title="感知机学习算法的对偶形式"></a>感知机学习算法的对偶形式</h2><ol>
<li><p>概述
 对偶指的是，将$w和b$表示为测试数据$i$的线性组合形式，通过求解系数得到$w和b$。具体说来，如果对误分类点i逐步修改$wb$修改了$n$次，则$w，b关于i$的增量分别为增量${\alpha}_iy_ix_i和{\alpha}_iy_i，这里{\alpha}_i=n_i\eta$，则最终求解到的参数分别表示为：</p>
<p> $$
 w \leftarrow w + \eta y_ix_i \\
 b \leftarrow b + \eta y_i
 $$</p>
</li>
<li><p>算法</p>
<p> 输入：线性可分的数据集$T=\{(x_1,y_1),(x_2,y_2), \cdots , (x_N,y_N)\},其中x_i \in \mathcal{X} = \mathcal{R}^n,y_i \in \mathcal{Y} = \{+1,-1 \},i=1,2,\cdots ,N;学习率\eta(0&lt;\eta \leq 1);$</p>
<p> 输出：$\alpha,b; 感知机模型 f(x) = sign(\sum_{j=1}^N \alpha_jy_jx_j \cdot x +b),其中\alpha = (\alpha_1,\alpha_2,\cdots ,\alpha_N)^T$</p>
<p> (1) 选取初值 $\alpha \leftarrow 0,b \leftarrow 0$</p>
<p> (2) 在训练集中选取数据$(x_i,y_i)$</p>
<p> (3) 如果$y_i(\sum_{j=1}^N \alpha_jy_jx_j \cdot x +b) \leq 0 $</p>
<p> $$
 \alpha_i \leftarrow \alpha_i + \eta  \\
 b \leftarrow b+ \eta y_i
 $$</p>
<p> (4) 转至(2)，直到训练集中没有误分类点</p>
<p> 对偶形式中的训练实例仅以内积的形式出现，为了方便，可以预先将训练集中实例间的内积计算出来并以矩阵的形式存储，这个矩阵被称为Gram矩阵：</p>
<p> $$ G = [x_i \cdot x_j]_{N \times N} $$</p>
</li>
<li><p>代码</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> animation</span><br><span class="line"></span><br><span class="line">training_set = [[(<span class="number">3</span>, <span class="number">3</span>), <span class="number">1</span>], [(<span class="number">4</span>, <span class="number">3</span>), <span class="number">1</span>], [(<span class="number">1</span>, <span class="number">1</span>), <span class="number">-1</span>]]</span><br><span class="line"><span class="comment"># training_set = np.array([[[3, 3], 1], [[4, 3], 1], [[1, 1], -1], [[5, 2], -1]])</span></span><br><span class="line">a = np.zeros(len(training_set), np.float)</span><br><span class="line">b = <span class="number">0.0</span></span><br><span class="line">Gram = <span class="keyword">None</span></span><br><span class="line">eta = <span class="number">1</span></span><br><span class="line"><span class="comment"># y = np.array(training_set[:, 1])</span></span><br><span class="line">y = np.empty((len(training_set)), np.float)</span><br><span class="line">x = np.empty((len(training_set), <span class="number">2</span>), np.float)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(training_set)):</span><br><span class="line">    x[i] = training_set[i][<span class="number">0</span>]</span><br><span class="line">    y[i] = training_set[i][<span class="number">1</span>]</span><br><span class="line">history = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算Gram矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_gram</span><span class="params">()</span>:</span></span><br><span class="line">    g = np.empty((len(training_set), len(training_set)), np.int)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(training_set)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(training_set)):</span><br><span class="line">            g[i][j] = np.dot(training_set[i][<span class="number">0</span>], training_set[j][<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新变量:a,b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a, b, eta</span><br><span class="line">    a[i] += eta</span><br><span class="line">    b = b + y[i]</span><br><span class="line">    history.append([np.dot(a * y, x), b])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算判断条件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a, b, x, y</span><br><span class="line">    res = np.dot(a * y, Gram[i])</span><br><span class="line">    res = (res + b) * y[i]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断超平面是否正确</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a, b, x, y</span><br><span class="line">    flag = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(training_set)):</span><br><span class="line">        <span class="keyword">if</span> cal(i) &lt;= <span class="number">0</span>:</span><br><span class="line">            flag = <span class="keyword">True</span></span><br><span class="line">            update(i)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">        w = np.dot(a * y, x)</span><br><span class="line">        print(<span class="string">"RESULT: w: "</span> + str(w) + <span class="string">" b: "</span> + str(b))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    Gram = cal_gram()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> check(): <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># first set up the figure, the axis, and the plot element we want to animate</span></span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = plt.axes(xlim=(<span class="number">0</span>, <span class="number">4</span>), ylim=(<span class="number">-2</span>, <span class="number">2</span>))</span><br><span class="line">    line, = ax.plot([], [], <span class="string">'g'</span>, lw=<span class="number">2</span>)</span><br><span class="line">    label = ax.text([], [], <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># initialization function: plot the background of each frame</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">()</span>:</span></span><br><span class="line">        line.set_data([], [])</span><br><span class="line">        x, y, x_, y_ = [], [], [], []</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> training_set:</span><br><span class="line">            <span class="comment"># 正实例</span></span><br><span class="line">            <span class="keyword">if</span> p[<span class="number">1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                x.append(p[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">                y.append(p[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 负实例</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x_.append(p[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">                y_.append(p[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        plt.plot(x,y,<span class="string">'bo'</span>)</span><br><span class="line">        plt.plot(x_,y_,<span class="string">'rx'</span>)</span><br><span class="line">        plt.legend([<span class="string">'超平面'</span>,<span class="string">'正实例'</span>, <span class="string">'负实例'</span>], loc=<span class="string">'upper left'</span>)</span><br><span class="line">        plt.axis([<span class="number">-1</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">5</span>])</span><br><span class="line">        plt.grid(<span class="keyword">True</span>)</span><br><span class="line">        plt.xlabel(<span class="string">'x'</span>)</span><br><span class="line">        plt.ylabel(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">        plt.title(<span class="string">'感知机算法实验——对偶形式'</span>)</span><br><span class="line">        <span class="keyword">return</span> line, label</span><br><span class="line"></span><br><span class="line">    <span class="comment"># animation function.  this is called sequentially</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">animate</span><span class="params">(i)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> history, ax, line, label</span><br><span class="line"></span><br><span class="line">        w = history[i][<span class="number">0</span>]</span><br><span class="line">        b = history[i][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        hyperplane = <span class="string">"&#123;0&#125;*x1+&#123;1&#125;*x2+&#123;2&#125;=0"</span>.format(w[<span class="number">0</span>],w[<span class="number">1</span>],b)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> w[<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">            line.set_data([<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">            label.set_text(<span class="string">"第%d次运算:"</span>%(i+<span class="number">1</span>)+<span class="string">"超平面:"</span>+hyperplane)</span><br><span class="line">            label.set_position([<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> line, label</span><br><span class="line">        x1 = <span class="number">-6</span></span><br><span class="line">        y1 = -(b + w[<span class="number">0</span>] * x1) / w[<span class="number">1</span>]</span><br><span class="line">        x2 = <span class="number">6</span></span><br><span class="line">        y2 = -(b + w[<span class="number">0</span>] * x2) / w[<span class="number">1</span>]</span><br><span class="line">        line.set_data([x1, x2], [y1, y2])</span><br><span class="line">        x1 = <span class="number">0</span></span><br><span class="line">        y1 = -(b + w[<span class="number">0</span>] * x1) / w[<span class="number">1</span>]</span><br><span class="line">        label.set_text(<span class="string">"第%d次运算:"</span>%(i+<span class="number">1</span>)+<span class="string">"超平面:"</span>+hyperplane)</span><br><span class="line">        label.set_position([x1, y1])</span><br><span class="line">        <span class="keyword">return</span> line, label</span><br><span class="line"></span><br><span class="line">    print(history)</span><br><span class="line">    anim = animation.FuncAnimation(fig, animate, init_func=init, frames=len(history), interval=<span class="number">1000</span>, repeat=<span class="keyword">True</span>,blit=<span class="keyword">True</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    anim.save(<span class="string">'perceptron-animate2.gif'</span>, fps=<span class="number">2</span>, writer=<span class="string">'imagemagick'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="感知机学习算法的收敛性"><a href="#感知机学习算法的收敛性" class="headerlink" title="感知机学习算法的收敛性"></a>感知机学习算法的收敛性</h2><p>设训练数据集$T=\{(x_1,y_1),(x_2,y_2), \cdots , (x_N,y_N)\}是线性可分的,其中x_i \in \mathcal{X} = \mathcal{R}^n,y_i \in \mathcal{Y} = \{+1,-1 \},i=1,2,\cdots ,N;学习率\eta(0&lt;\eta \leq 1);$,则：</p>
<p>(1) 存在满足条件$\Vert \hat{w}_{opt} \Vert = 1的超平面 \hat{w}_{opt} \cdot x + b_{opt} =0 将训练数据集完全正确分开；且存在\gamma &gt;0,对所有的 i=1,2,\cdots , N $ :</p>
<p>$$y_i(\hat{w}]_{opt} \cdot \hat{x}]_i) = y_i(w_{opt} \cdot x_i + b_{opt}) \geq \gamma $$</p>
<p>(2) 令 $R = {max}_{1 \leq i \leq N} \Vert \hat{x}_i \Vert$,则感知机算法在训练集上的错误分类次数k满足不等式：</p>
<p>$$k \leq {\left( \frac{R}{\gamma} \right)}^2$$</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop源码学习(4)——Hadoop-Common-Conf(2)]]></title>
      <url>http://keyunluo.github.io/2016/08/04/2016-08-04-hadoop-common-conf-2.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>本节学习Hadoop-Common-Project中的hadoop-common-conf模块，该模块主要实现了hadoop项目中的配置信息处理，学习设置配置等内容。</p>
</blockquote>
<a id="more"></a>
<h2 id="get"><a href="#get" class="headerlink" title="get*"></a>get*</h2><p>get用于在Configuration对象中获取相应的配置信息，这些配置信息可以是boolean、int、long等基本类型，也可以是其他一些Hadoop常用类型，如类的信息(getClassByName、getClasses、getClass)、String数组(getStringCollection、getStrings)、URL(getResource)等，这些方法里最重要的是get()方法，它根据配置项的键获取相应的值，如果键不存在，则返回默认值defaultValue，其他的方法都会依赖Configuration.get()，并在get()的基础上做进一步的处理，get方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String name, String defaultValue)</span> </span>&#123;</span><br><span class="line">  String[] names = handleDeprecation(deprecationContext.get(), name);</span><br><span class="line">  String result = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">for</span>(String n : names) &#123;</span><br><span class="line">    result = substituteVars(getProps().getProperty(n, defaultValue));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Configuration.get()会调用私有方法substituteVars(),该方法会完成配置的属性扩展。属性扩展是将配置项的值包含${key}这种格式的变量替换成相应的值。</p>
<h2 id="配置属性扩展高效算法"><a href="#配置属性扩展高效算法" class="headerlink" title="配置属性扩展高效算法"></a>配置属性扩展高效算法</h2><p>代码中提到了一种快速的属性替换算法，比正则表达式快15倍以上。substituteVars的工作依赖于正则表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">varPat : \$\&#123;[^\&#125;\$ ]+ \&#125;</span><br></pre></td></tr></table></figure>
<p>即匹配${key},key不包含<code>}</code>,<code>$</code>和空格的一系列字符串，key至少出现一次。</p>
<p>该算法的详细代码如下：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性扩展只能进行一定的次数，最多20次，避免死循环</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SUBST = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始处的下标</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUB_START_IDX = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 结束处的下标</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUB_END_IDX = SUB_START_IDX + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * This is a manual implementation of the following regex</span><br><span class="line"> * "\\$\\&#123;[^\\&#125;\\$\u0020]+\\&#125;". It can be 15x more efficient than</span><br><span class="line"> * a regex matcher as demonstrated by HADOOP-11506. This is noticeable with</span><br><span class="line"> * Hadoop apps building on the assumption Configuration#get is an O(1)</span><br><span class="line"> * hash table lookup, especially when the eval is a long string.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> eval a string that may contain variables requiring expansion.</span><br><span class="line"> * <span class="doctag">@return</span> a 2-element int array res such that</span><br><span class="line"> * eval.substring(res[0], res[1]) is "var" for the left-most occurrence of</span><br><span class="line"> * $&#123;var&#125; in eval. If no variable is found -1, -1 is returned.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] findSubVariable(String eval) &#123;</span><br><span class="line">  <span class="keyword">int</span>[] result = &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> matchStart;  <span class="comment">// 匹配开始处，不断移动</span></span><br><span class="line">  <span class="keyword">int</span> leftBrace;   <span class="comment">// 从开始处匹配的第一个`&#123;`</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// scanning for a brace first because it's less frequent than $</span></span><br><span class="line">  <span class="comment">// that can occur in nested class names</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  match_loop:</span><br><span class="line">  <span class="comment">// 从括号左边扫描</span></span><br><span class="line">  <span class="keyword">for</span> (matchStart = <span class="number">1</span>, leftBrace = eval.indexOf(<span class="string">'&#123;'</span>, matchStart);</span><br><span class="line">       <span class="comment">// minimum left brace position (follows '$')</span></span><br><span class="line">       leftBrace &gt; <span class="number">0</span></span><br><span class="line">       <span class="comment">// right brace of a smallest valid expression "$&#123;c&#125;"</span></span><br><span class="line">       &amp;&amp; leftBrace + <span class="string">"&#123;c"</span>.length() &lt; eval.length();</span><br><span class="line">       leftBrace = eval.indexOf(<span class="string">'&#123;'</span>, matchStart)) &#123;</span><br><span class="line">    <span class="keyword">int</span> matchedLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (eval.charAt(leftBrace - <span class="number">1</span>) == <span class="string">'$'</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> subStart = leftBrace + <span class="number">1</span>; <span class="comment">// after '&#123;'</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = subStart; i &lt; eval.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (eval.charAt(i)) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'&#125;'</span>:  <span class="comment">//匹配到结果，返回结果</span></span><br><span class="line">            <span class="keyword">if</span> (matchedLen &gt; <span class="number">0</span>) &#123; <span class="comment">// match</span></span><br><span class="line">              result[SUB_START_IDX] = subStart;</span><br><span class="line">              result[SUB_END_IDX] = subStart + matchedLen;</span><br><span class="line">              <span class="keyword">break</span> match_loop;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// fall through to skip 1 char</span></span><br><span class="line">          <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">'$'</span>:</span><br><span class="line">            matchStart = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span> match_loop;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            matchedLen++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// scanned from "$&#123;"  to the end of eval, and no reset via ' ', '$':</span></span><br><span class="line">      <span class="comment">//    no match!</span></span><br><span class="line">      <span class="keyword">break</span> match_loop;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// not a start of a variable</span></span><br><span class="line">      <span class="comment">// 不是一个变量的开始，从括号后一个字母继续</span></span><br><span class="line">      matchStart = leftBrace + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Attempts to repeatedly expand the value &#123;<span class="doctag">@code</span> expr&#125; by replacing the</span><br><span class="line"> * left-most substring of the form "$&#123;var&#125;" in the following precedence order</span><br><span class="line"> * &lt;ol&gt;</span><br><span class="line"> *   &lt;li&gt;by the value of the Java system property "var" if defined&lt;/li&gt;</span><br><span class="line"> *   &lt;li&gt;by the value of the configuration key "var" if defined&lt;/li&gt;</span><br><span class="line"> * &lt;/ol&gt;</span><br><span class="line"> *</span><br><span class="line"> * If var is unbounded the current state of expansion "prefix$&#123;var&#125;suffix" is</span><br><span class="line"> * returned.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> expr the literal value of a config key</span><br><span class="line"> * <span class="doctag">@return</span> null if expr is null, otherwise the value resulting from expanding</span><br><span class="line"> * expr using the algorithm above.</span><br><span class="line"> * <span class="doctag">@throws</span> IllegalArgumentException when more than</span><br><span class="line"> * &#123;<span class="doctag">@link</span> Configuration#MAX_SUBST&#125; replacements are required</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">// 重复替换表达式最左边的属性扩展</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">substituteVars</span><span class="params">(String expr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (expr == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  String eval = expr;</span><br><span class="line">  <span class="comment">// 循环，最多做20次属性扩展</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; MAX_SUBST; s++) &#123;</span><br><span class="line">    <span class="comment">// 老版本： private static pattern varPat = Pattern.compile("\\$\\&#123;[^\\&#125;\\$\u0020]+\\&#125;");</span></span><br><span class="line">    <span class="comment">// 替换： Matcher match = varPat.matcher("");</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] varBounds = findSubVariable(eval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 什么都没有找到，返回表达式</span></span><br><span class="line">    <span class="keyword">if</span> (varBounds[SUB_START_IDX] == -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> eval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取子串</span></span><br><span class="line">    <span class="keyword">final</span> String var = eval.substring(varBounds[SUB_START_IDX],</span><br><span class="line">        varBounds[SUB_END_IDX]);</span><br><span class="line">    String val = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 查看系统属性里有没有var对应的val</span></span><br><span class="line">    <span class="comment">// 这一步保证有限使用系统属性做属性扩展</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      val = System.getProperty(var);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(SecurityException se) &#123;</span><br><span class="line">      LOG.warn(<span class="string">"Unexpected SecurityException in Configuration"</span>, se);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看Configuration保存的键-值对里有没有var对应的val</span></span><br><span class="line">    <span class="keyword">if</span> (val == <span class="keyword">null</span>) &#123;</span><br><span class="line">      val = getRaw(var);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//属性扩展中的var没有绑定，不做扩展，返回</span></span><br><span class="line">    <span class="keyword">if</span> (val == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> eval; <span class="comment">// return literal $&#123;var&#125;: var is unbound</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> dollar = varBounds[SUB_START_IDX] - <span class="string">"$&#123;"</span>.length();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> afterRightBrace = varBounds[SUB_END_IDX] + <span class="string">"&#125;"</span>.length();</span><br><span class="line">    <span class="comment">// 替换，完成属性扩展</span></span><br><span class="line">    eval = eval.substring(<span class="number">0</span>, dollar)</span><br><span class="line">           + val</span><br><span class="line">           + eval.substring(afterRightBrace);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//次数过多，抛出异常</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Variable substitution depth too large: "</span></span><br><span class="line">                                  + MAX_SUBST + <span class="string">" "</span> + expr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Configurable-接口"><a href="#Configurable-接口" class="headerlink" title="Configurable 接口"></a>Configurable 接口</h2><p>Configurable的含义是可配置的，如果一个类实现了该接口，意味着该类是可以配置的，可以通过为这个类的对象传入一个Configuration实例。</p>
<ul>
<li>类图
<img src="/resource/blog/2016-08/configurable.png" alt="Configurable"></li>
</ul>
<p>Hadoop中有大量的类实现了Configurable接口，如org.apache.hadoop.mapreduce.lib.input.RegexFilter,RegexFilter对象工作时，需要提供一个正则表达式，用于过滤读取的记录。由于在RegexFilter的父类Filter中实现了Configurable接口，RegexFilter可以在它的setConf()方法中使用Configuration.get()方法获取以字符串传入的正则表达式，并初始化成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** configure the Filter by checking the configuration</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConf</span><span class="params">(Configuration conf)</span> </span>&#123;</span><br><span class="line">  String regex = conf.get(FILTER_REGEX);</span><br><span class="line">  <span class="keyword">if</span> (regex == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(FILTER_REGEX + <span class="string">"not set"</span>);</span><br><span class="line">  <span class="keyword">this</span>.p = Pattern.compile(regex);</span><br><span class="line">  <span class="keyword">this</span>.conf = conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，对象创建以后，就应该使用setConf()方法，为对象提供进一步的初始化工作。为了简化对象创建和调用setConf()方法这两个连续的步骤，org.apache.hadoop.util.ReflectionUtils提供了静态方法newInstance(),代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Class&lt;T&gt; theClass, Configuration conf)</span> </span>&#123;</span><br><span class="line">  T result;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Constructor&lt;T&gt; meth = (Constructor&lt;T&gt;) CONSTRUCTOR_CACHE.get(theClass);</span><br><span class="line">    <span class="keyword">if</span> (meth == <span class="keyword">null</span>) &#123;</span><br><span class="line">      meth = theClass.getDeclaredConstructor(EMPTY_ARRAY);</span><br><span class="line">      meth.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      CONSTRUCTOR_CACHE.put(theClass, meth);</span><br><span class="line">    &#125;</span><br><span class="line">    result = meth.newInstance();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">  &#125;</span><br><span class="line">  setConf(result, conf);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法newInstance()利用Java反射机制，根据对象类型信息(参数 theClass)，创建一个新的相应类型的对象，然后调用ReflectionUtils中的另一个静态方法setConf()配置对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setConf</span><span class="params">(Object theObject, Configuration conf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (conf != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (theObject <span class="keyword">instanceof</span> Configurable) &#123;</span><br><span class="line">      ((Configurable) theObject).setConf(conf);</span><br><span class="line">    &#125;</span><br><span class="line">    setJobConf(theObject, conf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在setConf()中，如果对象实现了Configurable接口，那么对象的setConf()方法会被调用，并根据COnfiguration类的实例conf进一步初始化对象。</p>
<h2 id="Configured类"><a href="#Configured类" class="headerlink" title="Configured类"></a>Configured类</h2><p>Configured类实现了Configurable接口，默认在构造函数中调用了setConf()方法，可简化使用</p>
<ul>
<li>类图
<img src="/resource/blog/2016-08/configured.png" alt="Configured"></li>
</ul>
<h2 id="ConfServlet类"><a href="#ConfServlet类" class="headerlink" title="ConfServlet类"></a>ConfServlet类</h2><p>输出正在运行的configuration数据的一个Servlet.</p>
<p><img src="/resource/blog/2016-08/ConfServlet.png" alt="ConfServlet"></p>
<h2 id="Reconfigurable"><a href="#Reconfigurable" class="headerlink" title="Reconfigurable"></a>Reconfigurable</h2><p>在运行时改变配置文件，与Reconfigurable相关的类共有6个：</p>
<ul>
<li>Reconfigurable ：接口，属性是否可改变等方法</li>
<li>ReconfigurableBase ：实现Reconfigurable接口的基类</li>
<li>ReconfigurationException ：属性不可改变，抛出异常</li>
<li>ReconfigurationServlet ：改变一个节点的配置文件的Servlet</li>
<li>ReconfigurationTaskStatus ：重新配置的任务状态信息</li>
<li>ReconfigurationUtil ：工具类，获得改变的属性</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop源码学习(3)——Hadoop-Common-Conf(1)]]></title>
      <url>http://keyunluo.github.io/2016/08/03/2016-08-03-hadoop-common-conf-1.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>本节学习Hadoop-Common-Project中的hadoop-common-conf模块，该模块主要实现了hadoop项目中的配置信息处理，从总体上了解configuration类。</p>
</blockquote>
<a id="more"></a>
<h2 id="hadoop-common-源代码结构"><a href="#hadoop-common-源代码结构" class="headerlink" title="hadoop-common 源代码结构"></a>hadoop-common 源代码结构</h2><p>hadoop-common是hadoop项目中的核心模块，在src/main中定义了很多基础功能，此外还有protobuf等定义，本文学习org.apache.hadoop.conf配置类的设计。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">├── org</span><br><span class="line">│   └── apache</span><br><span class="line">│       └── hadoop</span><br><span class="line">│           ├── conf</span><br><span class="line">│           ├── crypto</span><br><span class="line">│           ├── fs</span><br><span class="line">│           ├── ha</span><br><span class="line">│           ├── HadoopIllegalArgumentException.java</span><br><span class="line">│           ├── http</span><br><span class="line">│           ├── io</span><br><span class="line">│           ├── ipc</span><br><span class="line">│           ├── jmx</span><br><span class="line">│           ├── log</span><br><span class="line">│           ├── metrics</span><br><span class="line">│           ├── metrics2</span><br><span class="line">│           ├── net</span><br><span class="line">│           ├── record</span><br><span class="line">│           ├── security</span><br><span class="line">│           ├── service</span><br><span class="line">│           ├── tools</span><br><span class="line">│           ├── tracing</span><br><span class="line">│           └── util</span><br><span class="line">└── overview.html</span><br><span class="line"></span><br><span class="line">21 directories, 2 files</span><br></pre></td></tr></table></figure>
<h2 id="Java中的配置文件"><a href="#Java中的配置文件" class="headerlink" title="Java中的配置文件"></a>Java中的配置文件</h2><p>JDK提供了java.util.Properties类，用于处理简单的配置文件，它只支持键值对，形式如下：<code>ENTRY=VALUE</code>。由于Properties是基于HashTable的，它部支持节，对配置文件进行分类。</p>
<p>java.util.Properties中处理属性列表的主要方法：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用指定的键在此属性列表中搜索属性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getProperty</span><span class="params">(String key)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能同上，参数defaultValue提供了默认值</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title">getProperty</span><span class="params">(String key,String defaultValue)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Properties.setProperty()最终调用Hashtable的方法put</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> object <span class="title">setProperty</span><span class="params">(String key,String value)</span></span></span><br></pre></td></tr></table></figure></p>
<p>由于Java本身提供的配置文件功能简单，Java社区出现了大量的配置信息的读/写方案，其中比较有名的是Apache Jakarta Commons提供的Commons Configuration，其支持文本，XML配置文件格式，支持加载多个配置文件，支持分层或多级配置等。</p>
<p>Hadoop没有使用Java自带的配置文件类以及第三方类，而是自己实现了一套独有的配置文件管理系统，并提供了自己的API，即使用org.apache.hadoop.conf.Configuration处理配置信息。</p>
<h2 id="Configuration配置文件概述"><a href="#Configuration配置文件概述" class="headerlink" title="Configuration配置文件概述"></a>Configuration配置文件概述</h2><p>Hadoop配置文件采用ＸＭＬ格式，一个例子如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapred.child.java.opts<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>-Xmx4096m<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Hadoop配置文件的根元素是configuration，一般只包含子元素property。同时，Hadoop可以将多个配置文件合并，产生一个配置，如core-site.xml和core-default.xml，通过Configure类的loadResource()方法，把它们合并成一个配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">conf.addResource(<span class="string">"core-default.xml"</span>);</span><br><span class="line">conf.addResource(<span class="string">"core-site.xml"</span>);</span><br></pre></td></tr></table></figure>
<p>如果这两个资源都包含了相同的配置项。并且前面的一个资源配置项没有标记为final，那么后面的配置将覆盖前面的配置。</p>
<p>Hadoop配置系统还有一个很重要的功能，就是属性扩展，即可以使用<code>${}</code>进行引用。</p>
<p>使用Configuration类的一般过程是：构造Configuration对象，通过类的addResource()方法添加需要加载的资源；然后通过get<em>和set</em>方法访问/设置配置项，资源会在第一次使用的时候自动加载到对象中。</p>
<h2 id="Configuration-类分析"><a href="#Configuration-类分析" class="headerlink" title="Configuration 类分析"></a>Configuration 类分析</h2><ul>
<li>类图</li>
</ul>
<p><img src="/resource/blog/2016-08/hadoop-common-conf.png" alt="hadoop-common-conf"></p>
<ul>
<li>Configuration.addSource</li>
</ul>
<p>资源Resource由Object和Name构成。数组resources保存了所有通过addResource()方法添加Configuration对象的资源，Configuration.addSource()有如下六种形式：</p>
<ul>
<li>public void addResource(String name) ：CLASSPATH资源,如 “core-site.xml”</li>
<li>public void addResource(URL url) : 如 “<a href="http://server.com/core-site.xml" target="_blank" rel="external">http://server.com/core-site.xml</a>“</li>
<li>public void addResource(Path file) : hadoop文件路径，如 “hdfs://server:54300/conf/core-site.xml”</li>
<li>public void addResource(InputStream in) : 一个已经打开的输入流</li>
<li>public void addResource(InputStream in, String name) ：一个已经打开的输入流，传入Resource的名称</li>
<li>public void addResource(Configuration conf) ： Configuration对象</li>
</ul>
<ul>
<li>资源加载</li>
</ul>
<p>资源加载通过对象的addResource()方法或类的静态addDefaultResource()方法添加到Configuration对象中，添加的资源不会被立即加载，而是通过reloadConfiguration()方法清空properties和finalParameters。</p>
<p>静态方法addDefaultResource()也能清空Configuration对象中的数据，这是通过静态成员REGISTRY作为媒介进行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResource</span><span class="params">(InputStream in, String name)</span> </span>&#123;</span><br><span class="line">  addResourceObject(<span class="keyword">new</span> Resource(in, name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reloadConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  properties = <span class="keyword">null</span>;                            <span class="comment">// trigger reload</span></span><br><span class="line">  finalParameters.clear();                      <span class="comment">// clear site-limits</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addResourceObject</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">  resources.add(resource);                      <span class="comment">// add to resources</span></span><br><span class="line">  reloadConfiguration();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addDefaultResource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!defaultResources.contains(name)) &#123;</span><br><span class="line">    defaultResources.add(name);</span><br><span class="line">    <span class="keyword">for</span>(Configuration conf : REGISTRY.keySet()) &#123;</span><br><span class="line">      <span class="keyword">if</span>(conf.loadDefaults) &#123;</span><br><span class="line">        conf.reloadConfiguration();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成员变量properties中的数据，直到需要的时候才会加载进来，在getProps()方法中，如果发现properties为空，将触发loadResource()方法加载配置资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Properties <span class="title">getProps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (properties == <span class="keyword">null</span>) &#123;</span><br><span class="line">      properties = <span class="keyword">new</span> Properties();</span><br><span class="line">      HashMap&lt;String, String[]&gt; backup =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;String, String[]&gt;(updatingResource);</span><br><span class="line">      loadResources(properties, resources, quietmode);</span><br><span class="line">      <span class="keyword">if</span> (overlay!= <span class="keyword">null</span>) &#123;</span><br><span class="line">        properties.putAll(overlay);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Object,Object&gt; item: overlay.entrySet()) &#123;</span><br><span class="line">          String key = (String)item.getKey();</span><br><span class="line">          updatingResource.put(key, backup.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> properties;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="XML处理"><a href="#XML处理" class="headerlink" title="XML处理"></a>XML处理</h2><p>Hadoop的配置文件都是XML的形式，JAXP(Java API for XML Processing)是一种稳定的、可靠的XML处理API，支持SAX(Simple API for XML)和DOM(Document Object Model)两种XML处理方法。</p>
<p>SAX提供了一种流式的、时间驱动的XML处理方式，但是编写逻辑比较复杂，比较适合处理大的XML文件。</p>
<p>DOM和SAX不同，期工作方式是：首先将XML文档一次性的装入内存；然后根据文档中定义的元素和属性在内存中创建一个”树形结构”，也就是一个文档对象模型，将文档对象化，文档中每个节点对应着模型中一个对象；然后使用对象提供的编程接口，访问XML文档进而操作XML文档。由于Hadoop的配置文件都是很小的文件，因此Configuration使用DOM处理XML。</p>
<p>DOM加载部分的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Resource <span class="title">loadResource</span><span class="params">(Properties properties, Resource wrapper, <span class="keyword">boolean</span> quiet)</span> </span>&#123;</span><br><span class="line">    String name = UNKNOWN_RESOURCE;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Object resource = wrapper.getResource();</span><br><span class="line">      name = wrapper.getName();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 得到用于创建DOM解析器的工厂</span></span><br><span class="line">      DocumentBuilderFactory docBuilderFactory</span><br><span class="line">        = DocumentBuilderFactory.newInstance();</span><br><span class="line">      <span class="comment">//忽略xml中的注释</span></span><br><span class="line">      docBuilderFactory.setIgnoringComments(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//提供对XML名称空间的支持，允许xml中的Include机制</span></span><br><span class="line">      docBuilderFactory.setNamespaceAware(<span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          docBuilderFactory.setXIncludeAware(<span class="keyword">true</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (UnsupportedOperationException e) &#123;</span><br><span class="line">        LOG.error(<span class="string">"Failed to set setXIncludeAware(true) for parser "</span></span><br><span class="line">                + docBuilderFactory</span><br><span class="line">                + <span class="string">":"</span> + e,</span><br><span class="line">                e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取解析XML的DocumentBuilder对象</span></span><br><span class="line">      DocumentBuilder builder = docBuilderFactory.newDocumentBuilder();</span><br><span class="line">      Document doc = <span class="keyword">null</span>;</span><br><span class="line">      Element root = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">boolean</span> returnCachedProperties = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据不同资源，做预处理并调用相应形式的DocumentBuilder.parse</span></span><br><span class="line">      <span class="keyword">if</span> (resource <span class="keyword">instanceof</span> URL) &#123;                  <span class="comment">// an URL resource</span></span><br><span class="line">        doc = parse(builder, (URL)resource);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource <span class="keyword">instanceof</span> String) &#123;        <span class="comment">// a CLASSPATH resource</span></span><br><span class="line">        URL url = getResource((String)resource);</span><br><span class="line">        doc = parse(builder, url);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource <span class="keyword">instanceof</span> Path) &#123;          <span class="comment">// a file resource</span></span><br><span class="line">        <span class="comment">// Can't use FileSystem API or we get an infinite loop</span></span><br><span class="line">        <span class="comment">// since FileSystem uses Configuration API.  Use java.io.File instead.</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(((Path)resource).toUri().getPath())</span><br><span class="line">          .getAbsoluteFile();</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!quiet) &#123;</span><br><span class="line">            LOG.debug(<span class="string">"parsing File "</span> + file);</span><br><span class="line">          &#125;</span><br><span class="line">          doc = parse(builder, <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">              <span class="keyword">new</span> FileInputStream(file)), ((Path)resource).toString());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource <span class="keyword">instanceof</span> InputStream) &#123;</span><br><span class="line">        doc = parse(builder, (InputStream) resource, <span class="keyword">null</span>);</span><br><span class="line">        returnCachedProperties = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource <span class="keyword">instanceof</span> Properties) &#123;</span><br><span class="line">        overlay(properties, (Properties)resource);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">        root = (Element)resource;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// root 获取文档元素</span></span><br><span class="line">      <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (doc == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (quiet) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(resource + <span class="string">" not found"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        root = doc.getDocumentElement();</span><br><span class="line">      &#125;</span><br><span class="line">      Properties toAddTo = properties;</span><br><span class="line">      <span class="keyword">if</span>(returnCachedProperties) &#123;</span><br><span class="line">        toAddTo = <span class="keyword">new</span> Properties();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//确保根节点是configuration</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="string">"configuration"</span>.equals(root.getTagName()))</span><br><span class="line">        LOG.fatal(<span class="string">"bad conf file: top-level element not &lt;configuration&gt;"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//获取根节点的所有子节点</span></span><br><span class="line">      NodeList props = root.getChildNodes();</span><br><span class="line">      DeprecationContext deprecations = deprecationContext.get();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; props.getLength(); i++) &#123;</span><br><span class="line">        Node propNode = props.item(i);</span><br><span class="line">        <span class="keyword">if</span> (!(propNode <span class="keyword">instanceof</span> Element))  <span class="comment">// 如果子节点不是Element,忽略</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        Element prop = (Element)propNode;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"configuration"</span>.equals(prop.getTagName())) &#123;</span><br><span class="line">          <span class="comment">// 如果子节点是configuration，递归调用loadResource进行处理</span></span><br><span class="line">          <span class="comment">// 这意味着configuration的子节点可以是configuration</span></span><br><span class="line">          loadResource(toAddTo, <span class="keyword">new</span> Resource(prop, name), quiet);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子节点是property</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">"property"</span>.equals(prop.getTagName()))</span><br><span class="line">          LOG.warn(<span class="string">"bad conf file: element not &lt;property&gt;"</span>);</span><br><span class="line">        NodeList fields = prop.getChildNodes();</span><br><span class="line">        String attr = <span class="keyword">null</span>;</span><br><span class="line">        String value = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> finalParameter = <span class="keyword">false</span>;</span><br><span class="line">        LinkedList&lt;String&gt; source = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找name、value、final的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; fields.getLength(); j++) &#123;</span><br><span class="line">          Node fieldNode = fields.item(j);</span><br><span class="line">          <span class="keyword">if</span> (!(fieldNode <span class="keyword">instanceof</span> Element))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          Element field = (Element)fieldNode;</span><br><span class="line">          <span class="keyword">if</span> (<span class="string">"name"</span>.equals(field.getTagName()) &amp;&amp; field.hasChildNodes())</span><br><span class="line">            attr = StringInterner.weakIntern(</span><br><span class="line">                ((Text)field.getFirstChild()).getData().trim());</span><br><span class="line">          <span class="keyword">if</span> (<span class="string">"value"</span>.equals(field.getTagName()) &amp;&amp; field.hasChildNodes())</span><br><span class="line">            value = StringInterner.weakIntern(</span><br><span class="line">                ((Text)field.getFirstChild()).getData());</span><br><span class="line">          <span class="keyword">if</span> (<span class="string">"final"</span>.equals(field.getTagName()) &amp;&amp; field.hasChildNodes())</span><br><span class="line">            finalParameter = <span class="string">"true"</span>.equals(((Text)field.getFirstChild()).getData());</span><br><span class="line">          <span class="keyword">if</span> (<span class="string">"source"</span>.equals(field.getTagName()) &amp;&amp; field.hasChildNodes())</span><br><span class="line">            source.add(StringInterner.weakIntern(</span><br><span class="line">                ((Text)field.getFirstChild()).getData()));</span><br><span class="line">        &#125;</span><br><span class="line">        source.add(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ignore this parameter if it has already been marked as 'final'</span></span><br><span class="line">        <span class="comment">// 替换弃用key,忽略finalParameter</span></span><br><span class="line">        <span class="keyword">if</span> (attr != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (deprecations.getDeprecatedKeyMap().containsKey(attr)) &#123;</span><br><span class="line">            DeprecatedKeyInfo keyInfo =</span><br><span class="line">                deprecations.getDeprecatedKeyMap().get(attr);</span><br><span class="line">            keyInfo.clearAccessed();</span><br><span class="line">            <span class="keyword">for</span> (String key:keyInfo.newKeys) &#123;</span><br><span class="line">              <span class="comment">// update new keys with deprecated key's value</span></span><br><span class="line">              loadProperty(toAddTo, name, key, value, finalParameter,</span><br><span class="line">                  source.toArray(<span class="keyword">new</span> String[source.size()]));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            loadProperty(toAddTo, name, attr, value, finalParameter,</span><br><span class="line">                source.toArray(<span class="keyword">new</span> String[source.size()]));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (returnCachedProperties) &#123;</span><br><span class="line">        overlay(properties, toAddTo);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Resource(toAddTo, name);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      LOG.fatal(<span class="string">"error parsing conf "</span> + name, e);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DOMException e) &#123;</span><br><span class="line">      LOG.fatal(<span class="string">"error parsing conf "</span> + name, e);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SAXException e) &#123;</span><br><span class="line">      LOG.fatal(<span class="string">"error parsing conf "</span> + name, e);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ParserConfigurationException e) &#123;</span><br><span class="line">      LOG.fatal(<span class="string">"error parsing conf "</span> + name , e);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 载入属性</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadProperty</span><span class="params">(Properties properties, String name, String attr,</span><br><span class="line">      String value, <span class="keyword">boolean</span> finalParameter, String[] source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!finalParameters.contains(attr)) &#123;</span><br><span class="line">        properties.setProperty(attr, value);</span><br><span class="line">        updatingResource.put(attr, source);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!value.equals(properties.getProperty(attr))) &#123;</span><br><span class="line">        LOG.warn(name+<span class="string">":an attempt to override final parameter: "</span>+attr</span><br><span class="line">            +<span class="string">";  Ignoring."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (finalParameter) &#123;</span><br><span class="line">      finalParameters.add(attr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop源码学习(2)——Hadoop-Common-Annotations]]></title>
      <url>http://keyunluo.github.io/2016/08/02/2016-08-02-hadoop-common--annotation.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>本节学习Hadoop-Common-Project中的hadoop-annotation模块，该模块主要实现了hadoop项目中的注解。</p>
</blockquote>
<a id="more"></a>
<h2 id="hadoop-annotations-源代码结构"><a href="#hadoop-annotations-源代码结构" class="headerlink" title="hadoop-annotations 源代码结构"></a>hadoop-annotations 源代码结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">└── main</span><br><span class="line">    ├── java</span><br><span class="line">    │   └── org</span><br><span class="line">    │       └── apache</span><br><span class="line">    │           └── hadoop</span><br><span class="line">    │               └── classification</span><br><span class="line">    │                   ├── InterfaceAudience.java</span><br><span class="line">    │                   ├── InterfaceStability.java</span><br><span class="line">    │                   └── tools</span><br><span class="line">    │                       ├── ExcludePrivateAnnotationsJDiffDoclet.java</span><br><span class="line">    │                       ├── ExcludePrivateAnnotationsStandardDoclet.java</span><br><span class="line">    │                       ├── IncludePublicAnnotationsStandardDoclet.java</span><br><span class="line">    │                       ├── package-info.java</span><br><span class="line">    │                       ├── RootDocProcessor.java</span><br><span class="line">    │                       └── StabilityOptions.java</span><br><span class="line">    └── main34.iml</span><br><span class="line"></span><br><span class="line">7 directories, 9 files</span><br></pre></td></tr></table></figure>
<h2 id="org-apache-hadoop-classification"><a href="#org-apache-hadoop-classification" class="headerlink" title="org.apache.hadoop.classification"></a>org.apache.hadoop.classification</h2><p>该包内有两个类<code>InterfaceAudience</code>和<code>InterfaceStability</code>，分别是观众接口和稳定性接口。</p>
<ul>
<li>类<code>InterfaceAudience</code>：</li>
</ul>
<p>本注解告诉用户一个包，类，方法的认定的受众</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被任何项目或应用使用的，public</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Public &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅被注解指定的项目使用，例如”Common“，”HDFS“，”Zookeeper"等</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LimitedPrivate &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅被hadoop自身使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Private &#123;&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>类<code>InterfaceStability</code>：</li>
</ul>
<p>本注解告诉用户随着时间改变如何依赖一个特定的包，类或方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于一个小版本发布能够发展并保持兼容性，仅在大版本(m.0)发布时会破坏兼容性</span></span><br><span class="line"> <span class="keyword">public</span> <span class="meta">@interface</span> Stable &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 能够发展，但在小版本(m.x)发布时能破坏兼容性</span></span><br><span class="line"> <span class="keyword">public</span> <span class="meta">@interface</span> Evolving &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对任何级别的发布粒度都不能保证可靠性和稳定性</span></span><br><span class="line">  <span class="keyword">public</span> <span class="meta">@interface</span> Unstable &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="org-apache-hadoop-classification-tools"><a href="#org-apache-hadoop-classification-tools" class="headerlink" title="org.apache.hadoop.classification.tools"></a>org.apache.hadoop.classification.tools</h2><p>该包定义了一些Javadoc设置能被指定项目使用：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InterfaceAudience</span>.LimitedPrivate(&#123;<span class="string">"Common"</span>, <span class="string">"Avro"</span>, <span class="string">"Chukwa"</span>, <span class="string">"HBase"</span>, <span class="string">"HDFS"</span>,</span><br><span class="line">  <span class="string">"Hive"</span>, <span class="string">"MapReduce"</span>, <span class="string">"Pig"</span>, <span class="string">"ZooKeeper"</span>&#125;)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>ExcludePrivateAnnotationsStandardDoclet：排除被注解为Private或LimitedPrivate的元素，它委托至标准的Doclet(指定Javadoc工具的输出内容和格式),并采用相同的选项。</p>
</li>
<li><p>ExcludePrivateAnnotationsJDiffDoclet：排除被注解为Private或LimitedPrivate的元素，它委托至JDiff的Doclet(指定Javadoc工具的输出内容和格式),并采用相同的选项。</p>
</li>
<li><p>IncludePublicAnnotationsStandardDoclet：仅包括被Public注解修饰的类级别的元素，类级别的没有使用注解的被排除在外，此外，所有被标记为Private，LimitedPrivate的元素都被排除在外，它委托至标准的Doclet(指定Javadoc工具的输出内容和格式),并采用相同的选项。</p>
</li>
<li><p>RootDocProcessor：通过嵌套的排除Private和LimitedPrivate注解的元素的代理对象来处理替换Rootdoc。基于 <a href="http://www.sixlegs.com/blog/java/exclude-javadoc-tag.html" target="_blank" rel="external">http://www.sixlegs.com/blog/java/exclude-javadoc-tag.html</a> 上的代码。</p>
</li>
<li><p>StabilityOptions：稳定性选项:”-stable”,”-evolving”,”-unstable”。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中的注解(2)]]></title>
      <url>http://keyunluo.github.io/2016/08/02/2016-08-02-java-annotation-2.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>JDK除了在java.lang下提供了5个基本的Annotation之外，还在java.lang.annotation包下提供了6个Meta Annotation，其中有五个元Annotation都用于修饰其他Annotation定义。</p>
</blockquote>
<a id="more"></a>
<h2 id="使用-Retention"><a href="#使用-Retention" class="headerlink" title="使用@Retention"></a>使用@Retention</h2><p>@Retention只能用于修饰Annotation定义，用于指定被修饰的Annotation可以保留多长时间，@Retention包含一个RetentionPolicy类型的value成员变量，所以使用@Retention时必须为该value成员变量指定值。</p>
<p>value成员变量的值只能是如下三个：</p>
<ul>
<li>RetentionPolicy.CLASS ：编译器将把Annotation记录在class文件中。当运行Java程序时，JVM不可获取Annotation信息，这是默认值。</li>
<li>RetentionPolicy.RUNTIME :编译器将把Annotation记录在class文件中，当运行Java程序时，JVM也可以获取Annotation信息，程序通过反射获取该Annotation信息。</li>
<li>RetentionPolicy.SOURCE ： Annotation只保留在源代码中，编译器将直接丢弃这种Annotation。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义下面的Testable Annotation保留到运行时</span></span><br><span class="line"><span class="meta">@Retention</span>(</span><br><span class="line">value=RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Testable&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用注解时只需要为value成员变量指定值，则使用该注解时可以直接在该注释后面的括号里指定value成员变量的值，无需使用“value=变量值”的形式。因此，上面的例子中可省略<code>value=</code>。</p>
<h2 id="使用-Target"><a href="#使用-Target" class="headerlink" title="使用@Target"></a>使用@Target</h2><p>@Target也只能修饰一个Annotation定义，它用于指定被修饰的Annotation能用于修饰哪些程序单元。@Target元Annotation也包含一个value的成员变量，该成员变量的值只能是如下几个：</p>
<ul>
<li>ElementType.ANNOTATION_TYPE:指定该策略的Annotation只能修饰Annotation。</li>
<li>ElementType.CONSTRUCTOR:指定该策略的Annotation只能修饰构造器。</li>
<li>ElementType.FIELD: 指定该策略的Annotation只能修饰成员变量。</li>
<li>ElementType.LOCAL_VARIABLE:指定该策略的Annotation只能修饰局部变量。</li>
<li>ElementType.METHOD:指定该策略的Annotation只能修饰方法定义。</li>
<li>ElementType.PACKAGE:指定该策略的Annotation只能修饰包定义。</li>
<li>ElementType.PARAMETER:指定该策略的Annotation可以修饰参数。</li>
<li>ElementType.TYPE:指定该策略的Annotation可以修饰类，接口(包括注解类型)或枚举定义。</li>
</ul>
<p>与使用@Retention类似，使用@Target也可以直接在括号里指定value的值，而无需使用name=value的形式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ActionListenerFor&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-Documented"><a href="#使用-Documented" class="headerlink" title="使用@Documented"></a>使用@Documented</h2><p>@Documented用于指定被该元Annotation修饰的Annotation类将被javadoc等工具提取成文档，如果定义Annotation类时使用了@Documented修饰，则所有使用该Annotation修饰的程序元素的API文档中将会包含该Annotation说明。</p>
<p>下面的代码定义了一个Testable Annotation，程序使用@Documented来修饰@Testable Annotation定义，所以该Annotation将被javadoc工具所提取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="comment">// 定义Testable Annotation将被javadoc工具提取</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Testable&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中指定了javadoc工具生成的API文档将提取@Testable的使用信息。下面的代码定义了一个MyTest类，该类中的info()方法使用了@Testable修饰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span></span>&#123;</span><br><span class="line">    <span class="comment">// 使用@testable修饰info()方法</span></span><br><span class="line">    <span class="meta">@Testable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"info方法..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-Inherited"><a href="#使用-Inherited" class="headerlink" title="使用@Inherited"></a>使用@Inherited</h2><p>@Inherited元Annotation指定被它修饰的Annotation将具有继承性——如果某个类使用了@Xxx注解(定义该Annotation时使用了@Inherited修饰)修饰，则其子类将自动被@Xxx修饰。</p>
<p>下面使用@Inherited元Annotation修饰@Inherited定义，则该Annotation将具有继承性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Inheritable&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的程序代码表明@Inheritable具有继承性，如果某个类使用了@Inheritable修饰，则该类的子类将自动使用@Inheritable修饰。</p>
<p>下面程序中定义了一个Base基类，该基类使用了@Inheritable修饰，则Base类的子类将会默认使用@Inheritable修饰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用@Inheritable修饰的Base类</span></span><br><span class="line"><span class="meta">@Inheritable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InheritableTest类只是继承了Base类</span></span><br><span class="line"><span class="comment">// 并未直接使用@Inheritable Annotation修饰</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableTest</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 打印InheritableTest类是否具有@Inheritable修饰</span></span><br><span class="line">    System.out.prinln(InheritableTest.class.isAnnotationPresent(Inheritable.class));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的程序会输出：true。</p>
<h2 id="自定义Annotation"><a href="#自定义Annotation" class="headerlink" title="自定义Annotation"></a>自定义Annotation</h2><p>定义新的Annotation类型使用@interface关键字，定义一个新的Annotation类型与定义一个接口非常像：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个简单的Annotation类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了该Annotation后，就可以在程序的任何地方使用该Annotation，使用Annotation的语法非常类似于public，final这样的修饰符，通常可以用来修饰程序中的类，方法，变量，接口等定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Test修饰类的定义</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在默认情况下，Annotation可用于修饰任何程序元素，包括类，接口，方法等，如下程序使用@Test来修饰方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">    <span class="comment">// 使用@Test Annotation修饰方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Annotation还可以带成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTag&#123;</span><br><span class="line">    <span class="comment">// 定义带两个成员变量的Annotation</span></span><br><span class="line">    <span class="comment">// Annotation中的成员变量以方法的形式定义</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span>；</span><br><span class="line">    <span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦在Annotation中定义了成员变量后，使用该Annotation时就应该为该Annotation的成员变量指定值，如下面的代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="comment">// 使用带成员变量的Annotation时，需要为成员变量赋值</span></span><br><span class="line">    <span class="meta">@MyTag</span>(name=<span class="string">"xx"</span>,age=<span class="number">6</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以在定义Annotation的成员变量时为其指定初始值（默认值），可以使用default关键字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTag&#123;</span><br><span class="line">    <span class="comment">// 定义带两个成员变量的Annotation</span></span><br><span class="line">    <span class="comment">// Annotation中的成员变量以方法的形式定义</span></span><br><span class="line">    <span class="comment">// 使用default为两个成员变量指定初始值</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "Mike"；</span><br><span class="line">    <span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 24</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果为Annotation的成员变量指定了默认值，使用Annotation时则可以不为这些变量指定值，而是直接使用默认值。</p>
<p>通常把没有定义成员变量的Annotation类型称为标记，把包含成员变量的Annotation称为元数据Annotation。</p>
<h2 id="提取Annotation信息"><a href="#提取Annotation信息" class="headerlink" title="提取Annotation信息"></a>提取Annotation信息</h2><p>使用了Annotation修饰了类，方法，成员变量后，这些Annotation不会自己生效，必须由开发者提供相应的工具来提取并处理Annotation信息。</p>
<p>java.lang.reflect包下主要包含了一些实现反射功能的工具类，从JDK1.5开始，java.lang.reflect包所提供的反射API增加了读取运行时的Annotation能力，只有当定义Annotation时使用了@Retention(RetentionPolicy.RUNTIME)修饰，该Annotation才会在运行时可见，JVM才会在装载class文件是读取保存在class文件中Annotation。</p>
<p>Java 5 在java.lang.reflect包下新增了AnnotatedElement接口，该接口代表程序中可以接受注解的程序元素，主要包括Class，Constructor，Field，Method，Package等。AnnotatedElement接口是所有程序元素的父接口，所以程序通过反射获取了某几个类的AnnotatedElement对象后，程序就可以调用该对象的如下几个方法来访问Annotation信息：</p>
<ul>
<li><a extends="" annotation=""> A getAnnotation(Class<a> annotationClass):返回该程序元素上存在的，指定类型的注解，若不存在，返回null。</a></a></li>
<li><a extends="" annotation=""> A getDeclaredAnnotation(Class<a> annotationClass):这是Java8新增的方法，该方法尝试获取直接修饰该程序元素，指定类型的Annotation，若不存在，返回null。</a></a></li>
<li>Annotation[] getAnnotations():返回该程序元素上存在的所有注解。</li>
<li>Annotation[] getDeclaredAnnotations():返回直接修饰该程序元素的所有Annotation。</li>
<li>boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass):判断该程序元素上是否存在指定类型的注解。</li>
<li><a extends="" annotation=""> A[] getAnnotationsByType(Class<a> annotationClass):获取修饰该程序元素，指定类型的多个Annotation。</a></a></li>
<li><a extends="" annotation=""> A[] getDeclaredAnnotationsByType(Class<a> annotationClass):获取直接修饰该程序元素，指定类型的多个Annotation。</a></a></li>
</ul>
<p>Java8中可以在如下位置上使用Type Annotation“</p>
<ul>
<li>创建对象(使用new关键字)</li>
<li>类型转换</li>
<li>使用implements实现接口</li>
<li>使用throws声明抛出异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Test类的info方法的所有注解</span></span><br><span class="line">Annotation[] aArray =Class.forName(<span class="string">"Test"</span>).getMethod(<span class="string">"info"</span>).getAnnotations();</span><br><span class="line"><span class="keyword">for</span> ( Annotation an : aArray)&#123;</span><br><span class="line">    System.out.println(an);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java8新增的Type-Annotation"><a href="#Java8新增的Type-Annotation" class="headerlink" title="Java8新增的Type Annotation"></a>Java8新增的Type Annotation</h2><p>Java8为ElementType枚举增加了TYPE_PARAMETER,TYPE_USE两个枚举值，这样就允许定义枚举时使用@Target(ElementType.TYPE_USE)修饰，这种注解被称为Type Annotation(类型注解),Type Annotation可用在任何用到类型的地方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个简单的Type Annotation,不带任何成员变量</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE_USE)</span><br><span class="line"><span class="meta">@interface</span> NotNull&#123;&#125;</span><br><span class="line"><span class="comment">//定义类时使用Type Annotation</span></span><br><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeAnnotationTest</span> <span class="keyword">implements</span> @<span class="title">NotNull</span> /* <span class="keyword">implements</span>时使用<span class="title">Type</span> <span class="title">Annotation</span> */ <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="comment">//方法形参中使用Type Annotation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(@NotNull String[] args)</span></span><br><span class="line">    <span class="comment">// throws时使用Type Annotation</span></span><br><span class="line">    <span class="keyword">throws</span> @NotNull FileNotFoundException</span>&#123;</span><br><span class="line">    Object obj =<span class="string">"lovejava.org"</span>;</span><br><span class="line">    <span class="comment">//强制类型转换时使用Type Annotation</span></span><br><span class="line">    String str = (<span class="meta">@NotNull</span> String)obj;</span><br><span class="line">    <span class="comment">//创建对象时使用Type Annotation</span></span><br><span class="line">    Object win = <span class="keyword">new</span> <span class="meta">@NotNull</span> JFrame(<span class="string">"疯狂软件"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型中使用Type Annotation</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">foo</span><span class="params">(List&lt;@NotNull String &gt; info)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop源码学习(1)——Hadoop-Common-Project]]></title>
      <url>http://keyunluo.github.io/2016/08/01/2016-08-01-hadoop-common-project.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>Hadoop-Common-Project模块包括了一系列支撑其他Hadoop模块的公共工具，本系列文章从源代码的角度分析其实现。本文主要从总体上了解Hadoop-Common-Project模块。</p>
</blockquote>
<a id="more"></a>
<h2 id="Hadoop主要模块"><a href="#Hadoop主要模块" class="headerlink" title="Hadoop主要模块"></a>Hadoop主要模块</h2><ul>
<li><p>hadoop                       (主要的Hadoop模块)</p>
<ul>
<li>hadoop-project           (所有Hadoop Maven 模块的Parent POM，由以下部分组成：        )<ul>
<li>hadoop-project-dist      (Parent POM for modules that generate distributions.)</li>
<li>hadoop-annotations       (Generates the Hadoop doclet used to generated the Javadocs)</li>
<li>hadoop-assemblies        (Maven assemblies used by the different modules)</li>
<li>hadoop-common-project    (Hadoop Common)</li>
<li>hadoop-hdfs-project      (Hadoop HDFS)</li>
<li>hadoop-mapreduce-project (Hadoop MapReduce)</li>
<li>hadoop-tools             (Hadoop tools like Streaming, Distcp, etc.)</li>
<li>hadoop-dist              (Hadoop distribution assembler)</li>
</ul>
</li>
</ul>
</li>
<li><p>hadoop-2.6.4-src结构</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── BUILDING.txt</span><br><span class="line">├── dev-support</span><br><span class="line">├── hadoop-assemblies</span><br><span class="line">├── hadoop-client</span><br><span class="line">├── hadoop-common-project</span><br><span class="line">├── hadoop-dist</span><br><span class="line">├── hadoop-hdfs-project</span><br><span class="line">├── hadoop-main.iml</span><br><span class="line">├── hadoop-mapreduce-project</span><br><span class="line">├── hadoop-maven-plugins</span><br><span class="line">├── hadoop-minicluster</span><br><span class="line">├── hadoop-project</span><br><span class="line">├── hadoop-project-dist</span><br><span class="line">├── hadoop-tools</span><br><span class="line">├── hadoop-yarn-project</span><br><span class="line">├── LICENSE.txt</span><br><span class="line">├── NOTICE.txt</span><br><span class="line">├── pom.xml</span><br><span class="line">└── README.txt</span><br></pre></td></tr></table></figure>
<h2 id="Hadoop-Common-Project"><a href="#Hadoop-Common-Project" class="headerlink" title="Hadoop-Common-Project"></a>Hadoop-Common-Project</h2><ul>
<li>结构</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">├── dev-support：补丁等开发支持</span><br><span class="line">├── hadoop-annotations：Hadoop注解</span><br><span class="line">├── hadoop-auth：Hadoop授权</span><br><span class="line">├── hadoop-auth-examples：Hadoop授权例子</span><br><span class="line">├── hadoop-common：Hadoop Common模块</span><br><span class="line">├── hadoop-common-project.iml</span><br><span class="line">├── hadoop-kms：基于KeyProvider API的密钥管理服务器</span><br><span class="line">├── hadoop-minikdc：基于Apache Directory服务器迷你型密钥分发中心(KDC)，能够被嵌入到测试用例或作为一个独立的KDC从命令行使用</span><br><span class="line">├── hadoop-nfs：Hadoop NFS模块</span><br><span class="line">├── pom.xml</span><br><span class="line">└── target</span><br></pre></td></tr></table></figure>
<p>Hadoop-Common奠定了整个Hadoop项目的基石，其中hadoop-common是核心，IO、FS、HA、IPC、NET等构成了分布式系统的基础。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中的注解(1)]]></title>
      <url>http://keyunluo.github.io/2016/08/01/2016-08-01-java-annotation-1.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>从JDK1.5开始，Java增加了对元数据(MetaData)的支持，也就是Annotation。Annotation是代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并进行相应的处理。通过使用注解，程序开发人员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。</p>
</blockquote>
<a id="more"></a>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>Annotation提供了一种为程序元素设置元数据的方法，从某些方面来看，Annotation就像修饰符一样，可用于修饰包，类，构造器，方法，成员变量，参数，局部变量的声明，这些信息被存储在Annotation的”name=value”中。Annotation不影响程序代码的执行，无论增加或删除Annotation，代码都将始终如一的执行。若希望让程序中的Annotation在运行时起一定的作用，只有通过某种配套的工具对Annotation中的信息进行访问和处理，这种工具统称为APT(Annotation Processing Tool)。</p>
<p>Java中有5个基本Annotation，它们都定义在<code>java.lang</code>包下。使用Annotation时需要在其前面增加@符号，并把该Annotation当做一个修饰符使用。</p>
<ul>
<li>@Override</li>
<li>@Deprecated</li>
<li>@SupressWarnings</li>
<li>@SafeVarargs (Since Java7)</li>
<li>@FunctionalInterface (Since Java8)</li>
</ul>
<h2 id="限定重写父类方法：-Override"><a href="#限定重写父类方法：-Override" class="headerlink" title="限定重写父类方法：@Override"></a>限定重写父类方法：@Override</h2><p>@Override用来指定方法重载的，它可以强制一个子类必须覆盖父类的方法。@Override的作用是告诉编译器来检查这个方法，保证父类中的某个方法必须被重写，这样可以在编译阶段发现错误。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pulic <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"水果的info方法..."</span>)；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用@Override指定下面方法必须重写父类方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"苹果重写水果的Info方法..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="标记已过时：-Deprecated"><a href="#标记已过时：-Deprecated" class="headerlink" title="标记已过时：@Deprecated"></a>标记已过时：@Deprecated</h2><p>@Deprecated用来表示某个程序元素(类，方法等)已过时，当其他程序使用已过时的类，方法时，编译器将给出警告。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pulic <span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义info方法已过时</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"苹果的info方法..."</span>)；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//编译器将给出警告</span></span><br><span class="line">    <span class="keyword">new</span> Apple().info();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Deprecated的作用与文档注释中的@deprecated标记的作用基本相同，但它们的用法不同，前者是Java5才支持的注解，无需放到文档的注释部分，而是直接放到要修饰的方法，类，接口等。</p>
<h2 id="抑制编译器警告：-SuppressWarnings"><a href="#抑制编译器警告：-SuppressWarnings" class="headerlink" title="抑制编译器警告：@SuppressWarnings"></a>抑制编译器警告：@SuppressWarnings</h2><p>@SuppressWarnings指示被该Annotation修饰的程序元素(以及该程序元素中的所有子元素)取消显示指定的编译器警告。在通常情况下，如果程序中没有限定泛型限制的集合将会引起编译器警告，为了避免这种编译器警告，可以使用@SuppressWarning修饰。例如，下面的程序取消了没有使用泛型的编译器警告：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭整个类中的编译器警告</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(value=<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuppressWarningTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; mylist = <span class="keyword">new</span> ArrayList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java7中的”堆污染“警告与-SafeVarargs"><a href="#Java7中的”堆污染“警告与-SafeVarargs" class="headerlink" title="Java7中的”堆污染“警告与@SafeVarargs"></a>Java7中的”堆污染“警告与@SafeVarargs</h2><p>在泛型擦除时，如下代码可能导致运行时异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="number">20</span>);  <span class="comment">//添加元素时引发unchecked异常</span></span><br><span class="line"><span class="comment">// 下面的代码引起”未经检查的转换“的警告，编译，运行完全正常</span></span><br><span class="line">List&lt;String&gt; ls = list;</span><br><span class="line"><span class="comment">// 但只要访问ls里的元素，如下面的代码就会引起运行时的异常</span></span><br><span class="line">System.out.println(ls.get(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>Java把引发这种错误的原因称为”堆污染”(heap pollution),当把一个不带泛型的对象赋值给一个带泛型的变量时，往往就会发生这种堆污染现象。</p>
<p>对于形参个数可变的方法，该形参的类型又是泛型，将更容易导致”堆污染“，例如如下的工具类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorUtils</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">faultyMethod</span><span class="params">(List&lt;String&gt;... listStrArray)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Java语言不允许创建泛型数组，因此listArray只能被当成List[]处理</span></span><br><span class="line">    <span class="comment">//此时相当于把List&lt;String&gt;赋给了List，已经发生了”堆污染“</span></span><br><span class="line"></span><br><span class="line">    List[] listArray = listStrArray;</span><br><span class="line">    List&lt;Integer&gt; myList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    myList.add(<span class="keyword">new</span> Random().next(<span class="number">100</span>));</span><br><span class="line">    <span class="comment">//把listArray的第一个元素赋为myArray</span></span><br><span class="line">    listArray[<span class="number">0</span>] = myList;</span><br><span class="line">    String s = listArray[<span class="number">0</span>].get[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Java6以及更早的版本中，Java编译器认为faultyMethod()方法没有任何问题，等到使用该方法时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorUtilsTest</span></span>&#123;</span><br><span class="line">    <span class="function">publc <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    ErrorUtils.faultyMethod(Arrays.asList(<span class="string">"Hello"</span>),Arrays)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会引发一个unchecked警告，在运行时会引发ClassCastException异常。</p>
<p>从Java7开始，Java编译器进行更加严格的检查，在编译ErrorUtils时就会发出一个如下的警告：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ErrorUtils.java:<span class="number">15</span>:警告[unchecked] 参数化 varargs类型List&lt;String&gt;的堆可能已经受到污染</span><br></pre></td></tr></table></figure>
<p>但有些时候，开发者不希望看到这个警告，则可以使用如下三种方式来抑制这个警告：</p>
<ul>
<li>使用@SafeVarargs修饰引发该警告的方法或构造器。</li>
<li>使用@SuppressWarnings(“unchecked”)修饰。</li>
<li>编译时使用-Xlint:varargs选项。</li>
</ul>
<p>通常使用@SafeVarargs修饰，编译上述两个程序时都不会发出任何警告。</p>
<h2 id="Java8的函数式接口与-FunctionalInterface"><a href="#Java8的函数式接口与-FunctionalInterface" class="headerlink" title="Java8的函数式接口与@FunctionalInterface"></a>Java8的函数式接口与@FunctionalInterface</h2><p>Java8规定：如果接口中只有一个抽象方法（可以包含多个默认方法或多个static方法），该接口就是函数式接口。@FunctionalInterface就是用来指定某个接口必须是函数式接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionalInterface</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"foo类方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"bar默认方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;  <span class="comment">//只定义一个抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@FunctionalInterface告诉编译器检查这个接口，保证该接口只能包含一个抽象方法，否则就编译出错。如果再增加一个抽象方法abc()，则会编译出错：意外的@FunctionalInterface注释。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[搭建Cloudera集群]]></title>
      <url>http://keyunluo.github.io/2016/07/28/2016-07-28-cloudera-cluster.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>使用Cloudera Manager 5 利用镜像搭建Hadoop/Spark集群。</p>
</blockquote>
<a id="more"></a>
<h2 id="SSH-JDK"><a href="#SSH-JDK" class="headerlink" title="SSH,JDK"></a>SSH,JDK</h2><ul>
<li><p>配置ssh,使slave01能免密钥访问<code>slave02~slave10</code>,即将<code>slave01~slave10</code>的公钥<code>id_rsa.pub</code>添加到slave01的<code>~/.ssh/authorized_keys</code>中。</p>
</li>
<li><p><code>pip</code>设置代理</p>
</li>
</ul>
<p>编辑<code>~/.pip/pip.conf</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">global</span>]</span><br><span class="line">index-url = http://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">proxy  = http://server:<span class="number">8899</span></span><br><span class="line"></span><br><span class="line">[install]</span><br><span class="line">trusted-host=pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure>
<p>在root用户下拷贝pip设置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.pip</span><br><span class="line">cp /home/hadoop/.pip/pip.conf ~/.pip/</span><br></pre></td></tr></table></figure>
<ul>
<li>slave01安装pssh，pscp</li>
</ul>
<p>root用户下安装pssh： <code>pip install -U pssh</code></p>
<p>安装pscp:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=<span class="string">"http://server:8899/"</span></span><br><span class="line">export https_proxy=<span class="string">"http://server:8899/"</span></span><br><span class="line">git clone https://github.com/pssh/parallel-ssh</span><br><span class="line">cd parallel-ssh</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>
<ul>
<li>新建slaves文件</li>
</ul>
<p>新建一个<code>slaves</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">slave02</span><br><span class="line">slave03</span><br><span class="line">slave04</span><br><span class="line">slave05</span><br><span class="line">slave06</span><br><span class="line">slave07</span><br><span class="line">slave08</span><br><span class="line">slave09</span><br><span class="line">slave10</span><br></pre></td></tr></table></figure>
<ul>
<li>批量拷贝安装pscp</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pscp -h /home/hadoop/slaves -r parallel-ssh /home/hadoop/</span><br><span class="line">sudo pssh -h ~/slaves <span class="string">"cd /home/hadoop/parallel-ssh &amp;&amp; python setup.py install"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>批量安装JDK,并设置环境变量</li>
</ul>
<p>下载Oracle-JDK：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.oracle.com/otn-pub/java/jdk/8u102-b14/jdk-8u102-linux-x64.rpm?AuthParam=1469704553_712c2889a98a77ece53c26087d3ae902</span><br><span class="line">scp jdk-8u102-linux-x64.rpm\?AuthParam\=1469704553_712c2889a98a77ece53c26087d3ae902 hadoop@slave01:~/cloudera/jdk-8u102-linux-x64.rpm</span><br></pre></td></tr></table></figure>
<p>安装JDK</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh jdk<span class="number">-8</span>u102-linux-x64.rpm</span><br><span class="line">pscp -h /home/hadoop/slaves jdk<span class="number">-8</span>u102-linux-x64.rpm /home/hadoop/jdk<span class="number">-8</span>u102-linux-x64.rpm</span><br><span class="line">pssh -h /home/hadoop/slaves <span class="string">"rpm -ivh /home/hadoop/jdk-8u102-linux-x64.rpm &amp;&amp; rm -f /home/hadoop/jdk-8u102-linux-x64.rpm"</span></span><br></pre></td></tr></table></figure>
<p>安装Scala:</p>
<p>root下：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://downloads.lightbend.com.sixxs.org/scala/<span class="number">2.11</span><span class="number">.8</span>/scala<span class="number">-2.11</span><span class="number">.8</span>.rpm</span><br><span class="line">rpm -ivh scala<span class="number">-2.11</span><span class="number">.8</span>.rpm</span><br><span class="line">pscp -h /home/hadoop/slaves scala<span class="number">-2.11</span><span class="number">.8</span>.rpm /home/hadoop/</span><br><span class="line">pssh -h /home/hadoop/slaves <span class="string">"rpm -ivh /home/hadoop/scala-2.11.8.rpm"</span></span><br><span class="line">pssh -h /home/hadoop/slaves <span class="string">"rm -f /home/hadoop/scala-2.11.8.rpm"</span></span><br></pre></td></tr></table></figure></p>
<p>设置环境变量</p>
<p><code>sudo vim /etc/profile.d/cloudera.sh</code>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/default</span><br><span class="line">export SCALA_HOME=/usr/share/scala</span><br><span class="line">export M2_HOME=/usr/local/maven</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$SCALA_HOME/lib</span><br><span class="line">export PATH=$JAVA_HOME/bin:$SCALA_HOME/bin:$M2_HOME/bin:$PATH</span><br></pre></td></tr></table></figure></p>
<p>复制到其他节点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pscp -h /home/hadoop/slaves /etc/profile.d/cloudera.sh /etc/profile.d/cloudera.sh</span><br><span class="line">pssh -h /home/hadoop/slaves <span class="string">"source /etc/profile"</span></span><br></pre></td></tr></table></figure>
<h2 id="安装Cloudera"><a href="#安装Cloudera" class="headerlink" title="安装Cloudera"></a>安装Cloudera</h2><ul>
<li>配置Cloudera源</li>
</ul>
<p><code>vim /etc/yum.repos.d/Cloudera.repo</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[cloudera-manager]</span><br><span class="line"><span class="comment"># Packages for Cloudera Manager, Version 5, on RedHat or CentOS 7 x86_64</span></span><br><span class="line">name=Cloudera Manager</span><br><span class="line">baseurl=http://<span class="number">192.168</span><span class="number">.80</span><span class="number">.80</span>/cm5/redhat/<span class="number">7</span>/x86_64/cm/<span class="number">5</span>/</span><br><span class="line">gpgkey =http://<span class="number">192.168</span><span class="number">.80</span><span class="number">.80</span>/cm5/redhat/<span class="number">7</span>/x86_64/cm/RPM-GPG-KEY-cloudera</span><br><span class="line">gpgcheck = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>复制到集群的其他节点上：<code>pscp -h /home/hadoop/slaves /etc/yum.repos.d/Cloudera.repo /etc/yum.repos.d/</code>,更新缓存：<code>pssh -h /home/hadoop/slaves &quot;yum clean all;yum makecache&quot;</code>.</p>
<p>导入key:<code>rpm --import http://archive.cloudera.com/cm5/redhat/7/x86_64/cm/RPM-GPG-KEY-cloudera</code></p>
<p>在一个合适的目录下执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://<span class="number">192.168</span><span class="number">.80</span><span class="number">.80</span>/cm5/installer/latest/cloudera-manager-installer.bin</span><br><span class="line">sudo chmod +x cloudera-manager-installer.bin</span><br><span class="line">sudo ./cloudera-manager-installer.bin</span><br></pre></td></tr></table></figure>
<p><strong>保证sudo无密码访问</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chmod u+w /etc/sudoers</span></span><br><span class="line">grid ALL=(root)NOPASSWD:ALL</span><br><span class="line">cloudera-scm  ALL=(ALL)  ALL</span><br><span class="line"><span class="comment"># chmod u-w /etc/sudoers</span></span><br></pre></td></tr></table></figure>
<p>一路点确定后就安装好了，点击<code>http://slave01:7180/cmf/login</code>就可以登录，默认用户名和密码都是<code>admin</code>.</p>
<p>选择Express版本：
<img src="/resource/blog/2016-07/Cloudera.png" alt="版本">
选择机器：
<img src="/resource/blog/2016-07/Cloudera-Host.png" alt="机器">
选择Parcel：
<img src="/resource/blog/2016-07/Cloudera-Parcel.png" alt="Parcel">
选择集群CDH：
<img src="/resource/blog/2016-07/Cloudera-Cluster.png" alt="CDH">
不选择单用户模式：
安装界面：
<img src="/resource/blog/2016-07/Cloudera-Install.png" alt="Install">
检查，提示警告：<code>echo never &gt; /sys/kernel/mm/transparent_hugepage/defrag</code>
安装所有服务：
<img src="/resource/blog/2016-07/Cloudera-Service.png" alt="服务">
集群分配：
<img src="/resource/blog/2016-07/Cloudera-Configure.png" alt="Configure">
接下来是数据库配置，<strong>自己手动记录用户名和密码</strong>。
接着是集群安装，最后安装成功如下：
<img src="/resource/blog/2016-07/Cloudera-Final.png" alt="安装成功"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[搭建Cloudera离线parcel源]]></title>
      <url>http://keyunluo.github.io/2016/07/28/2016-07-28-cloudera-repo.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>Cloudera外网访问速度比较慢，并且服务器集群内部访问外网比较麻烦，因此在外网服务器中搭建Cloudera源，供安装使用。</p>
</blockquote>
<a id="more"></a>
<h2 id="配置网卡静态地址"><a href="#配置网卡静态地址" class="headerlink" title="配置网卡静态地址"></a>配置网卡静态地址</h2><p>外网服务器有五块网卡，eth0连接外网，eth2连接内网，这里配置eth1,对外界访问隔离：设置地址为<code>192.168.80.80</code>,编辑<code>/etc/network/interfaces</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">iface eth1 inet static</span><br><span class="line">address <span class="number">192.168</span><span class="number">.80</span><span class="number">.80</span></span><br><span class="line">netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">gateway <span class="number">192.168</span><span class="number">.80</span><span class="number">.2</span></span><br></pre></td></tr></table></figure>
<h2 id="集群配置网络"><a href="#集群配置网络" class="headerlink" title="集群配置网络"></a>集群配置网络</h2><ul>
<li>关闭SELINUX</li>
</ul>
<p>编辑 <code>sudo vim /etc/selinux/config</code>，修改为 <code>SELINUX=disabled</code>,然后重启。</p>
<ul>
<li>修改host</li>
</ul>
<p>编辑 <code>/etc/hosts</code>,添加一行<code>192.168.80.80   archive.cloudera.com</code></p>
<h2 id="配置Cloudera镜像"><a href="#配置Cloudera镜像" class="headerlink" title="配置Cloudera镜像"></a>配置Cloudera镜像</h2><p>参考(cloudera_mirror)[<a href="https://github.com/sskaje/cloudera_mirror],搭建Cloudera镜像。" target="_blank" rel="external">https://github.com/sskaje/cloudera_mirror],搭建Cloudera镜像。</a></p>
<ul>
<li>建立目录</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/repo/cloudera_mirror</span><br></pre></td></tr></table></figure>
<ul>
<li>安装PHP</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php5 php5-gd php5-cli</span><br></pre></td></tr></table></figure>
<ul>
<li>新建<code>fixlink.php</code>，固定链接</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$domain = <span class="string">'archive.cloudera.com.sixxs.org'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>($argv[<span class="number">1</span>])) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&#123;$argv[0]&#125; cm4|cm5 \n"</span>;</span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($argv[<span class="number">1</span>] == <span class="string">'cm4'</span>) &#123;</span><br><span class="line">    $path = <span class="string">'/cm4/redhat/7/x86_64/cm/'</span>;</span><br><span class="line">    $compare_with = <span class="string">'4'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ($argv[<span class="number">1</span>] == <span class="string">'cm5'</span>) &#123;</span><br><span class="line">    $path = <span class="string">'/cm5/redhat/7/x86_64/cm/'</span>;</span><br><span class="line">    $compare_with = <span class="string">'5'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$web_contents = file_get_contents(<span class="string">'http://'</span> . $domain . $path);</span><br><span class="line">preg_match_all(<span class="string">'#&lt;a href="([\d\.a-z\-]+)/"&gt;([\d\.a-z\-]+)/&lt;/a&gt;#'</span>, $web_contents, $m);</span><br><span class="line"></span><br><span class="line">@chdir(<span class="keyword">__DIR__</span> . <span class="string">'/'</span> . $domain . $path);</span><br><span class="line"><span class="keyword">foreach</span> ($m[<span class="number">2</span>] <span class="keyword">as</span> $k=&gt;$v) &#123;</span><br><span class="line">    <span class="keyword">if</span> ($v === $compare_with || strpos($v, $compare_with) === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    $name = $v;</span><br><span class="line">    @unlink($name);</span><br><span class="line">    symlink($compare_with, $name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>新建<code>clear_outdated.php</code>,获得更新</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>($argv[<span class="number">1</span>]) || (!preg_match(<span class="string">'#^http://archive.cloudera.com.sixxs.org/.+/parcels/latest/$#'</span>, $argv[<span class="number">1</span>]) &amp;&amp; !preg_match(<span class="string">'#^http://archive.cloudera.com.sixxs.org/cm#'</span>, $argv[<span class="number">1</span>]))) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&lt;&lt;&lt;USAGE</span><br><span class="line"><span class="subst">&#123;$argv[0]&#125;</span> URL</span><br><span class="line">        URL should be like:</span><br><span class="line">                http://archive.cloudera.com.sixxs.org/PRODUCT/parcels/latest/</span><br><span class="line">                http://archive.cloudera.com/cm4/redhat/7/x86_64/cm/4/</span><br><span class="line">                http://archive.cloudera.com/cm5/redhat/7/x86_64/cm/5/</span><br><span class="line"></span><br><span class="line">USAGE;</span></span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$path = <span class="keyword">__DIR__</span> . <span class="string">'/'</span> . substr($argv[<span class="number">1</span>], strlen(<span class="string">'http://'</span>));</span><br><span class="line"><span class="keyword">if</span> (strpos($argv[<span class="number">1</span>], <span class="string">'parcels'</span>)) &#123;</span><br><span class="line">        $jsonfile = $path . <span class="string">'manifest.json'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!is_file($jsonfile)) &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">'manifest.json not found'</span>;</span><br><span class="line">                <span class="keyword">exit</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        $json = json_decode(file_get_contents($jsonfile), <span class="keyword">true</span>);</span><br><span class="line">        $parcels = <span class="keyword">array</span>();</span><br><span class="line">        <span class="keyword">foreach</span> ($json[<span class="string">'parcels'</span>] <span class="keyword">as</span> $p) &#123;</span><br><span class="line">                $parcels[] = $p[<span class="string">'parcelName'</span>];</span><br><span class="line">                $parcels[] = $p[<span class="string">'parcelName'</span>].<span class="string">'.sha1'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chdir($path);</span><br><span class="line">        $files = glob(<span class="string">'*'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> ($files <span class="keyword">as</span> $f) &#123;</span><br><span class="line">                <span class="keyword">if</span> ($f == <span class="string">'manifest.json'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (!in_array($f, $parcels)) &#123;</span><br><span class="line">                        <span class="keyword">echo</span> <span class="string">"Deleting outdated file &#123;$f&#125;...\n"</span>;</span><br><span class="line">                        unlink($f);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        chdir($path);</span><br><span class="line">        $files = glob(<span class="string">'*'</span>);</span><br><span class="line"></span><br><span class="line">        $tree = <span class="keyword">array</span>();</span><br><span class="line">        <span class="keyword">foreach</span> ($files <span class="keyword">as</span> $f) &#123;</span><br><span class="line">                preg_match(<span class="string">'#\d#'</span>, $f, $m, PREG_OFFSET_CAPTURE);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">isset</span>($m[<span class="number">0</span>][<span class="number">1</span>]) &amp;&amp; $m[<span class="number">0</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">                        $tree[substr($f, <span class="number">0</span>, $m[<span class="number">0</span>][<span class="number">1</span>])][] = $f;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> ($tree <span class="keyword">as</span> $f) &#123;</span><br><span class="line">                $keep = max($f);</span><br><span class="line">                <span class="keyword">foreach</span> ($f <span class="keyword">as</span> $_f) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ($_f != $keep) &#123;</span><br><span class="line">                                <span class="keyword">echo</span> <span class="string">"Removing file "</span>, $_f, <span class="string">"\n"</span>;</span><br><span class="line">                                unlink($_f);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>批量下载，新建<code>wget.sh</code>,使用<code>sixxs.org</code>加速</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">WGET=&quot;/usr/bin/wget -mc -e robots=off&quot;</span><br><span class="line">PHP=/usr/bin/php</span><br><span class="line">FIND=/usr/bin/find</span><br><span class="line">CURRENT_DIR=`dirname &quot;$0&quot;`</span><br><span class="line"></span><br><span class="line">PARCELS=(</span><br><span class="line">    &quot;http://archive.cloudera.com.sixxs.org/cdh5/parcels/latest/&quot;</span><br><span class="line">    &quot;http://archive.cloudera.com.sixxs.org/cdh5/parcels/5/&quot;</span><br><span class="line">    &quot;http://archive.cloudera.com.sixxs.org/gplextras5/parcels/latest/&quot;</span><br><span class="line">    &quot;http://archive.cloudera.com.sixxs.org/cm5/installer/latest/&quot;</span><br><span class="line">    &quot;http://archive.cloudera.com.sixxs.org/sqoop-connectors/parcels/latest/&quot;</span><br><span class="line">    &quot;http://archive.cloudera.com.sixxs.org/beta/impala-kudu/parcels/latest/&quot;</span><br><span class="line">    &quot;http://archive.cloudera.com.sixxs.org/beta/kudu/parcels/latest/&quot;</span><br><span class="line">    &quot;http://archive.cloudera.com.sixxs.org/cdh4/parcels/latest/&quot;</span><br><span class="line">    &quot;http://archive.cloudera.com.sixxs.org/search/parcels/latest/&quot;</span><br><span class="line">    &quot;http://archive.cloudera.com.sixxs.org/impala/parcels/latest/&quot;</span><br><span class="line">    &quot;http://archive.cloudera.com.sixxs.org/sentry/parcels/latest/&quot;</span><br><span class="line">    &quot;http://archive.cloudera.com.sixxs.org/gplextras/parcels/latest/&quot;</span><br><span class="line">    &quot;http://archive.cloudera.com.sixxs.org/spark/parcels/latest/&quot;</span><br><span class="line">    &quot;http://archive.cloudera.com.sixxs.org/accumulo/parcels/latest/&quot;</span><br><span class="line">    &quot;http://archive.cloudera.com.sixxs.org/cm4/installer/latest/&quot;</span><br><span class="line"></span><br><span class="line">    &quot;http://archive.cloudera.com.sixxs.org/accumulo-c5/parcels/latest/&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">function download_parcel()</span><br><span class="line">&#123;</span><br><span class="line">    $WGET  $1 --accept-regex=&apos;.*el7.*&apos;</span><br><span class="line">    $WGET  $1/manifest.json</span><br><span class="line">    $PHP clear_outdated.php $1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cd $CURRENT_DIR</span><br><span class="line"></span><br><span class="line">$WGET  http://archive.cloudera.com.sixxs.org/cm4/redhat/7/x86_64/cm/4/ --accept-regex=&apos;\/4\/&apos; #--reject-regex=&apos;index\.html&apos;</span><br><span class="line">$WGET  http://archive.cloudera.com.sixxs.org/cm4/installer/latest/cloudera-manager-installer.bin</span><br><span class="line">$WGET  http://archive.cloudera.com.sixxs.org/cm4/redhat/7/x86_64/cm/RPM-GPG-KEY-cloudera</span><br><span class="line">$WGET  http://archive.cloudera.com.sixxs.org/cm4/redhat/7/x86_64/cm/cloudera-manager.repo</span><br><span class="line">$PHP clear_outdated.php http://archive.cloudera.com.sixxs.org/cm4/redhat/7/x86_64/cm/4/RPMS/x86_64/</span><br><span class="line"></span><br><span class="line">$WGET  http://archive.cloudera.com.sixxs.org/cm5/redhat/7/x86_64/cm/5/ --accept-regex=&apos;\/5\/&apos; #--reject-regex=&apos;index\.html&apos;</span><br><span class="line">$WGET  http://archive.cloudera.com.sixxs.org/cm5/installer/latest/cloudera-manager-installer.bin</span><br><span class="line">$WGET  http://archive.cloudera.com.sixxs.org/cm5/redhat/7/x86_64/cm/RPM-GPG-KEY-cloudera</span><br><span class="line">$WGET  http://archive.cloudera.com.sixxs.org/cm5/redhat/7/x86_64/cm/cloudera-manager.repo</span><br><span class="line">$PHP clear_outdated.php http://archive.cloudera.com.sixxs.org/cm5/redhat/7/x86_64/cm/5/RPMS/x86_64/</span><br><span class="line"></span><br><span class="line"># fix cm yum repo link</span><br><span class="line">$PHP fixlink.php cm4</span><br><span class="line">$PHP fixlink.php cm5</span><br><span class="line"></span><br><span class="line"># Download All parcels</span><br><span class="line">for i in $&#123;PARCELS[@]&#125;; do</span><br><span class="line">    download_parcel $i;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x wget.sh</span><br><span class="line">./wget.sh</span><br></pre></td></tr></table></figure>
<h2 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置<code>nginx</code></h2><p>编辑<code>/etc/nginx/sites-available/cloudera.conf</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen        <span class="number">192.168</span><span class="number">.80</span><span class="number">.80</span>:<span class="number">80</span>;</span><br><span class="line">        server_name   archive.cloudera.com.dislab;</span><br><span class="line">        access_log    logs/archive.cloudera.log;</span><br><span class="line">        root   /data/repo/cloudera_mirror/archive.cloudera.com.sixxs.org/ ;</span><br><span class="line">    autoindex on;</span><br><span class="line">        autoindex_exact_size    off;</span><br><span class="line">        autoindex_localtime     on;</span><br></pre></td></tr></table></figure>
<p>软链到<code>sites-enabled</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /etc/nginx/sites-available/cloudera.conf /etc/nginx/sites-enabled/</span><br><span class="line">sudo service nginx reload</span><br></pre></td></tr></table></figure>
<p>这样，镜像就搭好了。</p>
<p><img src="/resource/blog/2016-07/Cloudera-Parcel-Repo.png" alt="镜像"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RedHat7.0更换CentOS源]]></title>
      <url>http://keyunluo.github.io/2016/07/27/2016-07-27-redhat-centos.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>服务器默认安装的是RedHat Linux，Redhat 的更新包只对注册的用户生效，所以我们自己手动更改成CentOS 的更新包，CentOS几乎和redhat是一样的，所以无需担心软件包是否可安装，安装之后是否有问题，本文记录配置过程。</p>
</blockquote>
<a id="more"></a>
<h2 id="查看系统本身所安装的yum-软件包"><a href="#查看系统本身所安装的yum-软件包" class="headerlink" title="查看系统本身所安装的yum 软件包"></a>查看系统本身所安装的yum 软件包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@slave10 hadoop]<span class="comment"># rpm -qa | grep yum</span></span><br><span class="line">yum-langpacks<span class="number">-0.4</span><span class="number">.2</span><span class="number">-3.</span>el7.noarch</span><br><span class="line">yum-metadata-parser<span class="number">-1.1</span><span class="number">.4</span><span class="number">-10.</span>el7.x86_64</span><br><span class="line">yum<span class="number">-3.4</span><span class="number">.3</span><span class="number">-118.</span>el7.noarch</span><br><span class="line">yum-utils<span class="number">-1.1</span><span class="number">.31</span><span class="number">-24.</span>el7.noarch</span><br><span class="line">yum-rhn-plugin<span class="number">-2.0</span><span class="number">.1</span><span class="number">-4.</span>el7.noarch</span><br><span class="line">PackageKit-yum<span class="number">-0.8</span><span class="number">.9</span><span class="number">-11.</span>el7.x86_64</span><br></pre></td></tr></table></figure>
<h2 id="删除这些软件包"><a href="#删除这些软件包" class="headerlink" title="删除这些软件包"></a>删除这些软件包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rpm -e yum<span class="number">-3.4</span><span class="number">.3</span><span class="number">-118.</span>el7.noarch --nodeps</span><br><span class="line">rpm -e yum-utils<span class="number">-1.1</span><span class="number">.31</span><span class="number">-24.</span>el7.noarch --nodeps</span><br><span class="line">rpm -e yum-rhn-plugin<span class="number">-2.0</span><span class="number">.1</span><span class="number">-4.</span>el7.noarch --nodeps</span><br><span class="line">rpm -e yum-metadata-parser<span class="number">-1.1</span><span class="number">.4</span><span class="number">-10.</span>el7.x86_64 --nodeps</span><br><span class="line">rpm -e yum-langpacks<span class="number">-0.4</span><span class="number">.2</span><span class="number">-3.</span>el7.noarch --nodeps</span><br><span class="line">rpm -e PackageKit-yum<span class="number">-0.8</span><span class="number">.9</span><span class="number">-11.</span>el7.x86_64 --nodeps</span><br><span class="line">rpm -e subscription-manager-gui --nodeps</span><br><span class="line">rpm -e subscription-manager-firstboot --nodeps</span><br><span class="line">rpm -e --nodeps redhat-release-server</span><br><span class="line">rpm -e --nodeps redhat-logos</span><br></pre></td></tr></table></figure>
<h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><p>代理服务器使用的是<code>tinyproxy</code>,安装在<code>192.168.100.102</code>中，可以访问外网。</p>
<p>注意：不使用此方法——系统级代理：写入：/etc/profile
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http_proxy=&quot;http://192.168.100.2:8899/&quot;</span><br><span class="line">export http_proxy</span><br></pre></td></tr></table></figure></p>
<p>这样整个系统都使用了代理，可能对Hadoop集群通信造成困扰，因此不予采纳。</p>
<h3 id="为YUM设置代理"><a href="#为YUM设置代理" class="headerlink" title="为YUM设置代理"></a>为YUM设置代理</h3><p>编辑 <code>sudo vim /etc/yum.conf</code> ，添加一行<code>proxy=http://192.168.100.2:8899/</code>,更改如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[main]</span><br><span class="line">cachedir=/var/cache/yum/$basearch/$releasever</span><br><span class="line">keepcache=0</span><br><span class="line">debuglevel=2</span><br><span class="line">logfile=/var/log/yum.log</span><br><span class="line">exactarch=1</span><br><span class="line">obsoletes=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">plugins=1</span><br><span class="line">installonly_limit=5</span><br><span class="line">bugtracker_url=http://bugs.centos.org/set_project.php?project_id=23&amp;ref=http://bugs.centos.org/bug_report_page.php?category=yum</span><br><span class="line">distroverpkg=centos-release</span><br><span class="line">proxy=http://192.168.100.2:8899/</span><br></pre></td></tr></table></figure>
<h3 id="为wget设置代理"><a href="#为wget设置代理" class="headerlink" title="为wget设置代理"></a>为wget设置代理</h3><p>编辑/etc/wgetrc，在最后加入
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http_proxy=http://<span class="number">192.168</span><span class="number">.100</span><span class="number">.2</span>:<span class="number">8899</span>/</span><br><span class="line">https_proxy = http://<span class="number">192.168</span><span class="number">.100</span><span class="number">.2</span>:<span class="number">8899</span>/</span><br></pre></td></tr></table></figure></p>
<p>刷新：<code>source /etc/wgetrc</code></p>
<h2 id="导入GPG-KEY"><a href="#导入GPG-KEY" class="headerlink" title="导入GPG-KEY"></a>导入GPG-KEY</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/centos/<span class="number">7</span>/os/x86_64/RPM-GPG-KEY-CentOS<span class="number">-7</span></span><br><span class="line">sudo mv RPM-GPG-KEY-CentOS<span class="number">-7</span> /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS<span class="number">-7</span></span><br></pre></td></tr></table></figure>
<h2 id="找到自己所需要的版本下载"><a href="#找到自己所需要的版本下载" class="headerlink" title="找到自己所需要的版本下载"></a>找到自己所需要的版本下载</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/centos/<span class="number">7</span>/os/x86_64/Packages/yum<span class="number">-3.4</span><span class="number">.3</span><span class="number">-132.</span>el7.centos<span class="number">.0</span><span class="number">.1</span>.noarch.rpm</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/centos/<span class="number">7</span>/os/x86_64/Packages/yum-utils<span class="number">-1.1</span><span class="number">.31</span><span class="number">-34.</span>el7.noarch.rpm</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/centos/<span class="number">7</span>/os/x86_64/Packages/yum-rhn-plugin<span class="number">-2.0</span><span class="number">.1</span><span class="number">-5.</span>el7.noarch.rpm</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/centos/<span class="number">7</span>/os/x86_64/Packages/yum-metadata-parser<span class="number">-1.1</span><span class="number">.4</span><span class="number">-10.</span>el7.x86_64.rpm</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/centos/<span class="number">7</span>/os/x86_64/Packages/yum-langpacks<span class="number">-0.4</span><span class="number">.2</span><span class="number">-4.</span>el7.noarch.rpm</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/centos/<span class="number">7</span>/os/x86_64/Packages/PackageKit-yum<span class="number">-1.0</span><span class="number">.7</span><span class="number">-5.</span>el7.centos.x86_64.rpm</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/centos/<span class="number">7</span>/os/x86_64/Packages/yum-plugin-fastestmirror<span class="number">-1.1</span><span class="number">.31</span><span class="number">-34.</span>el7.noarch.rpm</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/centos/<span class="number">7</span>/os/x86_64/Packages/PackageKit<span class="number">-1.0</span><span class="number">.7</span><span class="number">-5.</span>el7.centos.x86_64.rpm</span><br></pre></td></tr></table></figure>
<h2 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh yum-metadata-parser<span class="number">-1.1</span><span class="number">.4</span><span class="number">-10.</span>el7.x86_64.rpm</span><br><span class="line">rpm -ivh yum-plugin-fastestmirror<span class="number">-1.1</span><span class="number">.31</span><span class="number">-34.</span>el7.noarch.rpm yum<span class="number">-3.4</span><span class="number">.3</span><span class="number">-132.</span>el7.centos<span class="number">.0</span><span class="number">.1</span>.noarch.rpm</span><br><span class="line">rpm -ivh yum-rhn-plugin<span class="number">-2.0</span><span class="number">.1</span><span class="number">-5.</span>el7.noarch.rpm yum-utils<span class="number">-1.1</span><span class="number">.31</span><span class="number">-34.</span>el7.noarch.rpm yum-langpacks<span class="number">-0.4</span><span class="number">.2</span><span class="number">-4.</span>el7.noarch.rpm</span><br></pre></td></tr></table></figure>
<h2 id="配置Repo"><a href="#配置Repo" class="headerlink" title="配置Repo"></a>配置Repo</h2><p>编辑 <code>vim /etc/yum.repos.d/CentOS-Base.repo</code> :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[base]</span><br><span class="line">name=CentOS-$releasever - Base</span><br><span class="line">baseurl=http://mirrors.tuna.tsinghua.edu.cn/centos/<span class="number">7</span>/os/$basearch/</span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS<span class="number">-7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#released updates</span></span><br><span class="line">[updates]</span><br><span class="line">name=CentOS-$releasever - Updates</span><br><span class="line">baseurl=http://mirrors.tuna.tsinghua.edu.cn/centos/<span class="number">7</span>/updates/$basearch/</span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS<span class="number">-7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#additional packages that may be useful</span></span><br><span class="line">[extras]</span><br><span class="line">name=CentOS-$releasever - Extras</span><br><span class="line">baseurl=http://mirrors.tuna.tsinghua.edu.cn/centos/<span class="number">7</span>/extras/$basearch/</span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS<span class="number">-7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#additional packages that extend functionality of existing packages</span></span><br><span class="line">[centosplus]</span><br><span class="line">name=CentOS-$releasever - Plus</span><br><span class="line">baseurl=http://mirrors.tuna.tsinghua.edu.cn/centos/<span class="number">7</span>/centosplus/$basearch/</span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">enabled=<span class="number">0</span></span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS<span class="number">-7</span></span><br></pre></td></tr></table></figure>
<h2 id="清除旧版本信息-删除RedHat信息"><a href="#清除旧版本信息-删除RedHat信息" class="headerlink" title="清除旧版本信息,删除RedHat信息"></a>清除旧版本信息,删除RedHat信息</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line"></span><br><span class="line">yum install subscription-manager-gui</span><br><span class="line">yum install libdevmapper* -y</span><br><span class="line">yum install PackageKit</span><br><span class="line"></span><br><span class="line">yum remove rhnlib redhat-support-tool redhat-support-lib-python</span><br><span class="line"></span><br><span class="line">yum clean all</span><br><span class="line">yum upgrade</span><br></pre></td></tr></table></figure>
<h2 id="查看更新后的结果："><a href="#查看更新后的结果：" class="headerlink" title="查看更新后的结果："></a>查看更新后的结果：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@slave10 ~]$ cat /etc/redhat-release</span><br><span class="line">CentOS Linux release <span class="number">7.2</span><span class="number">.1511</span> (Core)</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[统计学习方法——概论]]></title>
      <url>http://keyunluo.github.io/2016/07/26/2016-07-26-statical-learning-1.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>统计学习(statistical learning)做的事情是：基于数据建立概率统计模型，然后用模型对数据进行预测和分析。</p>
</blockquote>
<a id="more"></a>
<h2 id="统计学习三要素"><a href="#统计学习三要素" class="headerlink" title="统计学习三要素"></a>统计学习三要素</h2><ol>
<li><p>模型</p>
<ul>
<li><p><strong>模型</strong> 就是所要学习的条件概率分布或决策函数。    $Y=f(X)$ 或 $P(Y|X)$</p>
</li>
<li><p><strong>模型的假设空间</strong> 包括所有可能的条件概率分布或决策函数。</p>
<p>$\mathcal{F} = \{f | Y=f_\theta(X), \theta\in R^n \}$</p>
<p>或 $ \mathcal{F} = \{P | P_\theta(Y|X), \theta\in R_n \}$。 其中 $ \theta$的取值空间$R^n$称为<strong>参数空间</strong>。</p>
</li>
</ul>
</li>
<li><p>策略
 <strong>策略</strong>也即学习的准则。一般来说监督学习的策略即指经验风险或结构风险函数最优化。</p>
<ul>
<li><p>经验风险</p>
<ul>
<li>损失函数 ：$ L(Y, f(X))$<ol>
<li>0-1损失函数</li>
<li>平方损失函数</li>
<li>绝对损失函数</li>
<li>对数损失函数</li>
</ol>
</li>
<li><p>风险函数
  <strong>风险函数(risk function)又叫期望损失(expected loss)</strong>，是理论模型$f(X)$关于联合分布$P(X,Y)$的平均意义下的损失。损失函数的期望是：</p>
<p>$$ R_{exp}(f) = E_p[L(Y,f(X))]=\int_{\mathcal{X}\times \mathcal{Y}}L(y,f(x))P(x,y)dxdy $$</p>
</li>
<li><p>经验风险
  风险函数和联合分布$P(X, Y)$，用作为模型的后者求作为策略的前者，显然是病态的。故取训练数据集上的平均损失称为<strong>经验风险(empirical risk)</strong>。</p>
<p>$$ R_{emp}(f) = \frac1N\sum_{i=1}^N L(y_i, f(x_i)) $$</p>
<p> 当训练样本数量$N$趋于无穷时，$R_{emp}$趋于$R_{exp}$。</p>
</li>
</ul>
</li>
<li><p>结构风险</p>
<p>  <strong>结构风险(structural risk)</strong>在经验风险的基础上添加正则化项(regularization，也叫罚项(penalty term))。</p>
<p>  $$ R_{srm}(f)=\frac1N\sum_{i=1}^N L(y_i,f(x_i))+ \lambda J(f), \lambda \geq 0 $$</p>
</li>
<li><p>经验风险最小化</p>
<p>  在$\mathcal{F}$找到一个$f$使得$R_{emp}$最小。
  p.s. 当模型是条件概率分布，损失函数是对数损失函数时，经验风险最小化等价于<strong>极大似然估计</strong>。</p>
</li>
<li><p>结构风险最小化</p>
<p>  为防止经验风险最小化有可能带来的过拟合，添加<strong>代表模型复杂度</strong>的罚项$J(f)$。</p>
</li>
</ul>
</li>
<li>算法
 最优化算法</li>
</ol>
<hr>
<h2 id="模型评估与模型选择"><a href="#模型评估与模型选择" class="headerlink" title="模型评估与模型选择"></a>模型评估与模型选择</h2><h3 id="误差"><a href="#误差" class="headerlink" title="误差"></a>误差</h3><ol>
<li><p>训练误差</p>
<p> <strong>训练误差(training error)</strong>是学习到的模型$Y=\hat{f}(X)$关于训练数据集的平均损失。</p>
<p> $$R_{emp}(\hat{f}) = \frac1N\sum_{i=1}^N L(y_i, \hat{f}(x_i))$$</p>
</li>
<li><p>测试误差</p>
<p> <strong>测试误差(test error)</strong>是学习到的模型$Y=\hat{f}(X)$关于测试数据集的平均损失。</p>
<p> $$e_{test}(\hat{f}) = \frac1{N’}\sum_{i=1}^{N’} L(y_i, \hat{f}(x_i))$$
当损失函数是0-1损失时，测试误差即为测试数据集上的误差率。</p>
</li>
</ol>
<h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p>正则化方法就是在经验风险函数上添加正则化项。<strong>正则化项(regularizer)</strong>一般是模型复杂度的单调递增函数。如可以是模型参数向量的范数。</p>
<p>正则化的一般形式：</p>
<p>$$ min_{f \in \mathcal{F} } \frac1N\sum_{i=1}^N L(y_i,f(x_i))+ \lambda J(f)$$</p>
<p>其中第一项是经验风险，第二项是正则化项，正则化项可以取不同的形式，例如，在回归问题中，损失函数是平方损失，正则化项可以是参数向量的$L_2$范数：</p>
<p>$$L(w)=\frac1N\sum_{i=1}^N L(y_i,f(x_i))+ \frac{\lambda}{2} {\Vert w \Vert}^2$$</p>
<ul>
<li>奥卡姆剃刀(Occam’s razor)原理：在所有可能选择的模型中，能够很好解释已知数据并且十分简单才是最好的模型。</li>
</ul>
<h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h3><p>将数据集随机分为训练集、验证集(validation set)和测试集，分别用于模型的训练、选择和评估。</p>
<ol>
<li>简单交叉验证
 分两部分：训练集和测试集</li>
<li>$S$折交叉验证
 等分$S$部分：$S-1$份做训练集，1份做测试集。重复进行。</li>
<li>留一交叉验证
 $S$折交叉验证的特例$S=N$。</li>
</ol>
<h3 id="泛化能力"><a href="#泛化能力" class="headerlink" title="泛化能力"></a>泛化能力</h3><ol>
<li><p>泛化误差</p>
<p> <strong>泛化误差(generalization error)</strong>学到的模型$\hat{f}$对未知数据预测的误差。</p>
<p> $$R_{exp}(\hat{f}) = E_p[L(Y,\hat{f}(X))]=\int _{\mathcal{X}\times \mathcal{Y}}L(y,\hat{f}(x))P(x,y)dxdy$$</p>
<p> 泛化误差就是学习到的模型的期望风险。</p>
</li>
<li><p>泛化误差上界</p>
<ul>
<li>样本容量增加，泛化误差上界趋近于0</li>
<li>假设空间容量增加，泛化误差上界增大</li>
</ul>
</li>
</ol>
<hr>
<h2 id="监督学习分类"><a href="#监督学习分类" class="headerlink" title="监督学习分类"></a>监督学习分类</h2><h3 id="按学习方法分类"><a href="#按学习方法分类" class="headerlink" title="按学习方法分类"></a>按学习方法分类</h3><ol>
<li>生成方法-&gt;生成模型<ul>
<li>由数据学习联合概率分布$P(X,Y)$后，求出概率分布$P(Y|X) = P(X,Y)/P(X)$。</li>
<li>包括：朴素贝叶斯法、隐马尔科夫模型</li>
</ul>
</li>
<li>判别方法-&gt;判别模型<ul>
<li>由数据直接学习决策函数$f(X)$或者条件概率分布$P(Y|X)$。</li>
<li>包括：k近邻法、感知机、逻辑斯蒂回归模型、最大熵模型、支持向量机、提升方法、条件随机场。</li>
</ul>
</li>
<li>区别：<ul>
<li>生成方法：<ul>
<li>可还原出$P(X,Y)$</li>
<li>学习收敛速度快，当N增大时，更快收敛于真实模型</li>
<li>当存在隐变量时，仍可以使用</li>
</ul>
</li>
<li>判别方法<ul>
<li>直接学习$f(X)$或$P(Y|X)$，往往学习的准确率更高</li>
<li>可对数据进行抽象、特征定义以简化学习问题</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="研究议题"><a href="#研究议题" class="headerlink" title="研究议题"></a>研究议题</h3><p>输入变量和输出变量均为连续变量的预测问题称为回归问题，如函数拟合；输出变量为有限个离散变量的预测问题称为分类问题，学习出的分类模型或分类决策函数称为分类器（classifier）；输入变量与输出变量均为变量序列的预测问题称为标注问题，如词性标注，输入词序列，输出是（词，词性）的标记序列。</p>
<ol>
<li>分类问题<ul>
<li>评价指标<ul>
<li>精确率(precision)
  $$P = \frac{TP}{TP+FP}$$</li>
<li>召回率(recall)
  $$R = \frac{TP}{TP+FN}$$</li>
<li>$F_1$
  $$F_1 = \frac{2}{\frac1P + \frac1R} = \frac{2TP}{2TP+FP+FN}$$</li>
</ul>
</li>
</ul>
</li>
<li>标注问题</li>
<li>回归问题</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PlantUML时序图绘制]]></title>
      <url>http://keyunluo.github.io/2016/07/25/2016-07-25-plantuml-sequence.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>PlantUML是一个开源项目，并支持快速绘制常见的UML图像,本节主要学习其时序图的用法,时序图通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。</p>
</blockquote>
<a id="more"></a>
<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>你可以使用-&gt;来绘制参与者之间的消息传递， 而不必显式的声明参与者。
你也可以使用 “–&gt;” 绘制一个虚线箭头表示异步消息。</p>
<p>另外，你也可以使用 “&lt;-“ 和 “&lt;–”. 这虽然不影响图形绘制，但可以增加可读性。 注意：仅适用于时序图，其它图形的规则是不同的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">Alice -&gt; Bob: Authentication Request</span><br><span class="line">Bob --&gt; Alice: Authentication Response</span><br><span class="line"></span><br><span class="line">Alice -&gt; Bob: Another authentication Request</span><br><span class="line">Alice &lt;-- Bob: another authentication Response</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure>
<img src="http://www.plantuml.com/plantuml/svg/Syp9J4vLqBLJSCfFib9mB2t9ICqhoKnEBCdCprC8IYqiJIqkuGBAAUW2rJY256DHLLoGdrUSoiNbY6fONZvGNP528dP38OfjT7KXgXDngOOO3W00">
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>所有以单引号开头的行 ‘都是注释。</p>
<p>你也可以使用多行注释，多行注释以 /‘ 开头 ‘/ 结尾。</p>
<h2 id="声明参与者"><a href="#声明参与者" class="headerlink" title="声明参与者"></a>声明参与者</h2><p>可以使用 participant 关键字来改变参与者的先后顺序。
你也可以使用其它关键字来声明参与者:</p>
<ul>
<li>actor</li>
<li>boundary</li>
<li>control</li>
<li>entity</li>
<li>database</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">actor Foo1</span><br><span class="line">boundary Foo2</span><br><span class="line">control Foo3</span><br><span class="line">entity Foo4</span><br><span class="line">database Foo5</span><br><span class="line">Foo1 -&gt; Foo2 : To boundary</span><br><span class="line">Foo1 -&gt; Foo3 : To control</span><br><span class="line">Foo1 -&gt; Foo4 : To entity</span><br><span class="line">Foo1 -&gt; Foo5 : To database</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure>
<img src="http://www.plantuml.com/plantuml/svg/IqmkoIzISClFD-HAoY_DIqaigWJnZBYIy_DAYl9pG1nZhjIyaimIi8G9LqfYIM9IOd4gY6VA1TAfe6i7rgDWfH2Ihm0p1bdA6285DHDPnWGY0x40MS8K8W6p3G00">
<p>使用 as 关键字重命名参与者，可以使用RGB值或者颜色名修改 actor 或参与者的背景色。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">actor Bob #red</span><br><span class="line">' The only difference between actor</span><br><span class="line">'and participant is the drawing</span><br><span class="line">participant Alice</span><br><span class="line">participant "I have a really\nlong name" as L #99FF99</span><br><span class="line">/' You can also declare:</span><br><span class="line">   participant L as "I have a really\nlong name"  #99FF99</span><br><span class="line">  '/</span><br><span class="line"></span><br><span class="line">Alice-&gt;Bob: Authentication Request</span><br><span class="line">Bob-&gt;Alice: Authentication Response</span><br><span class="line">Bob-&gt;L: Log transaction</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure>
<img src="http://www.plantuml.com/plantuml/svg/VP2n2W8n44JxVCMWnLLYVLS8MWZ2LM8ZsAp9UWRYxfda5F_Ug20AOhlpPcPtoMQDMEWUuyZELDWS6IhX1kSF1uuibh7dV6KMq0Cs5Ob3Jp5xwtkI39-GYyj5kdhfpASq3zxorsIqmf4k349a2k6saw3IGUZ48r12Yt5TBvTrRQOLjZh0KYaEIU7O1ehS6E2hldtO_iQ-8u5gQinpgSci7DrWFfJLfMHHzYfOytdWb4tH9hCdzmD9lKhY5zCsQBL3ZYIflAS0Tm00">
<h2 id="更改箭头的样式"><a href="#更改箭头的样式" class="headerlink" title="更改箭头的样式"></a>更改箭头的样式</h2><p>修改箭头样式的方式有以下几种:</p>
<ul>
<li>末尾加 x 表示一条丢失的消息</li>
<li>使用 \ 或 / 替代 &lt; 或 &gt; 来表示 have only the bottom or top part of the arrow</li>
<li>使用两个箭头标记 (如 &gt;&gt; 或 //) 表示空心箭头。</li>
<li>使用 – 替代 - 以表示虚线箭头。</li>
<li>在箭头末尾加 “o”</li>
<li>双向箭头。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Bob -&gt;x Alice</span><br><span class="line">Bob -&gt; Alice</span><br><span class="line">Bob -&gt;&gt; Alice</span><br><span class="line">Bob -\ Alice</span><br><span class="line">Bob \\- Alice</span><br><span class="line">Bob //-- Alice</span><br><span class="line"></span><br><span class="line">Bob -&gt;o Alice</span><br><span class="line">Bob o\\-- Alice</span><br><span class="line"></span><br><span class="line">Bob &lt;-&gt; Alice</span><br><span class="line">Bob &lt;-&gt;o Alice</span><br></pre></td></tr></table></figure>
<img src="http://www.plantuml.com/plantuml/svg/SyfFKj2rgr1mpCbCJkLo0lDGE2Yy62HEJ8mk4azVNnV6XMhCHvBD1of6aRP1iSK6hXe0">
<h2 id="修改箭头颜色"><a href="#修改箭头颜色" class="headerlink" title="修改箭头颜色"></a>修改箭头颜色</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bob -[<span class="comment">#red]&gt; Alice : hello</span></span><br><span class="line">Alice -[<span class="comment">#0000FF]-&gt;Bob : ok</span></span><br></pre></td></tr></table></figure>
<img src="http://www.plantuml.com/plantuml/svg/SyfFKj2DLYvAJOcrKt3CoKnELR1Io4ZDoSddWl20aWP0uEOMgsld15HifP2V3G00">
<h2 id="消息编号"><a href="#消息编号" class="headerlink" title="消息编号"></a>消息编号</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">autonumber</span><br><span class="line">Bob -&gt; Alice : Authentication Request</span><br><span class="line">Bob &lt;- Alice : Authentication Response</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure>
<img src="http://www.plantuml.com/plantuml/svg/IomjoSyhpKrABU9ooazIqBLJSCp9J4vLi59mB2t9ICqhoKnEBCdCprC8IYqiJIqk0QkoqSMjghWWFwyu5G00">
<p>你可以在双引号内指定编号的格式。
格式是由 Java 的DecimalFormat类实现的 (‘0’ 表示数字, ‘#’ 表示数字且默认为 0 )。</p>
<p>你还可以使用 HTML 标签来制定格式。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line"></span><br><span class="line">title Simple communication example</span><br><span class="line"></span><br><span class="line">autonumber "&lt;b&gt;[000]"</span><br><span class="line">Bob -&gt; Alice : Authentication Request</span><br><span class="line">Bob &lt;- Alice : Authentication Response</span><br><span class="line"></span><br><span class="line">autonumber 15 "&lt;b&gt;(&lt;u&gt;##&lt;/u&gt;)"</span><br><span class="line">Bob -&gt; Alice : Another authentication Request</span><br><span class="line">Bob &lt;- Alice : Another authentication Response</span><br><span class="line"></span><br><span class="line">autonumber 40 10 "&lt;font color=red&gt;&lt;b&gt;Message 0  "</span><br><span class="line">Bob -&gt; Alice : Yet another authentication Request</span><br><span class="line">Bob &lt;- Alice : Yet another authentication Response</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure>
<img src="http://www.plantuml.com/plantuml/svg/bP2n2i8m48RtFiNHBZg8AUWYDL1t5vr47D9wQg39rUG2Fhwn8WYrejF1yV_tVHnhRX2sshHnr6HCiBfMhCa2tjHZcwZ0P8Efq45QL78lX3YaoOegc4We6rqZBA0CV47Bh-u6hm4zTwbYCfpoBLcFoJiZdtUOKH5abXNJ8CTzcALunu7w3JgK_W2V2SX5v9_8Sdn7Gsxfy2YZpngzLsS40T3psI63-ilfQ-FfTGS0">
<h2 id="给图表-diagram-添加备注"><a href="#给图表-diagram-添加备注" class="headerlink" title="给图表(diagram)添加备注"></a>给图表(diagram)添加备注</h2><p>关键字 legend 和 end legend 用于添加备注。
可选项 left， right 和 center 可用于设置标注的对齐方式。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">Alice -&gt; Bob : Hello</span><br><span class="line">legend right</span><br><span class="line">  Short</span><br><span class="line">  legend</span><br><span class="line">endlegend</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure>
<img src="http://www.plantuml.com/plantuml/svg/Syp9J4vLqBLJSCfFKh1Iy4ZDoSddoabDJyrBKIZAJCyeuL9G2Cx8BmBH464k88Oe0000">
<h2 id="给消息添加注释"><a href="#给消息添加注释" class="headerlink" title="给消息添加注释"></a>给消息添加注释</h2><p>我们可以通过在消息后面添加 note left 或者 note right 关键词来给消息添加注释。
你也可以通过使用 end note 来添加多行注释。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">Alice-&gt;Bob : hello</span><br><span class="line">note left: this is a first note</span><br><span class="line"></span><br><span class="line">Bob-&gt;Alice : ok</span><br><span class="line">note right: this is another note</span><br><span class="line"></span><br><span class="line">Bob-&gt;Bob : I am thinking</span><br><span class="line">note left</span><br><span class="line">    a note</span><br><span class="line">    can also be defined</span><br><span class="line">    on several lines</span><br><span class="line">end note</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure>
<img src="http://www.plantuml.com/plantuml/svg/JOr13eCm30JlUSL-W0zmGAAtFiCGGonSHqgYlhyEEHJB1sizerrLTfwMLzum8x5g3fORG_beCrgI2b_28QKsz5S83a_BsaLtyZM48cTw6XucBazZTBn1dqxP9NR-km9yQE3ztCb0MZCsHkH3ZEETPqFbBnTIg8SriCNR-W40">
<h2 id="改变备注框的形状"><a href="#改变备注框的形状" class="headerlink" title="改变备注框的形状"></a>改变备注框的形状</h2><p>你可以使用 hnote 和 rnote 这两个关键字来修改备注框的形状。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">caller -&gt; server : conReq</span><br><span class="line">hnote over caller : idle</span><br><span class="line">caller &lt;- server : conConf</span><br><span class="line">rnote over server</span><br><span class="line"> "r" as rectangle</span><br><span class="line"> "h" as hexagon</span><br><span class="line">endrnote</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure>
<img src="http://www.plantuml.com/plantuml/svg/LOlB2O0m44JlMyMGUne8uiKEx234rGXX5pSYbkyNnDlCctafbi86twAoRMSAI2ezBvH5LuPUB3sdW7aeJ6zh_4_fL4QoptasWZE7M66SrYZJgSFbcsJUuwH2BCEj7G00">
<h2 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h2><p>你可以使用|||来增加空间。
还可以使用数字指定增加的像素的数量。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">Alice -&gt; Bob: message 1</span><br><span class="line">Bob --&gt; Alice: ok</span><br><span class="line">|||</span><br><span class="line">Alice -&gt; Bob: message 2</span><br><span class="line">Bob --&gt; Alice: ok</span><br><span class="line">||45||</span><br><span class="line">Alice -&gt; Bob: message 3</span><br><span class="line">Bob --&gt; Alice: ok</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure>
<img src="http://www.plantuml.com/plantuml/svg/Syp9J4vLqBLJSCfFibB8JIqkJanFLJ3a0d8LT872ZY1vAuNyRAwQcXekHwogZR2gDZ75gS4OKmC0">
<h2 id="生命线的激活与撤销"><a href="#生命线的激活与撤销" class="headerlink" title="生命线的激活与撤销"></a>生命线的激活与撤销</h2><p>关键字activate和deactivate用来表示参与者的生命活动。
一旦参与者被激活，它的生命线就会显示出来。</p>
<p>activate和deactivate适用于以上情形。</p>
<p>destroy表示一个参与者的生命线的终结。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">participant User</span><br><span class="line"></span><br><span class="line">User -&gt; A: DoWork</span><br><span class="line">activate A</span><br><span class="line"></span><br><span class="line">A -&gt; B: &lt;&lt; createRequest &gt;&gt;</span><br><span class="line">activate B</span><br><span class="line"></span><br><span class="line">B -&gt; C: DoWork</span><br><span class="line">activate C</span><br><span class="line">C --&gt; B: WorkDone</span><br><span class="line">destroy C</span><br><span class="line"></span><br><span class="line">B --&gt; A: RequestCreated</span><br><span class="line">deactivate B</span><br><span class="line"></span><br><span class="line">A -&gt; User: Done</span><br><span class="line">deactivate A</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure>
<img src="http://www.plantuml.com/plantuml/svg/POv12iCm30Jl-mfz81y8mM0xBoYKdesZWod4gQ8M-ljQJY65NdJGxixkbaHBBbjQbQux2s2N1aT-fBdUgjoHifPNKYOFU9F2IDD4MRWzB_nuygxatEaBG31V_4T4H1eEX0bpNHbBoqjzDyrYH_KN6tl7qYo_y3x2TXg_0yw97m00">
<h2 id="进入和发出消息"><a href="#进入和发出消息" class="headerlink" title="进入和发出消息"></a>进入和发出消息</h2><p>如果只想关注部分图示，你可以使用进入和发出箭头。
使用方括号[和]表示图示的左、右两侧。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">[-&gt; A: DoWork</span><br><span class="line"></span><br><span class="line">activate A</span><br><span class="line"></span><br><span class="line">A -&gt; A: Internal call</span><br><span class="line">activate A</span><br><span class="line"></span><br><span class="line">A -&gt;] : &lt;&lt; createRequest &gt;&gt;</span><br><span class="line"></span><br><span class="line">A&lt;--] : RequestCreated</span><br><span class="line">deactivate A</span><br><span class="line">[&lt;- A: Done</span><br><span class="line">deactivate A</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure>
<img src="http://www.plantuml.com/plantuml/svg/YzQrKt2qKd393yylokRYIamkoInBB4bLSEJYSbI0o7dcbQGMvINcA2GdvkHWg8XLi5AmiL58Bae52WQb5fQc5fSesDa19MrqTK6IK35di88KhfHK91EYRNGXjkUbeaW00000">
<h2 id="包裹参与者"><a href="#包裹参与者" class="headerlink" title="包裹参与者"></a>包裹参与者</h2><p>可以使用box和end box画一个盒子将参与者包裹起来。
还可以在box关键字之后添加标题或者背景颜色。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">box "Internal Service" #LightBlue</span><br><span class="line">    participant Bob</span><br><span class="line">    participant Alice</span><br><span class="line">end box</span><br><span class="line">participant Other</span><br><span class="line"></span><br><span class="line">Bob -&gt; Alice : hello</span><br><span class="line">Alice -&gt; Other : hello</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure>
<img src="http://www.plantuml.com/plantuml/svg/IyglK53op2j9BSfBp548JYqgoqnELL9GzibCpoXnoYbDvL80WeB4efBCvCo2nBmI1QVy90mnnnoWBgxKl1I5fFmABcGP_vACr28kBg0c1LqxY3e5AuMCr9oSV2u83oWCLWGJ1W00">
<h2 id="外观参数-skinparam"><a href="#外观参数-skinparam" class="headerlink" title="外观参数(skinparam)"></a>外观参数(skinparam)</h2><p>使用skinparam命令改变颜色和字体。
如下场景可以使用这一命令：</p>
<ul>
<li>在图示定义中，</li>
<li>在一个包含文件中,</li>
<li>在由命令行或者ANT任务提供的配置文件中。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">skinparam sequenceArrowThickness 2</span><br><span class="line">skinparam roundcorner 20</span><br><span class="line">skinparam maxmessagesize 60</span><br><span class="line">skinparam sequenceParticipant underline</span><br><span class="line"></span><br><span class="line">actor User</span><br><span class="line">participant "First Class" as A</span><br><span class="line">participant "Second Class" as B</span><br><span class="line">participant "Last Class" as C</span><br><span class="line"></span><br><span class="line">User -&gt; A: DoWork</span><br><span class="line">activate A</span><br><span class="line"></span><br><span class="line">A -&gt; B: Create Request</span><br><span class="line">activate B</span><br><span class="line"></span><br><span class="line">B -&gt; C: DoWork</span><br><span class="line">activate C</span><br><span class="line">C --&gt; B: WorkDone</span><br><span class="line">destroy C</span><br><span class="line"></span><br><span class="line">B --&gt; A: Request Created</span><br><span class="line">deactivate B</span><br><span class="line"></span><br><span class="line">A --&gt; User: Done</span><br><span class="line">deactivate A</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure>
<img src="http://www.plantuml.com/plantuml/svg/PO-xJWCn44Nx-OfH-aWe1KMAI6j7L1G8WgX7tX5OcxMN6OVNr-DP0l6ArkVSUySwn3IHq8ZAhoTEWJkH_7vuYM58h8eRq3z5yYdr8KjYmSrL0qRw6AjCpwpnY_6wPR-zToGbXZXHAbXhM8unCG25aWKVbGMcnbZTHD62_aYgAoJ5ReaVEEJKDzmj-IqjqXx09d2zmswB-_oKPR3f-4Q5QpTqXjmMlR2ztDlHMYwA0t2c-Fzf3nxNFsa3-ro_rTUmv4_RTJEig-VEyqHVdRQzcpKxqXRcYijztm00">
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">skinparam backgroundColor #EEEBDC</span><br><span class="line">skinparam handwritten true</span><br><span class="line"></span><br><span class="line">skinparam sequence &#123;</span><br><span class="line">    ArrowColor DeepSkyBlue</span><br><span class="line">    ActorBorderColor DeepSkyBlue</span><br><span class="line">    LifeLineBorderColor blue</span><br><span class="line">    LifeLineBackgroundColor #A9DCDF</span><br><span class="line"></span><br><span class="line">    ParticipantBorderColor DeepSkyBlue</span><br><span class="line">    ParticipantBackgroundColor DodgerBlue</span><br><span class="line">    ParticipantFontName Impact</span><br><span class="line">    ParticipantFontSize 17</span><br><span class="line">    ParticipantFontColor #A9DCDF</span><br><span class="line"></span><br><span class="line">    ActorBackgroundColor aqua</span><br><span class="line">    ActorFontColor DeepSkyBlue</span><br><span class="line">    ActorFontSize 17</span><br><span class="line">    ActorFontName Aapex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">actor User</span><br><span class="line">participant "First Class" as A</span><br><span class="line">participant "Second Class" as B</span><br><span class="line">participant "Last Class" as C</span><br><span class="line"></span><br><span class="line">User -&gt; A: DoWork</span><br><span class="line">activate A</span><br><span class="line"></span><br><span class="line">A -&gt; B: Create Request</span><br><span class="line">activate B</span><br><span class="line"></span><br><span class="line">B -&gt; C: DoWork</span><br><span class="line">activate C</span><br><span class="line">C --&gt; B: WorkDone</span><br><span class="line">destroy C</span><br><span class="line"></span><br><span class="line">B --&gt; A: Request Created</span><br><span class="line">deactivate B</span><br><span class="line"></span><br><span class="line">A --&gt; User: Done</span><br><span class="line">deactivate A</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure>
<img src="http://www.plantuml.com/plantuml/svg/VP91IyD048Nlyok6Ukx1azY3aDsq81GHYtYU9cDTakwcinjh5V-xsRGqQHhSutplpNiCwmjZAnBQufgoOYEkjhbsfHEycS_dAjNWpueFilbUJ0XiCKZDq6EUTpNRZF47i7c9YDiVzwJCrQeugB8nj2WBJfIJd6LSi3Jll3IM-vhr5HosJUvJdIwW5JsJ19EPYcpuBwWl6wnBNRvX6LCkd0rFj6Lyt5QKXJ6yCj-CjtTZQAJiyHw3VDhLrD7EENhCOUPvsFPCgE8l-0MWECPNpm9Lrmed2oC-e2x9-mcIn-GIhpXpDkznTScNTE7M0342fm-Op9exlZafOhJvfD2K0KWYKZFKmd7o4Z-E3vr40QWeqTTk3HgdHtS4gRCCUMCMTuYvgeLDwcddAI9lDFtjIIkB9MD2kwBhzmS0">]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo博客中的绘图]]></title>
      <url>http://keyunluo.github.io/2016/07/25/2016-07-25-hexo-uml.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>UML是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。本文介绍在Hexo中的两种绘图组件。</p>
</blockquote>
<a id="more"></a>
<h2 id="hexo-diagram"><a href="#hexo-diagram" class="headerlink" title="hexo-diagram"></a>hexo-diagram</h2><p>特点：</p>
<ul>
<li>时序图</li>
<li>鲁棒图</li>
<li>流程图</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-diagram --save</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>diagram_type: sequence,robustness,flow,默认是时序图。</p>
<p>实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">``` sequence</span><br><span class="line"><span class="meta">@found "You", -&gt;</span></span><br><span class="line"><span class="meta">  @message "Think", -&gt;</span></span><br><span class="line"><span class="meta">    @message "Write your idea", "JUMLY", -&gt;</span></span><br><span class="line"><span class="meta">      @create "Diagram"</span></span><br><span class="line">jumly</span><br><span class="line"></span><br><span class="line"><span class="meta">@found "Browser", -&gt;</span></span><br><span class="line"><span class="meta">  @message "http request", "HTTP Server", -&gt;</span></span><br><span class="line"><span class="meta">    @create "HTTP Session", -&gt;</span></span><br><span class="line"><span class="meta">      @message "init"</span></span><br><span class="line"><span class="meta">      @message "aquire lock", "Database"</span></span><br><span class="line"><span class="meta">    @message "do something"</span></span><br><span class="line"><span class="meta">    @message "release lock", "Database"</span></span><br><span class="line"><span class="meta">    @reply "", "Browser"</span></span><br></pre></td></tr></table></figure>
<p><img src="/resource/diagrams/2016-07-25-hexo-uml-diagram-0.png" alt="sequence"></p>
<p><img src="/resource/diagrams/2016-07-25-hexo-uml-diagram-1.png" alt="sequence"></p>
<p>流程图的例子：
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//纵向流程图</span><br><span class="line">st=&gt;start: Start:&gt;http://www.google.com[blank]</span><br><span class="line">e=&gt;end:&gt;http://www.google.com</span><br><span class="line">op1=&gt;operation: My Operation</span><br><span class="line">sub1=&gt;subroutine: My Subroutine</span><br><span class="line">cond=&gt;condition: Yes</span><br><span class="line">or No?:&gt;http://www.google.com</span><br><span class="line">io=&gt;inputoutput: catch something...</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op1</span><br><span class="line"></span><br><span class="line">//横向流程图</span><br><span class="line">st=&gt;start: Start|past:&gt;http://www.google.com[blank]</span><br><span class="line">e=&gt;end: End|future:&gt;http://www.google.com</span><br><span class="line">op1=&gt;operation: My Operation|past</span><br><span class="line">op2=&gt;operation: Stuff|current</span><br><span class="line">sub1=&gt;subroutine: My Subroutine|invalid</span><br><span class="line">cond=&gt;condition: Yes</span><br><span class="line">or No?|approved:&gt;http://www.google.com</span><br><span class="line">c2=&gt;condition: Good idea|rejected</span><br><span class="line">io=&gt;inputoutput: catch something...|future</span><br><span class="line"></span><br><span class="line">st-&gt;op1(right)-&gt;cond</span><br><span class="line">cond(yes, right)-&gt;c2</span><br><span class="line">cond(no)-&gt;sub1(left)-&gt;op1</span><br><span class="line">c2(yes)-&gt;io-&gt;e</span><br><span class="line">c2(no)-&gt;op2-&gt;e</span><br></pre></td></tr></table></figure></p>
<p><img src="/resource/diagrams/2016-07-25-hexo-uml-diagram-2.png" alt="flow"></p>
<p><img src="/resource/diagrams/2016-07-25-hexo-uml-diagram-3.png" alt="flow"></p>
<p><img src="/resource/diagrams/2016-07-25-hexo-uml-diagram-4.png" alt="flow"></p>
<h2 id="hexo-tag-plantuml"><a href="#hexo-tag-plantuml" class="headerlink" title="hexo-tag-plantuml"></a>hexo-tag-plantuml</h2><p>PlantUML是一个快速创建UML图形的组件，通过简单和直观的语言来定义图形，PlantUML支持的图形有：</p>
<ul>
<li>时序图(sequence diagram)</li>
<li>用例图(use case diagram)</li>
<li>类图(class diagram)</li>
<li>活动图(activity diagram)</li>
<li>组件图(component diagram)</li>
<li>状态图(state diagram)</li>
<li>部署图(deployment diagram)</li>
<li>对象图(object diagram)</li>
<li>图形接口(wireframe graphical interface)</li>
</ul>
<p>它的详细的官方文档为:<a href="http://plantuml.com/PlantUML_Language_Reference_Guide.pdf" target="_blank" rel="external">PlantUML Language Reference Guide</a></p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>在Hexo博客的根目录下执行下面命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-tag-plantuml --save</span><br></pre></td></tr></table></figure>
<p>本质上是使用在线生成的方式产生图片的。</p>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>一个简单例子如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">Alice -&gt; Bob: Authentication Request</span><br><span class="line">Bob --&gt; Alice: Authentication Response</span><br><span class="line">Alice -&gt; Bob: Another authentication Request</span><br><span class="line">Alice &lt;-- Bob: another authentication Response</span><br><span class="line">&#123;% endplantuml %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">package org.nju.dislab.uml&#123;</span><br><span class="line">    class TestA &#123;</span><br><span class="line">        -String name</span><br><span class="line">        +int id</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class TestB extends TestA&#123;</span><br><span class="line">        -String desc</span><br><span class="line">        +String getDesc()</span><br><span class="line">        +void setDesc(String desc)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure>
<img src="http://www.plantuml.com/plantuml/svg/Syp9J4vLqBLJSCfFib9mB2t9ICqhoKnEBCdCprC8IYqiJIqkuGBAAUW2rJY256DHLLoGdrUSokM8QbPUFb1PaK8YTZCXYcrqTI6g4t6fXfWD0000">
<img src="http://www.plantuml.com/plantuml/svg/POr12i9034NtFKMM5d7keFG6Ue4u2KFiD9KcbOBqxbOThEZVvNt-onLZYucX7rBGonX8BECvZ5s-Lx0aPZI34vlluKsUsHrz44sWsF47RaKTX5xtNFsi3y2Jir9n_Qk8BQwg0XDxi_1DlJQtNWYiyAzjNVxE3m00">
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python Pandas数据处理入门]]></title>
      <url>http://keyunluo.github.io/2016/07/23/2016-07-23-python-pandas.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>Pandas包含高级的数据结构和精巧的工具，使得在Python中处理数据非常快速和简单。Pandas建造在NumPy之上，它使得以NumPy为中心的应用很容易使用。</p>
</blockquote>
<a id="more"></a>
<h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Series是一个一维的类似数组的对象，包含一个数组的数据（任何NumPy的数据类型）和一个与数组关联的数据标签，被叫做 索引 。最简单的Series是由一个数组的数据构成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x=pd.Series(index = range(<span class="number">5</span>),data=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">12</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">9</span></span><br><span class="line"><span class="number">3</span> <span class="number">11</span></span><br><span class="line"><span class="number">4</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>Pandas的数据结构主要用来处理时序数据，因此，<code>index</code>项必须是可排序的。</p>
<h3 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x=pd.Series(index = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'d'</span>,<span class="string">'z'</span>,<span class="string">'z'</span>],data=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">12</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">a     <span class="number">1</span></span><br><span class="line">b     <span class="number">3</span></span><br><span class="line">d     <span class="number">9</span></span><br><span class="line">z    <span class="number">11</span></span><br><span class="line">z    <span class="number">12</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<ul>
<li><p>点标选择</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.a</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.z</span><br><span class="line">z <span class="number">11</span></span><br><span class="line">z <span class="number">12</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下标选择,使用iloc</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.iloc[:<span class="number">3</span>]</span><br><span class="line">a <span class="number">1</span></span><br><span class="line">b <span class="number">3</span></span><br><span class="line">d <span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.loc[<span class="string">'a'</span>:<span class="string">'d'</span>]</span><br><span class="line">a    <span class="number">1</span></span><br><span class="line">b    <span class="number">3</span></span><br><span class="line">d    <span class="number">9</span></span><br><span class="line">dtype: int64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="string">'a'</span>:<span class="string">'d'</span>]</span><br><span class="line">a    <span class="number">1</span></span><br><span class="line">b    <span class="number">3</span></span><br><span class="line">d    <span class="number">9</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用分片时，注意包括终点。</p>
<h3 id="聚集和统计"><a href="#聚集和统计" class="headerlink" title="聚集和统计"></a>聚集和统计</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = pd.Series(range(<span class="number">5</span>),[<span class="number">1</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">9</span>,<span class="number">10</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">1</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2</span>     <span class="number">1</span></span><br><span class="line"><span class="number">11</span>    <span class="number">2</span></span><br><span class="line"><span class="number">9</span>     <span class="number">3</span></span><br><span class="line"><span class="number">10</span>    <span class="number">4</span></span><br><span class="line">dtype: int64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grp=x.groupby(<span class="keyword">lambda</span> i:i%<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grp.get_group(<span class="number">0</span>)</span><br><span class="line"><span class="number">2</span>     <span class="number">1</span></span><br><span class="line"><span class="number">10</span>    <span class="number">4</span></span><br><span class="line">dtype: int64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grp.get_group(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span>     <span class="number">0</span></span><br><span class="line"><span class="number">11</span>    <span class="number">2</span></span><br><span class="line"><span class="number">9</span>     <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grp.max()</span><br><span class="line"><span class="number">0</span>    <span class="number">4</span></span><br><span class="line"><span class="number">1</span>    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><p> 一个DataFrame表示一个表格，类似电子表格的数据结构，包含一个经过排序的列表集，它们每一个都可以有不同的类型值（数字，字符串，布尔等等）。DataFrame有行和列的索引；它可以被看作是一个Series的字典（每个Series共享一个索引）。与其它你以前使用过的（如 R 的 data.frame )类似DataFrame的结构相比，在DataFrame里的面向行和面向列的操作大致是对称的。在底层，数据是作为一个或多个二维数组存储的，而不是列表，字典，或其它一维的数组集合。</p>
<h3 id="创建-：-使用字典"><a href="#创建-：-使用字典" class="headerlink" title="创建 ： 使用字典"></a>创建 ： 使用字典</h3><p>索引会自动分配，并且对列进行了排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df = pd.DataFrame(&#123;<span class="string">'col1'</span>:[<span class="number">1</span>,<span class="number">3</span>,<span class="number">11</span>,<span class="number">2</span>],<span class="string">'col2'</span>:[<span class="number">9</span>,<span class="number">23</span>,<span class="number">0</span>,<span class="number">2</span>]&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df</span><br><span class="line">   col1  col2</span><br><span class="line"><span class="number">0</span>     <span class="number">1</span>     <span class="number">9</span></span><br><span class="line"><span class="number">1</span>     <span class="number">3</span>    <span class="number">23</span></span><br><span class="line"><span class="number">2</span>    <span class="number">11</span>     <span class="number">0</span></span><br><span class="line"><span class="number">3</span>     <span class="number">2</span>     <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="数据访问-1"><a href="#数据访问-1" class="headerlink" title="数据访问"></a>数据访问</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.iloc[:<span class="number">2</span>,:<span class="number">2</span>]</span><br><span class="line">   col1  col2</span><br><span class="line"><span class="number">0</span>     <span class="number">1</span>     <span class="number">9</span></span><br><span class="line"><span class="number">1</span>     <span class="number">3</span>    <span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df[<span class="string">'col1'</span>]</span><br><span class="line"><span class="number">0</span>     <span class="number">1</span></span><br><span class="line"><span class="number">1</span>     <span class="number">3</span></span><br><span class="line"><span class="number">2</span>    <span class="number">11</span></span><br><span class="line"><span class="number">3</span>     <span class="number">2</span></span><br><span class="line">Name: col1, dtype: int64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.col1</span><br><span class="line"><span class="number">0</span>     <span class="number">1</span></span><br><span class="line"><span class="number">1</span>     <span class="number">3</span></span><br><span class="line"><span class="number">2</span>    <span class="number">11</span></span><br><span class="line"><span class="number">3</span>     <span class="number">2</span></span><br><span class="line">Name: col1, dtype: int64</span><br></pre></td></tr></table></figure>
<h3 id="聚集和统计-1"><a href="#聚集和统计-1" class="headerlink" title="聚集和统计"></a>聚集和统计</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df = pd.DataFrame(&#123;<span class="string">'col1'</span>:[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],<span class="string">'col2'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df</span><br><span class="line">   col1  col2</span><br><span class="line"><span class="number">0</span>     <span class="number">1</span>     <span class="number">1</span></span><br><span class="line"><span class="number">1</span>     <span class="number">1</span>     <span class="number">2</span></span><br><span class="line"><span class="number">2</span>     <span class="number">0</span>     <span class="number">3</span></span><br><span class="line"><span class="number">3</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grp = df.groupby(<span class="string">'col1'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grp.get_group(<span class="number">0</span>)</span><br><span class="line">   col1  col2</span><br><span class="line"><span class="number">2</span>     <span class="number">0</span>     <span class="number">3</span></span><br><span class="line"><span class="number">3</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grp.get_group(<span class="number">1</span>)</span><br><span class="line">   col1  col2</span><br><span class="line"><span class="number">0</span>     <span class="number">1</span>     <span class="number">1</span></span><br><span class="line"><span class="number">1</span>     <span class="number">1</span>     <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grp.sum()</span><br><span class="line">      col2</span><br><span class="line">col1</span><br><span class="line"><span class="number">0</span>        <span class="number">7</span></span><br><span class="line"><span class="number">1</span>        <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="产生新列"><a href="#产生新列" class="headerlink" title="产生新列"></a>产生新列</h3><p>给一个不存在的列赋值，将会创建一个新的列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df[<span class="string">'sum_col'</span>]=df.eval(<span class="string">'col1+col2'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df</span><br><span class="line">   col1  col2  sum_col</span><br><span class="line"><span class="number">0</span>     <span class="number">1</span>     <span class="number">1</span>        <span class="number">2</span></span><br><span class="line"><span class="number">1</span>     <span class="number">1</span>     <span class="number">2</span>        <span class="number">3</span></span><br><span class="line"><span class="number">2</span>     <span class="number">0</span>     <span class="number">3</span>        <span class="number">3</span></span><br><span class="line"><span class="number">3</span>     <span class="number">0</span>     <span class="number">4</span>        <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grp = df.groupby([<span class="string">'sum_col'</span>,<span class="string">'col1'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = grp.sum()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line">              col2</span><br><span class="line">sum_col col1</span><br><span class="line"><span class="number">2</span>       <span class="number">1</span>        <span class="number">1</span></span><br><span class="line"><span class="number">3</span>       <span class="number">0</span>        <span class="number">3</span></span><br><span class="line">        <span class="number">1</span>        <span class="number">2</span></span><br><span class="line"><span class="number">4</span>       <span class="number">0</span>        <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.unstack()</span><br><span class="line">        col2</span><br><span class="line">col1       <span class="number">0</span>    <span class="number">1</span></span><br><span class="line">sum_col</span><br><span class="line"><span class="number">2</span>        NaN  <span class="number">1.0</span></span><br><span class="line"><span class="number">3</span>        <span class="number">3.0</span>  <span class="number">2.0</span></span><br><span class="line"><span class="number">4</span>        <span class="number">4.0</span>  NaN</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Markdown中编写LaTex数学公式]]></title>
      <url>http://keyunluo.github.io/2016/07/19/2016-07-19-markdown-math.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>目前hexo中写博客使用Markdown语言，而写博客经常要用到一些数学公式，在Markdown中写LaTeX数学公式则显得非常重要，本节将一些常用的数学公式的写法记录下来，以备日后查询。</p>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="LaTeX-基本语法"><a href="#LaTeX-基本语法" class="headerlink" title="$\LaTeX$基本语法"></a>$\LaTeX$基本语法</h2><ul>
<li><strong>使用LaTeX</strong></li>
</ul>
<p><code>$</code>符号开始</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$ y_k=<span class="tag">\<span class="name">varphi</span></span>(u_k+v_k)$</span></span><br><span class="line"><span class="formula">$J<span class="tag">\<span class="name">alpha</span></span>(x) = <span class="tag">\<span class="name">sum</span><span class="string">&#123;m=0&#125;</span></span>^<span class="tag">\<span class="name">infty</span></span> <span class="tag">\<span class="name">frac</span><span class="string">&#123;(-1)^m&#125;</span><span class="string">&#123;m! \Gamma (m + \alpha + 1)&#125;</span></span> &#123;<span class="tag">\<span class="name">left</span></span>(&#123; <span class="tag">\<span class="name">frac</span><span class="string">&#123;x&#125;</span><span class="string">&#123;2&#125;</span></span> &#125;<span class="tag">\<span class="name">right</span></span>)&#125;^&#123;2m + <span class="tag">\<span class="name">alpha</span></span>&#125;$</span></span><br><span class="line">#注意下面的写法：(右对齐)</span><br><span class="line"><span class="formula">$$ y_k=<span class="tag">\<span class="name">varphi</span></span>(u_k+v_k)$$</span></span><br></pre></td></tr></table></figure>
<p>则依次显示为：</p>
<p>$ y_k=\varphi(u_k+v_k)$</p>
<p>$J\alpha(x) = \sum{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha}$</p>
<p>$$ y_k=\varphi(u_k+v_k)$$</p>
<ul>
<li><strong>输入上下标</strong></li>
</ul>
<p><code>^</code>表示上标, <code>_</code>表示下标。如果上下标的内容多于一个字符，要用<code>{}</code>把这些内容括起来当成一个整体。上下标是可以嵌套的，也可以同时使用。例如：
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$x^&#123;y^z&#125;=(1+&#123;<span class="tag">\<span class="name">rm</span></span> e&#125;^x)^&#123;-2xy^w&#125;$</span></span><br><span class="line"><span class="formula">$f(x)=x_2^3+1$</span></span><br><span class="line">#如果要在左右两边都有上下标，可以用<span class="tag">\<span class="name">sideset</span></span>命令:</span><br><span class="line"><span class="formula">$<span class="tag">\<span class="name">sideset</span><span class="string">&#123;^12&#125;</span><span class="string">&#123;^34&#125;</span></span><span class="tag">\<span class="name">bigotimes</span></span>$</span></span><br></pre></td></tr></table></figure></p>
<p>则显示如下：</p>
<p>$x^{y^z}=(1+{\rm e}^x)^{-2xy^w}$</p>
<p>$f(x)=x_2^3+1$</p>
<p>$\sideset{^12}{^34}\bigotimes$</p>
<ul>
<li><strong>输入括号和分隔符</strong></li>
</ul>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">()、[]和|表示自己，&#123;&#125;表示&#123;&#125;。当要显示大号的括号或分隔符时，要用<span class="tag">\<span class="name">left</span></span>和<span class="tag">\<span class="name">right</span></span>命令：</span><br><span class="line"><span class="formula">$f(x,y,z) = 3y^2z <span class="tag">\<span class="name">left</span></span>( 3+<span class="tag">\<span class="name">frac</span><span class="string">&#123;7x+5&#125;</span><span class="string">&#123;1+y^2&#125;</span></span> <span class="tag">\<span class="name">right</span></span>)$</span></span><br><span class="line">有时候要用<span class="tag">\<span class="name">left</span></span>.或<span class="tag">\<span class="name">right</span></span>.进行匹配而不显示本身：</span><br><span class="line"><span class="formula">$<span class="tag">\<span class="name">frac</span><span class="string">&#123;du&#125;</span><span class="string">&#123;dt&#125;</span></span>  <span class="tag">\<span class="name">|</span></span> _&#123;x=0&#125;$</span></span><br></pre></td></tr></table></figure>
<p>显示为：</p>
<p>$f(x,y,z) = 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right)$</p>
<p>$\frac{du}{dt}  | _{x=0}$</p>
<ul>
<li><strong>微分方程</strong></li>
</ul>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$<span class="tag">\<span class="name">frac</span><span class="string">&#123;du&#125;</span><span class="string">&#123;dt&#125;</span></span> and <span class="tag">\<span class="name">frac</span><span class="string">&#123;d^2 u&#125;</span><span class="string">&#123;dx^2&#125;</span></span>$</span></span><br></pre></td></tr></table></figure>
<p>$\frac{du}{dt} and \frac{d^2 u}{dx^2}$</p>
<ul>
<li><strong>输入偏微分方程</strong></li>
</ul>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$$</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;eqnarray&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">frac</span><span class="string">&#123;\partial u&#125;</span><span class="string">&#123;\partial t&#125;</span></span> <span class="tag">\<span class="name">\</span></span><br><span class="line">= </span>h^2 <span class="tag">\<span class="name">left</span></span>( <span class="tag">\<span class="name">frac</span><span class="string">&#123;\partial^2 u&#125;</span><span class="string">&#123;\partial x^2&#125;</span></span> <span class="tag">\<span class="name">\</span></span></span><br><span class="line"><span class="tag">\<span class="name">+</span></span> <span class="tag">\<span class="name">frac</span><span class="string">&#123;\partial^2 u&#125;</span><span class="string">&#123;\partial y^2&#125;</span></span> <span class="tag">\<span class="name">\</span></span></span><br><span class="line"><span class="tag">\<span class="name">+</span></span> <span class="tag">\<span class="name">frac</span><span class="string">&#123;\partial^2 u&#125;</span><span class="string">&#123;\partial z^2&#125;</span></span><span class="tag">\<span class="name">right</span></span>)</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;eqnarray&#125;</span></span></span><br><span class="line">$$</span></span><br></pre></td></tr></table></figure>
<p>$$
\begin{eqnarray}
\frac{\partial u}{\partial t} \
= h^2 \left( \frac{\partial^2 u}{\partial x^2} \
+ \frac{\partial^2 u}{\partial y^2} \
+ \frac{\partial^2 u}{\partial z^2}\right)
\end{eqnarray}
$$</p>
<ul>
<li><strong>输入分数</strong></li>
</ul>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$<span class="tag">\<span class="name">frac</span><span class="string">&#123;1&#125;</span><span class="string">&#123;3&#125;</span></span>$</span></span><br><span class="line"><span class="formula">$P(v)=<span class="tag">\<span class="name">frac</span><span class="string">&#123;1&#125;</span><span class="string">&#123;1+exp(-v/T)&#125;</span></span>$</span></span><br></pre></td></tr></table></figure>
<p>  依次显示为：
  $\frac{1}{3}$</p>
<p>  $P(v)=\frac{1}{1+exp(-v/T)}$</p>
<ul>
<li><strong>输入开方</strong>
\sqrt</li>
</ul>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$<span class="tag">\<span class="name">sqrt</span><span class="string">&#123;2&#125;</span></span>$</span></span><br><span class="line"><span class="formula">$<span class="tag">\<span class="name">sqrt</span><span class="string">[n]</span><span class="string">&#123;3&#125;</span></span>$</span></span><br></pre></td></tr></table></figure>
<p>  $\sqrt{2}$</p>
<p>  $\sqrt[n]{3}$</p>
<ul>
<li><strong>输入省略号</strong>
数学公式中常见的省略号有两种，<strong>\ldots</strong>表示与文本底线对齐的省略号，<strong>\cdots</strong>表示与文本中线对齐的省略号。</li>
</ul>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$f(x_1,x_2,<span class="tag">\<span class="name">ldots</span></span>,x_n) = x_1^2 + x_2^2 + <span class="tag">\<span class="name">cdots</span></span> + x_n^2$</span></span><br></pre></td></tr></table></figure>
<p>   $f(x_1,x_2,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2$</p>
<ul>
<li><strong>输入向量</strong></li>
</ul>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$<span class="tag">\<span class="name">vec</span><span class="string">&#123;a&#125;</span></span> <span class="tag">\<span class="name">cdot</span></span> <span class="tag">\<span class="name">vec</span><span class="string">&#123;b&#125;</span>=<span class="number">0</span></span>$</span></span><br></pre></td></tr></table></figure>
<p>  $\vec{a} \cdot \vec{b}=0$</p>
<ul>
<li><strong>输入积分</strong></li>
</ul>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$<span class="tag">\<span class="name">int</span></span>_0^1 x^2 &#123;<span class="tag">\<span class="name">rm</span></span> d&#125;x$</span></span><br></pre></td></tr></table></figure>
<p>  $\int_0^1 x^2 {\rm d}x$</p>
<ul>
<li><strong>输入极限运算</strong></li>
</ul>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$<span class="tag">\<span class="name">lim</span></span>_&#123;n <span class="tag">\<span class="name">rightarrow</span></span> +<span class="tag">\<span class="name">infty</span></span>&#125; <span class="tag">\<span class="name">frac</span><span class="string">&#123;1&#125;</span><span class="string">&#123;n(n+1)&#125;</span></span>$</span></span><br><span class="line"><span class="formula">$<span class="tag">\<span class="name">frac</span><span class="string">&#123;1&#125;</span><span class="string">&#123;\lim_&#123;u \rightarrow \infty&#125;</span></span>&#125;, <span class="tag">\<span class="name">frac</span><span class="string">&#123;1&#125;</span><span class="string">&#123;\lim\limits_&#123;u \rightarrow \infty&#125;</span></span>&#125;$</span></span><br></pre></td></tr></table></figure>
<p>$\lim_{n \rightarrow +\infty} \frac{1}{n(n+1)}$</p>
<p>$\frac{1}{\lim_{u \rightarrow \infty}}$</p>
<p>$\frac{1}{\lim\limits_{u \rightarrow \infty}}$</p>
<ul>
<li><strong>输入累加、累乘运算</strong></li>
</ul>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$<span class="tag">\<span class="name">sum</span></span>_&#123;i=0&#125;^n <span class="tag">\<span class="name">frac</span><span class="string">&#123;1&#125;</span><span class="string">&#123;i^2&#125;</span></span>$</span></span><br><span class="line"><span class="formula">$<span class="tag">\<span class="name">prod</span></span>_&#123;i=0&#125;^n <span class="tag">\<span class="name">frac</span><span class="string">&#123;1&#125;</span><span class="string">&#123;i^2&#125;</span></span>$</span></span><br></pre></td></tr></table></figure>
<p> $\sum_{i=0}^n \frac{1}{i^2}$</p>
<p> $\prod_{i=0}^n \frac{1}{i^2}$</p>
<ul>
<li><strong>等效</strong></li>
</ul>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$$</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line">$&#123;<span class="tag">\<span class="name">frac</span><span class="string">&#123;3&#125;</span><span class="string">&#123;5&#125;</span></span> [3 + 2*( a+ b)]&#125;$</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line">$$</span></span><br><span class="line"></span><br><span class="line"><span class="formula">$$</span><br><span class="line">$&#123;<span class="tag">\<span class="name">frac</span><span class="string">&#123;3&#125;</span><span class="string">&#123;5&#125;</span></span> [3 + 2*( a+ b)]&#125;$</span><br><span class="line">$$</span></span><br></pre></td></tr></table></figure>
<p>${\frac{3}{5} [3 + 2*( a+ b)]}$</p>
<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><table>
<thead>
<tr>
<th style="text-align:center">希腊字母(小写)</th>
<th style="text-align:left">输入</th>
<th style="text-align:center">希腊字母(大写)</th>
<th style="text-align:left">输入</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">α</td>
<td style="text-align:left">\alpha</td>
<td style="text-align:center">Α</td>
<td style="text-align:left">A</td>
</tr>
<tr>
<td style="text-align:center">β</td>
<td style="text-align:left">\beta</td>
<td style="text-align:center">Β</td>
<td style="text-align:left">B</td>
</tr>
<tr>
<td style="text-align:center">γ</td>
<td style="text-align:left">\gamma</td>
<td style="text-align:center">Γ</td>
<td style="text-align:left">\Gamma</td>
</tr>
<tr>
<td style="text-align:center">δ</td>
<td style="text-align:left">\delta</td>
<td style="text-align:center">Δ</td>
<td style="text-align:left">\Delta</td>
</tr>
<tr>
<td style="text-align:center">ε或$\epsilon$</td>
<td style="text-align:left">\epsilon或\varepsilon</td>
<td style="text-align:center">Ε</td>
<td style="text-align:left">E</td>
</tr>
<tr>
<td style="text-align:center">ζ</td>
<td style="text-align:left">\zeta</td>
<td style="text-align:center">Ζ</td>
<td style="text-align:left">Z</td>
</tr>
<tr>
<td style="text-align:center">η</td>
<td style="text-align:left">\eta</td>
<td style="text-align:center">Η</td>
<td style="text-align:left">H</td>
</tr>
<tr>
<td style="text-align:center">θ或$\vartheta$</td>
<td style="text-align:left">\theta或\vartheta</td>
<td style="text-align:center">Θ</td>
<td style="text-align:left">\Theta</td>
</tr>
<tr>
<td style="text-align:center">ι</td>
<td style="text-align:left">\iota　</td>
<td style="text-align:center">Ι</td>
<td style="text-align:left">I</td>
</tr>
<tr>
<td style="text-align:center">κ</td>
<td style="text-align:left">\kappa</td>
<td style="text-align:center">Κ</td>
<td style="text-align:left">K</td>
</tr>
<tr>
<td style="text-align:center">λ</td>
<td style="text-align:left">\lambda</td>
<td style="text-align:center">Λ</td>
<td style="text-align:left">\Lambda</td>
</tr>
<tr>
<td style="text-align:center">μ</td>
<td style="text-align:left">\mu</td>
<td style="text-align:center">Μ</td>
<td style="text-align:left">M</td>
</tr>
<tr>
<td style="text-align:center">ν</td>
<td style="text-align:left">\nu</td>
<td style="text-align:center">Ν</td>
<td style="text-align:left">N</td>
</tr>
<tr>
<td style="text-align:center">ξ</td>
<td style="text-align:left">\xi</td>
<td style="text-align:center">Ξ</td>
<td style="text-align:left">\Xi</td>
</tr>
<tr>
<td style="text-align:center">ο</td>
<td style="text-align:left">o</td>
<td style="text-align:center">Ο</td>
<td style="text-align:left">O</td>
</tr>
<tr>
<td style="text-align:center">π或$\varpi$</td>
<td style="text-align:left">\pi或\varpi</td>
<td style="text-align:center">Π</td>
<td style="text-align:left">\Pi</td>
</tr>
<tr>
<td style="text-align:center">ρ或$\varrho$</td>
<td style="text-align:left">\rho或\varrho</td>
<td style="text-align:center">Ρ</td>
<td style="text-align:left">P</td>
</tr>
<tr>
<td style="text-align:center">σ或$\varsigma$</td>
<td style="text-align:left">\sigma或\varsigma</td>
<td style="text-align:center">Σ</td>
<td style="text-align:left">\Sigma</td>
</tr>
<tr>
<td style="text-align:center">τ</td>
<td style="text-align:left">\tau</td>
<td style="text-align:center">Τ</td>
<td style="text-align:left">T</td>
</tr>
<tr>
<td style="text-align:center">υ</td>
<td style="text-align:left">\upsilon</td>
<td style="text-align:center">Υ</td>
<td style="text-align:left">\Upsilon</td>
</tr>
<tr>
<td style="text-align:center">φ或$\varphi$</td>
<td style="text-align:left">\phi或\varphi</td>
<td style="text-align:center">Φ</td>
<td style="text-align:left">\Phi　</td>
</tr>
<tr>
<td style="text-align:center">χ</td>
<td style="text-align:left">\chi</td>
<td style="text-align:center">Χ</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:center">ψ</td>
<td style="text-align:left">\psi</td>
<td style="text-align:center">Ψ</td>
<td style="text-align:left">\Psi</td>
</tr>
<tr>
<td style="text-align:center">ω</td>
<td style="text-align:left">\omega</td>
<td style="text-align:center">Ω</td>
<td style="text-align:left">\Omega</td>
</tr>
</tbody>
</table>
<h2 id="三角函数与逻辑数学字符"><a href="#三角函数与逻辑数学字符" class="headerlink" title="三角函数与逻辑数学字符"></a>三角函数与逻辑数学字符</h2><table>
<thead>
<tr>
<th style="text-align:center">数学字符</th>
<th style="text-align:center">输入</th>
<th style="text-align:center">数学字符</th>
<th style="text-align:center">输入</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\pm$</td>
<td style="text-align:center">\pm</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">\times</td>
</tr>
<tr>
<td style="text-align:center">$\div$</td>
<td style="text-align:center">\div</td>
<td style="text-align:center">$\mid$</td>
<td style="text-align:center">\mid</td>
</tr>
<tr>
<td style="text-align:center">$\nmid$</td>
<td style="text-align:center">\nmid</td>
<td style="text-align:center">$\cdot$</td>
<td style="text-align:center">\cdot</td>
</tr>
<tr>
<td style="text-align:center">$\circ$</td>
<td style="text-align:center">\circ</td>
<td style="text-align:center">$\ast$</td>
<td style="text-align:center">\ast</td>
</tr>
<tr>
<td style="text-align:center">$\bigodot$</td>
<td style="text-align:center">\bigodot</td>
<td style="text-align:center">$\bigotimes$</td>
<td style="text-align:center">\bigotimes</td>
</tr>
<tr>
<td style="text-align:center">$\bigoplus$</td>
<td style="text-align:center">\bigoplus</td>
<td style="text-align:center">$\leq$</td>
<td style="text-align:center">\leq</td>
</tr>
<tr>
<td style="text-align:center">$\geq$</td>
<td style="text-align:center">\geq</td>
<td style="text-align:center">$\neq$</td>
<td style="text-align:center">\neq</td>
</tr>
<tr>
<td style="text-align:center">$\approx$</td>
<td style="text-align:center">\approx</td>
<td style="text-align:center">$\equiv$</td>
<td style="text-align:center">\equiv</td>
</tr>
<tr>
<td style="text-align:center">$\sum$</td>
<td style="text-align:center">\sum</td>
<td style="text-align:center">$\prod$</td>
<td style="text-align:center">\prod</td>
</tr>
<tr>
<td style="text-align:center">$\coprod$</td>
<td style="text-align:center">\coprod</td>
<td style="text-align:center">$\emptyset$</td>
<td style="text-align:center">\emptyset</td>
</tr>
<tr>
<td style="text-align:center">$\in$</td>
<td style="text-align:center">\in</td>
<td style="text-align:center">$\notin$</td>
<td style="text-align:center">\notin</td>
</tr>
<tr>
<td style="text-align:center">$\subset$</td>
<td style="text-align:center">\subset</td>
<td style="text-align:center">$\supset$</td>
<td style="text-align:center">\supset</td>
</tr>
<tr>
<td style="text-align:center">$\subseteq$</td>
<td style="text-align:center">\subseteq</td>
<td style="text-align:center">$\supseteq$</td>
<td style="text-align:center">\supseteq</td>
</tr>
<tr>
<td style="text-align:center">$\bigcap$</td>
<td style="text-align:center">\bigcap</td>
<td style="text-align:center">$\bigcup$</td>
<td style="text-align:center">\bigcup</td>
</tr>
<tr>
<td style="text-align:center">$\bigvee$</td>
<td style="text-align:center">\bigvee</td>
<td style="text-align:center">$\bigwedge$</td>
<td style="text-align:center">\bigwedge</td>
</tr>
<tr>
<td style="text-align:center">$\biguplus$</td>
<td style="text-align:center">\biguplus</td>
<td style="text-align:center">$\bigsqcup$</td>
<td style="text-align:center">\bigsqcup</td>
</tr>
<tr>
<td style="text-align:center">$\log$</td>
<td style="text-align:center">\log</td>
<td style="text-align:center">$\lg$</td>
<td style="text-align:center">\lg</td>
</tr>
<tr>
<td style="text-align:center">$\ln$</td>
<td style="text-align:center">\ln</td>
<td style="text-align:center">$\bot$</td>
<td style="text-align:center">\bot</td>
</tr>
<tr>
<td style="text-align:center">$\angle$</td>
<td style="text-align:center">\angle</td>
<td style="text-align:center">$30^\circ$</td>
<td style="text-align:center">30^\circ</td>
</tr>
<tr>
<td style="text-align:center">$\sin$</td>
<td style="text-align:center">\sin</td>
<td style="text-align:center">$\cos$</td>
<td style="text-align:center">\cos</td>
</tr>
<tr>
<td style="text-align:center">$\tan$</td>
<td style="text-align:center">\tan</td>
<td style="text-align:center">$\cot$</td>
<td style="text-align:center">\cot</td>
</tr>
<tr>
<td style="text-align:center">$\sec$</td>
<td style="text-align:center">\sec</td>
<td style="text-align:center">$\csc$</td>
<td style="text-align:center">\csc</td>
</tr>
<tr>
<td style="text-align:center">$\prime$</td>
<td style="text-align:center">\prime</td>
<td style="text-align:center">$\int$</td>
<td style="text-align:center">\int</td>
</tr>
<tr>
<td style="text-align:center">$\iint$</td>
<td style="text-align:center">\iint</td>
<td style="text-align:center">$\iiint$</td>
<td style="text-align:center">\iiint</td>
</tr>
<tr>
<td style="text-align:center">$\iiiint$</td>
<td style="text-align:center">\iiiint</td>
<td style="text-align:center">$\oint$</td>
<td style="text-align:center">\oint</td>
</tr>
<tr>
<td style="text-align:center">$\lim$</td>
<td style="text-align:center">\lim</td>
<td style="text-align:center">$\infty$</td>
<td style="text-align:center">\infty</td>
</tr>
<tr>
<td style="text-align:center">$\nabla$</td>
<td style="text-align:center">\nabla</td>
<td style="text-align:center">$\because$</td>
<td style="text-align:center">\because</td>
</tr>
<tr>
<td style="text-align:center">$\therefore$</td>
<td style="text-align:center">\therefore</td>
<td style="text-align:center">$\forall$</td>
<td style="text-align:center">\forall</td>
</tr>
<tr>
<td style="text-align:center">$\exists$</td>
<td style="text-align:center">\exists</td>
<td style="text-align:center">$\not=$</td>
<td style="text-align:center">\not=</td>
</tr>
<tr>
<td style="text-align:center">$\not&gt;$</td>
<td style="text-align:center">\not&gt;</td>
<td style="text-align:center">$\not\subset$</td>
<td style="text-align:center">\not\subset</td>
</tr>
<tr>
<td style="text-align:center">$\hat{y}$</td>
<td style="text-align:center">\hat{y}</td>
<td style="text-align:center">$\check{y}$</td>
<td style="text-align:center">\check{y}</td>
</tr>
<tr>
<td style="text-align:center">$\breve{y}$</td>
<td style="text-align:center">\breve{y}</td>
<td style="text-align:center">$\overline{a+b+c+d}$</td>
<td style="text-align:center">\overline{a+b+c+d}</td>
</tr>
<tr>
<td style="text-align:center">$\underline{a+b+c+d}$</td>
<td style="text-align:center">\underline{a+b+c+d}</td>
<td style="text-align:center">$\overbrace{a+\underbrace{b+c}{1.0}+d}^{2.0}$</td>
<td style="text-align:center">\overbrace{a+\underbrace{b+c}{1.0}+d}^{2.0}</td>
</tr>
<tr>
<td style="text-align:center">$\uparrow$</td>
<td style="text-align:center">\uparrow</td>
<td style="text-align:center">$\downarrow$</td>
<td style="text-align:center">\downarrow</td>
</tr>
<tr>
<td style="text-align:center">$\Uparrow$</td>
<td style="text-align:center">\Uparrow</td>
<td style="text-align:center">$\Downarrow$</td>
<td style="text-align:center">\Downarrow</td>
</tr>
<tr>
<td style="text-align:center">$\rightarrow$</td>
<td style="text-align:center">\rightarrow</td>
<td style="text-align:center">$\leftarrow$</td>
<td style="text-align:center">\leftarrow</td>
</tr>
<tr>
<td style="text-align:center">$\Rightarrow$</td>
<td style="text-align:center">\Rightarrow</td>
<td style="text-align:center">$\Leftarrow$</td>
<td style="text-align:center">\Leftarrow</td>
</tr>
<tr>
<td style="text-align:center">$\longrightarrow$</td>
<td style="text-align:center">\longrightarrow</td>
<td style="text-align:center">$\longleftarrow$</td>
<td style="text-align:center">\longleftarrow</td>
</tr>
<tr>
<td style="text-align:center">$\Longrightarrow$</td>
<td style="text-align:center">\Longrightarrow</td>
<td style="text-align:center">$\Longleftarrow$</td>
<td style="text-align:center">\Longleftarrow</td>
</tr>
<tr>
<td style="text-align:center">$\ $</td>
<td style="text-align:center">\空格</td>
<td style="text-align:center">#</td>
<td style="text-align:center">\#</td>
</tr>
</tbody>
</table>
<h2 id="字体转换"><a href="#字体转换" class="headerlink" title="字体转换"></a>字体转换</h2><p>要对公式的某一部分字符进行字体转换，可以用{\rm 需转换的部分字符}命令，其中\rm可以参照下表选择合适的字体。一般情况下，公式默认为意大利体。</p>
<p><code>\rm</code>　　罗马体</p>
<p><code>\it</code>　　意大利体</p>
<p><code>\bf</code>　　黑体　</p>
<p><code>\sf</code>　　等线体</p>
<p><code>\mit</code> 　数学斜体　</p>
<p><code>\tt</code>　打字机字体</p>
<p><code>\sc</code>　　小体大写字母</p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$$<span class="tag">\<span class="name">\</span></span>begin&#123;array&#125;&#123;c|lcr&#125;</span><br><span class="line">n &amp; <span class="tag">\<span class="name">text</span><span class="string">&#123;Left&#125;</span></span> &amp; <span class="tag">\<span class="name">text</span><span class="string">&#123;Center&#125;</span></span> &amp; <span class="tag">\<span class="name">text</span><span class="string">&#123;Right&#125;</span></span> <span class="tag">\<span class="name">\</span></span><span class="tag">\<span class="name">\</span></span></span><br><span class="line"><span class="tag">\<span class="name">hline</span></span></span><br><span class="line">1 &amp; 0.24 &amp; 1 &amp; 125 <span class="tag">\<span class="name">\</span></span><span class="tag">\<span class="name">\</span></span></span><br><span class="line">2 &amp; -1 &amp; 189 &amp; -8 <span class="tag">\<span class="name">\</span></span><span class="tag">\<span class="name">\</span></span></span><br><span class="line">3 &amp; -20 &amp; 2000 &amp; 1+10i <span class="tag">\<span class="name">\</span></span><span class="tag">\<span class="name">\</span></span></span><br><span class="line"><span class="tag">\<span class="name">\</span></span>end&#123;array&#125; $$</span></span><br></pre></td></tr></table></figure>
<p>$$\begin{array}{c|lcr}
n &amp; \text{Left} &amp; \text{Center} &amp; \text{Right} \\
\hline
1 &amp; 0.24 &amp; 1 &amp; 125 \\
2 &amp; -1 &amp; 189 &amp; -8 \\
3 &amp; -20 &amp; 2000 &amp; 1+10i \\
\end{array} $$</p>
<h2 id="花括号用法"><a href="#花括号用法" class="headerlink" title="花括号用法"></a>花括号用法</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$$f(x)=</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;cases&#125;</span></span></span><br><span class="line">0&amp; <span class="tag">\<span class="name">text</span><span class="string">&#123;x=0&#125;</span></span><span class="tag">\<span class="name">\</span></span></span><br><span class="line">1&amp; <span class="tag">\<span class="name">text</span><span class="string">&#123;x!=0&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;cases&#125;</span></span>$$</span></span><br></pre></td></tr></table></figure>
<p>$$
f(x)=
\begin{cases}
0&amp; \text{x=0}\\
1&amp; \text{x!=0}
\end{cases}
$$</p>
<h2 id="多行数学式对齐"><a href="#多行数学式对齐" class="headerlink" title="多行数学式对齐"></a>多行数学式对齐</h2><p><strong>利用&amp;符号来对齐，在每个等号前添加&amp;符号即可</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$$<span class="tag">\<span class="name">begin</span><span class="string">&#123;array&#125;</span></span> &#123;lcl&#125;</span><br><span class="line"><span class="tag">\<span class="name">cos</span></span> 2<span class="tag">\<span class="name">theta</span></span> &amp; = &amp; <span class="tag">\<span class="name">cos</span></span>^2 <span class="tag">\<span class="name">theta</span></span> - <span class="tag">\<span class="name">sin</span></span>^2 <span class="tag">\<span class="name">theta</span></span> <span class="tag">\<span class="name">\</span></span><span class="tag">\<span class="name">\</span></span></span><br><span class="line">             &amp; = &amp; 2 <span class="tag">\<span class="name">cos</span></span>^2 <span class="tag">\<span class="name">theta</span></span> - 1.</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;array&#125;</span></span>$$</span></span><br><span class="line"></span><br><span class="line"><span class="formula">$$<span class="tag">\<span class="name">begin</span><span class="string">&#123;array&#125;</span></span> &#123;lcl&#125;</span><br><span class="line">f(x) &amp; = &amp; (a+b)^2 <span class="tag">\<span class="name">\</span></span><span class="tag">\<span class="name">\</span></span></span><br><span class="line">     &amp; = &amp; a^2+2ab+b^2</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;array&#125;</span></span>$$</span></span><br></pre></td></tr></table></figure>
<p>$$\begin{array} {lcl}
\cos 2\theta &amp; = &amp; \cos^2 \theta - \sin^2 \theta \\
             &amp; = &amp; 2 \cos^2 \theta - 1.
\end{array}$$</p>
<p>$$\begin{array} {lcl}
f(x) &amp; = &amp; (a+b)^2 \\
     &amp; = &amp; a^2+2ab+b^2
\end{array}$$</p>
<h2 id="矩阵与行列式"><a href="#矩阵与行列式" class="headerlink" title="矩阵与行列式"></a>矩阵与行列式</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$$</span><br><span class="line">matrix</span><br><span class="line">[ ( <span class="tag">\<span class="name">begin</span><span class="string">&#123;array&#125;</span><span class="string">&#123;ccc&#125;</span></span></span><br><span class="line">a &amp; b &amp; c <span class="tag">\<span class="name">\</span></span><span class="tag">\<span class="name">\</span></span></span><br><span class="line">d &amp; e &amp; f <span class="tag">\<span class="name">\</span></span><span class="tag">\<span class="name">\</span></span></span><br><span class="line">g &amp; h &amp; i <span class="tag">\<span class="name">end</span><span class="string">&#123;array&#125;</span></span> )]$$</span></span><br><span class="line"></span><br><span class="line"><span class="formula">$$</span><br><span class="line">[ <span class="tag">\<span class="name">chi</span></span>(<span class="tag">\<span class="name">lambda</span></span>) = <span class="tag">\<span class="name">left</span></span>| <span class="tag">\<span class="name">begin</span><span class="string">&#123;array&#125;</span><span class="string">&#123;ccc&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">lambda</span></span> - a &amp; -b &amp; -c <span class="tag">\<span class="name">\</span></span><span class="tag">\<span class="name">\</span></span></span><br><span class="line">-d &amp; <span class="tag">\<span class="name">lambda</span></span> - e &amp; -f <span class="tag">\<span class="name">\</span></span><span class="tag">\<span class="name">\</span></span></span><br><span class="line">-g &amp; -h &amp; <span class="tag">\<span class="name">lambda</span></span> - i <span class="tag">\<span class="name">end</span><span class="string">&#123;array&#125;</span></span> <span class="tag">\<span class="name">right</span></span>|.]</span><br><span class="line">$$</span></span><br><span class="line"></span><br><span class="line"><span class="formula">$$ <span class="tag">\<span class="name">left</span><span class="string">[</span><br><span class="line">      \begin&#123;array&#125;&#123;cc|c&#125;</span><br><span class="line">        1&amp;2&amp;3 \\\\</span><br><span class="line">        4&amp;5&amp;6</span><br><span class="line">      \end&#123;array&#125;</span><br><span class="line">    \right]</span></span></span><br><span class="line">$$</span></span><br></pre></td></tr></table></figure>
<p>$$
matrix
[ ( \begin{array}{ccc}
a &amp; b &amp; c \\
d &amp; e &amp; f \\
g &amp; h &amp; i \end{array} )]$$</p>
<p>$$
[ \chi(\lambda) = \left| \begin{array}{ccc}
\lambda - a &amp; -b &amp; -c \\
-d &amp; \lambda - e &amp; -f \\
-g &amp; -h &amp; \lambda - i \end{array} \right|.]
$$</p>
<p>$$ \left[
      \begin{array}{cc|c}
        1&amp;2&amp;3 \\
        4&amp;5&amp;6
      \end{array}
    \right]
$$</p>
<h2 id="括号的其他用法"><a href="#括号的其他用法" class="headerlink" title="括号的其他用法"></a>括号的其他用法</h2><table>
<thead>
<tr>
<th style="text-align:left">功能</th>
<th style="text-align:left">语法</th>
<th style="text-align:center">显示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">圆括号，小括号</td>
<td style="text-align:left">\left( \frac{a}{b} \right)</td>
<td style="text-align:center">$\left( \frac{a}{b} \right)$</td>
</tr>
<tr>
<td style="text-align:left">方括号，中括号</td>
<td style="text-align:left">\left[ \frac{a}{b} \right]</td>
<td style="text-align:center">$$\left[ \frac{a}{b} \right]$$</td>
</tr>
<tr>
<td style="text-align:left">花括号，大括号</td>
<td style="text-align:left">\left{ \frac{a}{b}\right}</td>
<td style="text-align:center">$$\left\{ \frac{a}{b} \right\}$$</td>
</tr>
<tr>
<td style="text-align:left">角括号</td>
<td style="text-align:left">\left \langle \frac{a}{b} \right \rangle</td>
<td style="text-align:center">$\left \langle \frac{a}{b} \right \rangle$</td>
</tr>
<tr>
<td style="text-align:left">单竖线，绝对值</td>
<td style="text-align:left">\left\mid \frac{a}{b} \right\mid ,或\vert</td>
<td style="text-align:center">$\mid \frac{a}{b} \mid$</td>
</tr>
<tr>
<td style="text-align:left">双竖线，范式</td>
<td style="text-align:left">\Vert \frac{a}{b} \Vert</td>
<td style="text-align:center">$$\Vert \frac{a}{b} \Vert$$</td>
</tr>
<tr>
<td style="text-align:left">取整函数</td>
<td style="text-align:left">\left \lfloor \frac{a}{b} \right \rfloor</td>
<td style="text-align:center">$\left \lfloor \frac{a}{b} \right \rfloor$</td>
</tr>
<tr>
<td style="text-align:left">取顶函数</td>
<td style="text-align:left">\left \lceil \frac{c}{d} \right \rceil</td>
<td style="text-align:center">$\left \lceil \frac{c}{d} \right \rceil   $</td>
</tr>
<tr>
<td style="text-align:left">斜线与反斜线</td>
<td style="text-align:left">\left / \frac{a}{b} \right \backslash</td>
<td style="text-align:center">$\left / \frac{a}{b} \right \backslash$</td>
</tr>
<tr>
<td style="text-align:left">上下箭头</td>
<td style="text-align:left">\left \uparrow \frac{a}{b} \right \downarrow</td>
<td style="text-align:center">$\left \uparrow \frac{a}{b} \right \downarrow$</td>
</tr>
<tr>
<td style="text-align:left">混合括号1</td>
<td style="text-align:left">\left [ 0,1 \right )</td>
<td style="text-align:center">$\left [ 0,1 \right )$</td>
</tr>
<tr>
<td style="text-align:left">混合括号2</td>
<td style="text-align:left">\langle \psi  \mid</td>
<td style="text-align:center">$\langle \psi  \mid $</td>
</tr>
<tr>
<td style="text-align:left">单左括号</td>
<td style="text-align:left">\left { \frac{a}{b} \right .</td>
<td style="text-align:center">$$\left \{ \frac{a}{b} \right .$$</td>
</tr>
<tr>
<td style="text-align:left">单右括号</td>
<td style="text-align:left">\left . \frac{a}{b} \right }</td>
<td style="text-align:center">$$\left . \frac{a}{b} \right \}$$</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python Scipy学习(1)]]></title>
      <url>http://keyunluo.github.io/2016/07/19/2016-07-19-python-scipy.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>SciPy是另一种使用NumPy来做高等数学、信号处理、优化、统计和许多其它科学任务的语言扩展,SciPy在NumPy的基础上增加了众多的数学、科学以及工程计算中常用的模块。例如线性代数、常微分方程数值求解、信号处理、图像处理、稀疏矩阵等等,本节主要学习其统计和优化模块。</p>
</blockquote>
<a id="more"></a>
<h2 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h2><p>由于SciPy以NumPy为基础，那么import scipy的同时便import 了numpy库。</p>
<ul>
<li>统计子库-scipy.stats</li>
<li>线性代数-scipy.linalg</li>
<li>拟合与优化-scipy.optimize</li>
<li>插值-scipy.interpolate</li>
<li>数值积分-scipy.integate</li>
<li>稀疏矩阵-scipy.sparse</li>
<li>图像操作scipy.misc</li>
<li>图像处理-scipy.ndimage</li>
</ul>
<h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><p>scipy.stats的主要功能有以下几个方面：</p>
<ol>
<li>数值随机变量对象（包括密度分布函数，累积分布函数，样本函数等）</li>
<li>一些估计方法</li>
<li>一些测试方法</li>
</ol>
<ul>
<li>随机变量与分布:考虑$Beta$函数</li>
</ul>
<p>numpy 中提供了获取随机变量的样本的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: np.random.beta(<span class="number">5</span>, <span class="number">5</span>, size=<span class="number">3</span>)</span><br><span class="line">Out[<span class="number">2</span>]: array([ <span class="number">0.6167565</span> ,  <span class="number">0.67994589</span>,  <span class="number">0.32346476</span>])</span><br></pre></td></tr></table></figure>
<p>但是np.random.beta(a,b)是根据下面的函数得到的：</p>
<p>$f(x;a,b)=\frac{x^{(a-1)}(1-x)^{(b-1)} }{\int_0^1 u^{(a-1)}u^{(b-1)} {\rm d}u} , (0 \le x \le 1)$</p>
<p>为了获取更多beta分布的特性，我们经常使用scipy.stats:
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> beta</span><br><span class="line"><span class="keyword">from</span> matplotlib.pyplot <span class="keyword">import</span> hist, plot, show</span><br><span class="line">q = beta(<span class="number">5</span>, <span class="number">5</span>)      <span class="comment"># Beta(a, b), with a = b = 5 q是一个对象</span></span><br><span class="line">obs = q.rvs(<span class="number">2000</span>)   <span class="comment"># 2000 observations 获得2000个样本</span></span><br><span class="line">hist(obs, bins=<span class="number">40</span>, normed=<span class="keyword">True</span>)</span><br><span class="line">grid = np.linspace(<span class="number">0.01</span>, <span class="number">0.99</span>, <span class="number">100</span>)</span><br><span class="line">plot(grid, q.pdf(grid), <span class="string">'k-'</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure></p>
<p>结果如图：
<img src="/resource/blog/2016-07/beta.png" alt="beta分布特性"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.cdf(<span class="number">0.4</span>)      <span class="comment"># Cumulative distribution function  累积密度函数</span></span><br><span class="line"><span class="number">0.26656768000000003</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.pdf(<span class="number">0.4</span>)      <span class="comment"># Density function   密度函数</span></span><br><span class="line"><span class="number">2.0901888000000013</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.ppf(<span class="number">0.8</span>)      <span class="comment"># Quantile (inverse cdf) function</span></span><br><span class="line"><span class="number">0.63391348346427079</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.mean()</span><br><span class="line"><span class="number">0.5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>线性回归</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">19</span>]: <span class="keyword">from</span> scipy.stats <span class="keyword">import</span> linregress</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: x = np.random.randn(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: y = <span class="number">2</span> * x + <span class="number">0.1</span> * np.random.randn(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: gradient, intercept, r_value, p_value, std_err = linregress(x, y)</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: gradient, intercept</span><br><span class="line">Out[<span class="number">23</span>]: (<span class="number">1.9962554379482236</span>, <span class="number">0.008172822032671799</span>)</span><br></pre></td></tr></table></figure>
<h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><p>NumPy和SciPy都提供了线性代数函数库linalg，SciPy的线性代数库比NumPy更加全面。</p>
<ul>
<li>解线性方程组</li>
</ul>
<p><code>numpy.linalg.solve(A, b)</code>和<code>scipy.linalg.solve(A, b)</code>可以用来解线性方程组$Ax = b $，也就是计算$ x = A^{-1}b$ 。这里$A$为(M, M)的方形矩阵，$x$和$b$为长为M的向量。有时候$A$是固定的，需要对多组$b$进行求解，因此第二个参数也可以是(M, N)的矩阵$B$。这样计算出来的$X$也为(M, N)的矩阵。它相当于计算$A^{-1}B$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> scipy <span class="keyword">import</span> linalg</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>M, N = <span class="number">500</span>, <span class="number">50</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = np.random.rand(M, M)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B = np.random.rand(M, N)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X1 = linalg.solve(A, B)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X2 = np.dot(linalg.inv(A), B)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.allclose(X1, X2)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>lu_factor(A)对矩阵$A$进行LU分解，得到一个元组：(LU矩阵，排序数组)，将这个元组传递给lu_solve(),即可对不同的$B$进行求解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>luf = linalg.lu_factor(A)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X3 = linalg.lu_solve(luf, B)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.allclose(X1, X3)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<ul>
<li>最小二乘解</li>
</ul>
<p>lstsq()比solve()更一般化，它不要求矩阵$A$是正方形的，也就是说方程的个数可以少于、等于或者多于未知数的个数。它找到一组解$x$，使得$\Vert b - A \cdot x \Vert$最小。我们称所得到的结果为最小二乘解，即它使得所有等式的误差的平方和最小。</p>
<ul>
<li>奇异值分解-SVD</li>
</ul>
<p>奇异值分解是线性代数中一种重要的矩阵分解，在信号处理、统计学等领域有重要应用。假设$M$是一个m×n阶矩阵，存在一个分解使得：$ M = U \sum V^{*} $。其中$U$是m×m阶矩阵；$ \sum $是半正定m×n阶对角矩阵；而$V^*$，即$V$的共轭转置，是n×n阶矩阵。这样的分解就称作$M$的奇异值分解。$ \sum $对角线上的元素为$M$的奇异值。通常奇异值按照从大到小的顺序排列。</p>
<h2 id="拟合与优化"><a href="#拟合与优化" class="headerlink" title="拟合与优化"></a>拟合与优化</h2><ul>
<li>求根与稳定点</li>
</ul>
<p>稳定点：已知连续函数$f(x)$ ,则函数$f(x)$的稳定点为$x_0$，使得条件$f(x_0) = x_0$成立。</p>
<p>例如：$f(x)=sin(4(x-\frac{1}{4})) + x + x^{20} -1$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> bisect</span><br><span class="line">f =<span class="keyword">lambda</span> x : np.sin(<span class="number">4</span> * (x <span class="number">-0.25</span>)) + x + x**<span class="number">20</span> <span class="number">-1</span></span><br><span class="line">bisect(f,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="number">0.4082935042797544</span></span><br></pre></td></tr></table></figure>
<ul>
<li>非线性方程组求解</li>
</ul>
<p>fsolve()可以对非线性方程组进行求解。它的基本调用形式为fsolve(func, x0)。其中func是计算方程组误差的函数，它的参数x是一个数组，其值为方程组的一组可能的解。func返回将x代入方程组之后得到的每个方程的误差，x0为未知数的一组初始值。假设要对下面的方程组进行求解:
$$ f1(u1,u2,u3) = 0 ,f2(u1,u2,u3) = 0 , f3(u1,u2,u3) = 0 $$</p>
<p>那么func函数可以如下定义：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></span><br><span class="line">    u1,u2,u3 = x</span><br><span class="line">    <span class="keyword">return</span> [f1(u1,u2,u3), f2(u1,u2,u3), f3(u1,u2,u3)]</span><br></pre></td></tr></table></figure></p>
<p>例如：对下列方程组求解：
$$ 5x_1 +3 =0;4x_0^2 - 2sin(x_1x_2)=0;x_1x_2-1.5=0$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sin, cos</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> optimize</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    x0, x1, x2 = x.tolist()</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="number">5</span>*x1+<span class="number">3</span>,</span><br><span class="line">        <span class="number">4</span>*x0*x0 - <span class="number">2</span>*sin(x1*x2),</span><br><span class="line">        x1*x2 - <span class="number">1.5</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># f计算方程组的误差，[1,1,1]是未知数的初始值</span></span><br><span class="line">result = optimize.fsolve(f, [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line">print(result)</span><br><span class="line">print(f(result))</span><br></pre></td></tr></table></figure>
<p>f()是计算方程组的误差的函数，x参数是一组可能的解。fsolve()在调用f()时，传递给f()的参数是一个数组。</p>
<p>调用fsolve()时，传递计算误差的函数f()，以及未知数的初始值。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python Matplotlib绘图基础]]></title>
      <url>http://keyunluo.github.io/2016/07/18/2016-07-18-python-matplotlib.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>Matplotlib 是python最著名的绘图库，它提供了一整套和matlab相似的命令API，十分适合交互式地进行制图。而且也可以方便地将它作为绘图控件，嵌入GUI应用程序中。。</p>
</blockquote>
<a id="more"></a>
<h2 id="简单绘图"><a href="#简单绘图" class="headerlink" title="简单绘图"></a>简单绘图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建多项式 1*x^2+0*x+0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func = np.poly1d(np.array([<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]).astype(float))</span><br><span class="line"><span class="comment"># 一阶导数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func1 = func.deriv(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 在-10,10之间产生100个均匀分布的数值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.linspace(<span class="number">-10</span>,<span class="number">10</span>,<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = func(x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y1 = func1(x)</span><br><span class="line"><span class="comment"># 绘制两条曲线 分别为红色r和蓝色b</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pyplot.plot(x,y,<span class="string">'r'</span>,x,y1,<span class="string">'b'</span>)</span><br><span class="line">[&lt;matplotlib.lines.Line2D object at <span class="number">0xb2eeefec</span>&gt;, &lt;matplotlib.lines.Line2D object at <span class="number">0xb2ef46ac</span>&gt;]</span><br><span class="line"><span class="comment"># 横轴标签</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pyplot.xlabel(<span class="string">'x'</span>)</span><br><span class="line">&lt;matplotlib.text.Text object at <span class="number">0xb2f37e4c</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pyplot.ylabel(<span class="string">'y'</span>)</span><br><span class="line">&lt;matplotlib.text.Text object at <span class="number">0xb3083c8c</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pyplot.show()</span><br></pre></td></tr></table></figure>
<p>生成如下图像:
<img src="/resource/blog/2016-07/简单绘图.png" alt="简单绘图"></p>
<h2 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">func = np.poly1d(np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]).astype(float))</span><br><span class="line">x = np.linspace(<span class="number">-10</span>,<span class="number">10</span>,<span class="number">100</span>)</span><br><span class="line">y = func(x)</span><br><span class="line">func1 = func.deriv(<span class="number">1</span>)</span><br><span class="line">y1 = func1(x)</span><br><span class="line">func2 = func.deriv(<span class="number">2</span>)</span><br><span class="line">y2 = func2(x)</span><br><span class="line"><span class="comment"># subplot()创建子图，第一个参数为子图的行数，第二个参数是子图的列数，第三个参数是序号</span></span><br><span class="line">pyplot.subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">pyplot.plot(x,y,<span class="string">'r'</span>)</span><br><span class="line"><span class="comment"># 子图标题</span></span><br><span class="line">pyplot.title(<span class="string">'Polynomail'</span>)</span><br><span class="line"></span><br><span class="line">pyplot.subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">pyplot.plot(x,y1,<span class="string">'b'</span>)</span><br><span class="line">pyplot.title(<span class="string">'Firse Derivative'</span>)</span><br><span class="line"></span><br><span class="line">pyplot.subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">pyplot.plot(x,y2,<span class="string">'y'</span>)</span><br><span class="line">pyplot.title(<span class="string">'Second Derivative'</span>)</span><br><span class="line"></span><br><span class="line">pyplot.xlabel(<span class="string">'x'</span>)</span><br><span class="line">pyplot.ylabel(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">pyplot.show()</span><br></pre></td></tr></table></figure>
<p>生成如下图像：
<img src="/resource/blog/2016-07/子图.png" alt="绘制子图"></p>
<h2 id="绘制3维图像"><a href="#绘制3维图像" class="headerlink" title="绘制3维图像"></a>绘制3维图像</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> cm</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,projection=<span class="string">'3d'</span>)</span><br><span class="line">u = linspace(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 创建2维坐标网络</span></span><br><span class="line">x,y = meshgrid(u,u)</span><br><span class="line">z = x**<span class="number">2</span>+y**<span class="number">2</span></span><br><span class="line"><span class="comment"># 指定行和列的步长，并指定颜色</span></span><br><span class="line">ax.plot_surface(x,y,z,rstride=<span class="number">4</span>,cstride=<span class="number">4</span>,cmap=cm.binary_r)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>生成如下图像:
<img src="/resource/blog/2016-07/三维图像.png" alt="三维图像"></p>
<h2 id="绘制等高线图"><a href="#绘制等高线图" class="headerlink" title="绘制等高线图"></a>绘制等高线图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> cm</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line">fig = plt.figure()</span><br><span class="line"><span class="comment"># 这里不需要指定三维参数 projection='3d'</span></span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">u = linspace(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">x,y = meshgrid(u,u)</span><br><span class="line">z = x**<span class="number">2</span>+y**<span class="number">2</span></span><br><span class="line">ax.contourf(x,y,z)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>生成如下图像:
<img src="/resource/blog/2016-07/等高线图.png" alt="等高线图"></p>
<h2 id="绘制动画"><a href="#绘制动画" class="headerlink" title="绘制动画"></a>绘制动画</h2><p>首先新建了图片、坐标和一条空白的线作为全局变量。然后init方法是一个初始化的方法，什么都不干。animate方法中的参数i表示当前帧数，通过正弦函数接受i生成了坐标集合，并且更新到线条中去。接下来新建了anim对象，几个参数的名称都很好懂，最后一个blit方法是告诉matplotlib记得在每帧之前擦除init方法返回的那些图元。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> animation</span><br><span class="line"></span><br><span class="line"><span class="comment"># first set up the figure, the axis, and the plot element we want to animate</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = plt.axes(xlim=(<span class="number">0</span>, <span class="number">2</span>), ylim=(<span class="number">-2</span>, <span class="number">2</span>))</span><br><span class="line">line, = ax.plot([], [], lw=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># initialization function: plot the background of each frame</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">()</span>:</span></span><br><span class="line">    line.set_data([], [])</span><br><span class="line">    <span class="keyword">return</span> line,</span><br><span class="line"></span><br><span class="line"><span class="comment"># animation function.  this is called sequentially</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">animate</span><span class="params">(i)</span>:</span></span><br><span class="line">    x = np.linspace(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1000</span>)</span><br><span class="line">    y = np.sin(<span class="number">2</span> * np.pi * (x - <span class="number">0.01</span> * i))</span><br><span class="line">    line.set_data(x, y)</span><br><span class="line">    <span class="keyword">return</span> line,</span><br><span class="line"></span><br><span class="line"><span class="comment"># call the animator.  blit=true means only re-draw the parts that have changed.</span></span><br><span class="line">anim = animation.FuncAnimation(fig, animate, init_func=init,</span><br><span class="line">                               frames=<span class="number">200</span>, interval=<span class="number">20</span>, blit=<span class="keyword">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>生成如下图像:
<img src="/resource/blog/2016-07/animation.gif" alt="动画"></p>
<h2 id="导出GIF"><a href="#导出GIF" class="headerlink" title="导出GIF"></a>导出GIF</h2><ul>
<li>安装ImageMagick</li>
<li><p>配置matplotlib</p>
<p>先看看自己的配置文件放在了哪里：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.matplotlib_fname()</span><br><span class="line"><span class="string">'/usr/local/anaconda3/lib/python3.5/site-packages/matplotlib/mpl-data/matplotlibrc'</span></span><br></pre></td></tr></table></figure>
<p>取消“animation.convert_path”前面的注释，这样应该就配置好了，接下来用一句话就可以导出gif：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anim.save(<span class="string">'perceptron.gif'</span>, fps=<span class="number">2</span>, writer=<span class="string">'imagemagick'</span>)</span><br></pre></td></tr></table></figure>
<p>但是，出现了错误：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UserWarning: imagemagick MovieWriter unavailable</span><br><span class="line">warnings.warn (<span class="string">"% s MovieWriter unavailable"</span> writer%)</span><br></pre></td></tr></table></figure>
<p>此时，需要打开matplotlib的安装目录<code>/usr/local/anaconda3/lib/python3.5/site-packages/matplotlib/__init__.py</code>，在1131行<code>rcParams = rc_params()</code>下面添加一句：<code>rcParams[&#39;animation.convert_path&#39;] = &#39;/usr/bin/convert&#39;</code>，这样就好了。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python Numpy中的矩阵]]></title>
      <url>http://keyunluo.github.io/2016/07/18/2016-07-18-python-numpy-matrix.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>本篇博文记录Numpy的矩阵一般用法，主要学习numpy在线性代数中的应用。</p>
</blockquote>
<a id="more"></a>
<h2 id="创建矩阵"><a href="#创建矩阵" class="headerlink" title="创建矩阵"></a>创建矩阵</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 行与行之间用分号隔开，行内的元素之间用空格隔开</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = np.mat(<span class="string">'1 2 3;4 5 6;7 8 9'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">matrix([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">        [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br></pre></td></tr></table></figure>
<h2 id="矩阵转置"><a href="#矩阵转置" class="headerlink" title="矩阵转置"></a>矩阵转置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 transpose 来获取转置矩阵</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.transpose(m)</span><br><span class="line">matrix([[<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]])</span><br><span class="line"><span class="comment"># 使用 T 属性获取转置矩阵</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.T</span><br><span class="line">matrix([[<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]])</span><br></pre></td></tr></table></figure>
<h2 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># inv</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = np.matrix(<span class="string">'1 1 2;-1 2 0;1 1 3'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.linalg.inv(m)</span><br><span class="line">matrix([[ <span class="number">2.</span>        , <span class="number">-0.33333333</span>, <span class="number">-1.33333333</span>],</span><br><span class="line">        [ <span class="number">1.</span>        ,  <span class="number">0.33333333</span>, <span class="number">-0.66666667</span>],</span><br><span class="line">        [<span class="number">-1.</span>        ,  <span class="number">0.</span>        ,  <span class="number">1.</span>        ]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># I</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = np.matrix(<span class="string">'1 1 2;-1 2 0;1 1 3'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.I</span><br><span class="line">matrix([[ <span class="number">2.</span>        , <span class="number">-0.33333333</span>, <span class="number">-1.33333333</span>],</span><br><span class="line">        [ <span class="number">1.</span>        ,  <span class="number">0.33333333</span>, <span class="number">-0.66666667</span>],</span><br><span class="line">        [<span class="number">-1.</span>        ,  <span class="number">0.</span>        ,  <span class="number">1.</span>        ]])</span><br></pre></td></tr></table></figure>
<h2 id="分块矩阵"><a href="#分块矩阵" class="headerlink" title="分块矩阵"></a>分块矩阵</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.eye(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a * <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.bmat(<span class="string">'a b;a b'</span>)</span><br><span class="line">matrix([[ <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">2.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">2.</span>],</span><br><span class="line">        [ <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">2.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">2.</span>]])</span><br></pre></td></tr></table></figure>
<h2 id="线性代数-numpy-linalg模块包含线性代数函数"><a href="#线性代数-numpy-linalg模块包含线性代数函数" class="headerlink" title="线性代数:numpy.linalg模块包含线性代数函数"></a>线性代数:numpy.linalg模块包含线性代数函数</h2><ul>
<li>常用 numpy.linglg 函数</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>diag</td>
<td>返回一个方阵的对角线（或非对角线）元素为一个一维数组，或者转换一个一维数组到一个方阵（非对角线元素为零）</td>
</tr>
<tr>
<td>dot</td>
<td>矩阵乘积</td>
</tr>
<tr>
<td>trace</td>
<td>计算对角线上元素的和</td>
</tr>
<tr>
<td>det</td>
<td>计算矩阵行列式</td>
</tr>
<tr>
<td>eig</td>
<td>计算方阵的特征值和特征向量</td>
</tr>
<tr>
<td>inv</td>
<td>计算方阵的逆</td>
</tr>
<tr>
<td>pinv</td>
<td>计算方阵 Moore-Penrose pseudo-inverse 的转置</td>
</tr>
<tr>
<td>qr</td>
<td>计算 QR 分解</td>
</tr>
<tr>
<td>svd</td>
<td>计算奇异值分解（SVD）</td>
</tr>
<tr>
<td>solve</td>
<td>求解线性系统方程 Ax = b 的x，其中A是一个方阵</td>
</tr>
<tr>
<td>lstsq</td>
<td>计算 y = Xb 的最小二乘解</td>
</tr>
</tbody>
</table>
<ul>
<li>求解 $Ax=b$ 的线性方程组</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1x-2y+z=0</span></span><br><span class="line"><span class="comment"># 2y-8z=8</span></span><br><span class="line"><span class="comment"># -4x+5y+9z=-9</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = np.mat(<span class="string">'1 -2 1;0 2 -8;-4 5 9'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.array([<span class="number">0</span>,<span class="number">8</span>,<span class="number">-9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.linalg.solve(A,b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(x)</span><br><span class="line">[ <span class="number">29.</span>  <span class="number">16.</span>   <span class="number">3.</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(np.dot(A,x))</span><br><span class="line">[[ <span class="number">0.</span>  <span class="number">8.</span> <span class="number">-9.</span>]]</span><br></pre></td></tr></table></figure>
<ul>
<li>特征值和特征向量</li>
</ul>
<p>设$A$为$n$阶矩阵，若存在常数$λ$及$n$维非零向量$x$，使得$Ax=λx$，则称$λ$是矩阵$A$的特征值，$x$是$A$属于特征值$λ$的特征向量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a =np.matrix(<span class="string">'-1 1 0;-4 3 0;1 0 2'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># eigvals()返回特征值</span></span><br><span class="line"><span class="meta">... </span>np.linalg.eigvals(a)</span><br><span class="line">array([ <span class="number">2.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># eig()返回一个元组,第一项为特征值，第二项为对应的特征向量(按列排放)</span></span><br><span class="line"><span class="meta">... </span>np.linalg.eig(a)</span><br><span class="line">(array([ <span class="number">2.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>]), matrix([[ <span class="number">0.</span>        ,  <span class="number">0.40824829</span>,  <span class="number">0.40824829</span>],</span><br><span class="line">        [ <span class="number">0.</span>        ,  <span class="number">0.81649658</span>,  <span class="number">0.81649658</span>],</span><br><span class="line">        [ <span class="number">1.</span>        , <span class="number">-0.40824829</span>, <span class="number">-0.40824829</span>]]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment">#2  [0,0,1]</span></span><br><span class="line"><span class="meta">... </span><span class="comment">#1  [0.40824829,0.81649658,-0.40824829]</span></span><br><span class="line"><span class="meta">... </span><span class="comment">#验证</span></span><br><span class="line"><span class="meta">... </span>np.dot(a,[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">matrix([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.dot(<span class="number">2</span>,[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.dot(a,[<span class="number">0.40824829</span>,<span class="number">0.81649658</span>,<span class="number">-0.40824829</span>])</span><br><span class="line">matrix([[ <span class="number">0.40824829</span>,  <span class="number">0.81649658</span>, <span class="number">-0.40824829</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.dot(<span class="number">1</span>,[<span class="number">0.40824829</span>,<span class="number">0.81649658</span>,<span class="number">-0.40824829</span>])</span><br><span class="line">array([ <span class="number">0.40824829</span>,  <span class="number">0.81649658</span>, <span class="number">-0.40824829</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>奇异值分解</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = np.matrix(<span class="string">'4 11 14;8 7 -2'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>U,Sigma,V = np.linalg.svd(m)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Sigma)</span><br><span class="line">[ <span class="number">18.97366596</span>   <span class="number">9.48683298</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>广义逆矩阵: 摩尔－彭若斯广义逆</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = np.matrix(<span class="string">'4 11 14;8 7 -2'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = np.linalg.pinv(m)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(m*n)</span><br><span class="line">[[  <span class="number">1.00000000e+00</span>  <span class="number">-5.41233725e-16</span>]</span><br><span class="line"> [ <span class="number">-8.32667268e-17</span>   <span class="number">1.00000000e+00</span>]]</span><br><span class="line"><span class="comment">#近似单位阵</span></span><br></pre></td></tr></table></figure>
<ul>
<li>行列式计算</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = np.matrix(<span class="string">'4 6;8 2'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.linalg.det(m)</span><br><span class="line"><span class="number">-40.0</span></span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python Numpy中的数组]]></title>
      <url>http://keyunluo.github.io/2016/07/18/2016-07-18-python-numpy-array.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>NumPy 是 Numerical Python 的简称，是高性能计算和数据分析的基础包。本篇博文记录Numpy的数组一般用法，主要学习多维数组等用法。</p>
</blockquote>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Numpy是Python的一个科学计算的库，提供了矩阵运算的功能，其一般与Scipy、matplotlib一起使用。</p>
<p>NumPy的主要对象是同类型的多维数组。这种数组里面包含了一个表格的元素（通常是数字），所有的元素为同一个类型。由一个正整数组成的元组来索引。在NumPy中维度被称为<code>axes</code>(轴)，轴的数目被称为<code>rank</code>(秩)。</p>
<p>Numpy的主要作用如下：</p>
<ul>
<li>ndarray，快速和节省空间的多维数组，提供数组化的算术运算和高级的 广播 功能。</li>
<li>使用标准数学函数对整个数组的数据进行快速运算，而不需要编写循环。</li>
<li>读取/写入磁盘上的阵列数据和操作存储器映像文件的工具。</li>
<li>线性代数，随机数生成，和傅里叶变换的能力。</li>
<li>集成C，C++，Fortran代码的工具。</li>
</ul>
<p>从生态系统的角度看，最后一点是最为重要的。因为NumPy 提供了易用的<code>C API</code>，它可以很容易的将数据传递到使用低级语言编写的外部库，也可以使外部库返回NumPy数组数据到Python。 这一特性使得Python成为包装传统的C/C++/Fortran代码库，并给它们一个动态的、易于使用的接口的首选语言。</p>
<h2 id="多维数组对象"><a href="#多维数组对象" class="headerlink" title="多维数组对象"></a>多维数组对象</h2><p>在<code>NumPy</code>中表示数组的类为<code>ndarray</code>，别名就是array，注意，这里的<code>numpy.array</code>不同于Python标准库中的类<code>array.array</code>（这个数组只维护了一维的数组，仅仅提供了很少的函数方法）。下面是<code>ndarray</code>的重要属性：</p>
<ol>
<li><p><code>ndarray.ndim</code>
在ndarray数组中轴（维度）的数量。在Python的世界里，维度的数量又叫做rank。</p>
</li>
<li><p><code>ndarray.shape</code>
在ndarray中数组的形状，这是一个由正整数组成的元组来代表数组中每一个维度的大小。对于一个n*m的矩阵，shape就是(n,m)，因此，shape元组的长度代表的就是维度也就是ndim。</p>
</li>
<li><p><code>ndarray.size</code>
在ndarray数组中所有元素的数量，这个等于shape元组中相乘的数量。</p>
</li>
<li><p><code>ndarray.dtype</code>
描述数组中的元素的类型的对象。人们可以创建类型或者使用python标准库中的类型来指定dtype。另外，NumPy也提供了它自己的类型，比如numpy.int32,numpy.int16,numpy.float64等。</p>
</li>
<li><p><code>ndarray.itemsize</code>
描述数组中元素所占内存bytes的大小。举个例子，元素的类型为float64，那么itemsize就是8。这个值相当于ndarray.dtype.itemsize。</p>
</li>
<li><p><code>ndarray.data</code>
含有数组中实际元素的缓冲器（the buffer containing the actual elements of the array）。通常情况下，我们并不需要使用这个属性，因为我们将使用索引访问数组中的元素。</p>
</li>
</ol>
<p>例如如下操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: a = np.arange(<span class="number">15</span>).reshape(<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: a</span><br><span class="line">Out[<span class="number">3</span>]:</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: a.shape</span><br><span class="line">Out[<span class="number">4</span>]: (<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: a.ndim</span><br><span class="line">Out[<span class="number">5</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: a.dtype.name</span><br><span class="line">Out[<span class="number">6</span>]: <span class="string">'int64'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: a.itemsize</span><br><span class="line">Out[<span class="number">7</span>]: <span class="number">8</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: a.size</span><br><span class="line">Out[<span class="number">8</span>]: <span class="number">15</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: type(a)</span><br><span class="line">Out[<span class="number">9</span>]: numpy.ndarray</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: b = np.array([<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: b</span><br><span class="line">Out[<span class="number">11</span>]: array([<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: type(b)</span><br><span class="line">Out[<span class="number">12</span>]: numpy.ndarray</span><br></pre></td></tr></table></figure>
<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><ul>
<li><p>使用<code>numpy.array</code>方法，以<code>list</code>或<code>tuple</code>变量为参数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">13</span>]: c = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: d = np.array((<span class="number">1.2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: e = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: print(c,d,e,sep=<span class="string">'\n'</span>)</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span>]</span><br><span class="line">[ <span class="number">1.2</span>  <span class="number">3.</span>   <span class="number">4.</span>   <span class="number">5.</span> ]</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span>]]</span><br></pre></td></tr></table></figure>
<p>元素的类型也可以在创建数组的时候明确的指定：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">17</span>]: print(np.array([[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>]],dtype=complex))</span><br><span class="line">[[  <span class="number">2.</span>+<span class="number">0.j</span>   <span class="number">4.</span>+<span class="number">0.j</span>   <span class="number">6.</span>+<span class="number">0.j</span>]</span><br><span class="line"> [  <span class="number">8.</span>+<span class="number">0.j</span>  <span class="number">10.</span>+<span class="number">0.j</span>  <span class="number">12.</span>+<span class="number">0.j</span>]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用numpy.arange方法：产生连续的序列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">18</span>]: print(np.arange(<span class="number">2</span>,<span class="number">20</span>))</span><br><span class="line">[ <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: print(np.arange(<span class="number">2</span>,<span class="number">20</span>).reshape(<span class="number">3</span>,<span class="number">6</span>))</span><br><span class="line">[[ <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span>]</span><br><span class="line"> [<span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span>]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用numpy.linspace方法
：指定起点(包括)，终点(不包括),数据个数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">20</span>]: print(np.linspace(<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>))</span><br><span class="line">[ <span class="number">1.</span>          <span class="number">1.44444444</span>  <span class="number">1.88888889</span>  <span class="number">2.33333333</span>  <span class="number">2.77777778</span>  <span class="number">3.22222222</span></span><br><span class="line">  <span class="number">3.66666667</span>  <span class="number">4.11111111</span>  <span class="number">4.55555556</span>  <span class="number">5.</span>        ]</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用numpy.zeros，numpy.ones，numpy.eye等方法构造特定的矩阵</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">21</span>]: print(np.zeros((<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line">[[ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: print(np.ones((<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line">[[ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>]</span><br><span class="line"> [ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>]</span><br><span class="line"> [ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: print(np.eye(<span class="number">3</span>))</span><br><span class="line">[[ <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">1.</span>]]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>用于构建数组的标准函数的清单</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>array</td>
<td>转换输入数据（列表，数组或其它序列类型）到一个ndarray，可以推断一个dtype或明确的设置一个dtype。默认拷贝输入数据。</td>
</tr>
<tr>
<td>asarray</td>
<td>转换输入为一个ndarray，当输入已经是一个ndarray时就不拷贝。</td>
</tr>
<tr>
<td>arange</td>
<td>同内建的range函数，但不返回列表而是一个ndarray</td>
</tr>
<tr>
<td>ones, ones_like</td>
<td>根据提供的shape和dtype产生一个全1的数组。ones_like使用另一个数组为输入参数，产生一个shape和dtype都相同的数组。</td>
</tr>
<tr>
<td>zeros, zeros_like</td>
<td>同ones和ones_like，但是生成全0的数组</td>
</tr>
<tr>
<td>empty, enpty_like</td>
<td>通过分配新内存来构造新的数组，但不同与ones 和 zeros，不初始任何值。</td>
</tr>
<tr>
<td>eye, identity</td>
<td>生成一个NxN的单位方阵（对角线上为1，其它地方为0）</td>
</tr>
</tbody>
</table>
<h2 id="数组和纯量之间的操作"><a href="#数组和纯量之间的操作" class="headerlink" title="数组和纯量之间的操作"></a>数组和纯量之间的操作</h2><p>相同大小的数组间的算术运算，其操作作用在对应的元素上</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">24</span>]: e</span><br><span class="line">Out[<span class="number">24</span>]:</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: e*e</span><br><span class="line">Out[<span class="number">25</span>]:</span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">9</span>, <span class="number">16</span>],</span><br><span class="line">       [<span class="number">25</span>, <span class="number">36</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: <span class="number">1.5</span>*e</span><br><span class="line">Out[<span class="number">26</span>]:</span><br><span class="line">array([[ <span class="number">1.5</span>,  <span class="number">3.</span> ],</span><br><span class="line">       [ <span class="number">4.5</span>,  <span class="number">6.</span> ],</span><br><span class="line">       [ <span class="number">7.5</span>,  <span class="number">9.</span> ]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: e**<span class="number">0.5</span></span><br><span class="line">Out[<span class="number">27</span>]:</span><br><span class="line">array([[ <span class="number">1.</span>        ,  <span class="number">1.41421356</span>],</span><br><span class="line">       [ <span class="number">1.73205081</span>,  <span class="number">2.</span>        ],</span><br><span class="line">       [ <span class="number">2.23606798</span>,  <span class="number">2.44948974</span>]])</span><br><span class="line">In [<span class="number">28</span>]: <span class="number">2</span>*e<span class="number">-1</span></span><br><span class="line">Out[<span class="number">28</span>]:</span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">9</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure>
<p>跟其他矩阵操作语言不同的是，NumPy的数组中，操作符*的操作结果是矩阵中元素对应相乘，矩阵相乘可以使用dot函数和方法:
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">31</span>]: e</span><br><span class="line">Out[<span class="number">31</span>]:</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: f =np.array([<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: e.dot(f)</span><br><span class="line">Out[<span class="number">33</span>]: array([ <span class="number">8</span>, <span class="number">18</span>, <span class="number">28</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: np.dot(e,f)</span><br><span class="line">Out[<span class="number">34</span>]: array([ <span class="number">8</span>, <span class="number">18</span>, <span class="number">28</span>])</span><br></pre></td></tr></table></figure></p>
<h2 id="数组的索引和切片"><a href="#数组的索引和切片" class="headerlink" title="数组的索引和切片"></a>数组的索引和切片</h2><p>切片同list一样，非常方便。
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">39</span>]: arr = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: arr[<span class="number">4</span>]</span><br><span class="line">Out[<span class="number">40</span>]: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: arr[<span class="number">5</span>:<span class="number">8</span>]</span><br><span class="line">Out[<span class="number">41</span>]: array([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: arr[<span class="number">-1</span>]</span><br><span class="line">Out[<span class="number">42</span>]: <span class="number">9</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: arr2d = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: arr2d[<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">44</span>]: array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: arr2d[:<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">45</span>]:</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: arr2d[:<span class="number">2</span>,<span class="number">1</span>:]</span><br><span class="line">Out[<span class="number">46</span>]:</span><br><span class="line">array([[<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: arr2d[:, :<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">47</span>]:</span><br><span class="line">array([[<span class="number">1</span>],</span><br><span class="line">       [<span class="number">4</span>],</span><br><span class="line">       [<span class="number">7</span>]])</span><br></pre></td></tr></table></figure></p>
<p>多维数组可以在每一个轴上有一个索引，这些索引可以在元组里面用逗号分隔：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">48</span>]: <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    ...:     <span class="keyword">return</span> <span class="number">2</span>*x-y</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: g = np.fromfunction(f,(<span class="number">5</span>,<span class="number">4</span>),dtype=int)</span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: g</span><br><span class="line">Out[<span class="number">50</span>]:</span><br><span class="line">array([[ <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">1</span>,  <span class="number">0</span>, <span class="number">-1</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">3</span>,  <span class="number">2</span>,  <span class="number">1</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">5</span>,  <span class="number">4</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">7</span>,  <span class="number">6</span>,  <span class="number">5</span>]])</span><br><span class="line">In [<span class="number">51</span>]: g[<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">51</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: g[<span class="number">0</span>:<span class="number">5</span>,<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">52</span>]: array([<span class="number">-1</span>,  <span class="number">1</span>,  <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: g[:,<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">53</span>]: array([<span class="number">-1</span>,  <span class="number">1</span>,  <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>])</span><br></pre></td></tr></table></figure></p>
<h2 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h2><p>NumPy提供了相似的数学函数，例如<code>sin</code>,<code>cos</code>,<code>exp</code>等。在NumPy中，这些被叫做<code>universal function</code>，在NumPy里这些函数作用按数组的元素运算，然后产生一个新的数组作为输出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>B = np.arange(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.exp(B)</span><br><span class="line">array([ <span class="number">1.</span>        ,  <span class="number">2.71828183</span>,  <span class="number">7.3890561</span> ])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.sqrt(B)</span><br><span class="line">array([ <span class="number">0.</span>        ,  <span class="number">1.</span>        ,  <span class="number">1.41421356</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C = np.array([<span class="number">2.</span>, <span class="number">-1.</span>, <span class="number">4.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.add(B, C)</span><br><span class="line">array([ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">6.</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>单目运算</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>abs, fabs</td>
<td>计算基于元素的整形，浮点或复数的绝对值。fabs对于没有复数数据的快速版本</td>
</tr>
<tr>
<td>sqrt</td>
<td>计算每个元素的平方根。等价于 arr ** 0.5</td>
</tr>
<tr>
<td>square</td>
<td>计算每个元素的平方。等价于 arr ** 2</td>
</tr>
<tr>
<td>exp</td>
<td>计算每个元素的指数。</td>
</tr>
<tr>
<td>log, log10, log2, log1p</td>
<td>自然对数（基于e），基于10的对数，基于2的对数和 log(1 + x)</td>
</tr>
<tr>
<td>sign</td>
<td>计算每个元素的符号：1(positive)，0(zero)， -1(negative)</td>
</tr>
<tr>
<td>ceil</td>
<td>计算每个元素的天花板，即大于或等于每个元素的最小值</td>
</tr>
<tr>
<td>floor</td>
<td>计算每个元素的地板，即小于或等于每个元素的最大值</td>
</tr>
<tr>
<td>rint</td>
<td>圆整每个元素到最近的整数，保留dtype</td>
</tr>
<tr>
<td>modf</td>
<td>分别返回分数和整数部分的数组</td>
</tr>
<tr>
<td>isnan</td>
<td>返回布尔数组标识哪些元素是 NaN （不是一个数）</td>
</tr>
<tr>
<td>isfinite, isinf</td>
<td>分别返回布尔数组标识哪些元素是有限的（non-inf, non-NaN）或无限的</td>
</tr>
<tr>
<td>cos, cosh, sin sinh, tan, tanh  regular 和 hyperbolic</td>
<td>三角函数</td>
</tr>
<tr>
<td>arccos, arccosh, arcsin, arcsinh, arctan, arctanh</td>
<td>反三角函数</td>
</tr>
<tr>
<td>logical_not</td>
<td>计算基于元素的非x的真值。等价于 -arr</td>
</tr>
</tbody>
</table>
<ul>
<li>双目运算</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>add</td>
<td>在数组中添加相应的元素</td>
</tr>
<tr>
<td>substract</td>
<td>在第一个数组中减去第二个数组</td>
</tr>
<tr>
<td>multiply</td>
<td>对数组元素相乘</td>
</tr>
<tr>
<td>divide, floor_divide</td>
<td>除和地板除（去掉余数）</td>
</tr>
<tr>
<td>power</td>
<td>使用第二个数组作为指数提升第一个数组中的元素</td>
</tr>
<tr>
<td>maximum, fmax</td>
<td>基于元素的最大值。 fmax 忽略 NaN</td>
</tr>
<tr>
<td>minimum, fmin</td>
<td>基于元素的最小值。 fmin 忽略 NaN</td>
</tr>
<tr>
<td>mod</td>
<td>基于元素的模（取余）</td>
</tr>
<tr>
<td>copysign</td>
<td>拷贝第二个参数的符号到第一个参数</td>
</tr>
<tr>
<td>greater, greater_equal, less, less_equal, not_equal</td>
<td>基于元素的比较，产生布尔数组。等价于中缀操作符 &gt;, &gt;=, &lt;, &lt;=, ==, !=</td>
</tr>
<tr>
<td>logical_and, logical_or, logical_xor</td>
<td>计算各个元素逻辑操作的真值。等价于中缀操作符 &amp;, $\mid$ ,^</td>
</tr>
</tbody>
</table>
<h2 id="转置数组和交换坐标轴"><a href="#转置数组和交换坐标轴" class="headerlink" title="转置数组和交换坐标轴"></a>转置数组和交换坐标轴</h2><p>转置是一种特殊形式的变形，类似的它会返回基础数据的一个视窗，而不会拷贝任何东西。数组有<code>transpose</code>方法和专门的<code>T</code>属性：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">55</span>]: arr = np.arange(<span class="number">15</span>).reshape((<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">56</span>]: arr</span><br><span class="line">Out[<span class="number">56</span>]:</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">57</span>]: arr.T</span><br><span class="line">Out[<span class="number">57</span>]:</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">5</span>, <span class="number">10</span>],</span><br><span class="line">       [ <span class="number">1</span>,  <span class="number">6</span>, <span class="number">11</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">7</span>, <span class="number">12</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">8</span>, <span class="number">13</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">9</span>, <span class="number">14</span>]])</span><br></pre></td></tr></table></figure></p>
<p>当进行矩阵运算时，，使用 np.dot 计算内部矩阵来产生$X^TX$ ：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">58</span>]: np.dot(arr.T, arr)</span><br><span class="line">Out[<span class="number">58</span>]:</span><br><span class="line">array([[<span class="number">125</span>, <span class="number">140</span>, <span class="number">155</span>, <span class="number">170</span>, <span class="number">185</span>],</span><br><span class="line">       [<span class="number">140</span>, <span class="number">158</span>, <span class="number">176</span>, <span class="number">194</span>, <span class="number">212</span>],</span><br><span class="line">       [<span class="number">155</span>, <span class="number">176</span>, <span class="number">197</span>, <span class="number">218</span>, <span class="number">239</span>],</span><br><span class="line">       [<span class="number">170</span>, <span class="number">194</span>, <span class="number">218</span>, <span class="number">242</span>, <span class="number">266</span>],</span><br><span class="line">       [<span class="number">185</span>, <span class="number">212</span>, <span class="number">239</span>, <span class="number">266</span>, <span class="number">293</span>]])</span><br></pre></td></tr></table></figure></p>
<p>对于更高维的数组，<code>transpose</code>接受用于转置的坐标轴的号码的一个元组（for extra mind bending）：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">59</span>]: arr = np.arange(<span class="number">16</span>).reshape((<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: arr</span><br><span class="line">Out[<span class="number">60</span>]:</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">61</span>]: arr.transpose((<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line">Out[<span class="number">61</span>]:</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]]])</span><br><span class="line">In [<span class="number">62</span>]: arr.swapaxes(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">Out[<span class="number">62</span>]:</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">4</span>],</span><br><span class="line">        [ <span class="number">1</span>,  <span class="number">5</span>],</span><br><span class="line">        [ <span class="number">2</span>,  <span class="number">6</span>],</span><br><span class="line">        [ <span class="number">3</span>,  <span class="number">7</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">8</span>, <span class="number">12</span>],</span><br><span class="line">        [ <span class="number">9</span>, <span class="number">13</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">14</span>],</span><br><span class="line">        [<span class="number">11</span>, <span class="number">15</span>]]])</span><br></pre></td></tr></table></figure></p>
<h2 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#水平组合</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a * <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hstack((a,b))</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">0</span>,  <span class="number">2</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment">#垂直组合</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vstack((a,b))</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">       [ <span class="number">0</span>,  <span class="number">2</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以通过concatenate函数来进行组合</span></span><br><span class="line"><span class="comment"># NumPy中维度(dimensions)叫做轴(axis)，轴的个数叫做秩(rank)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>concatenate((a,b),axis=<span class="number">0</span>)</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">       [ <span class="number">0</span>,  <span class="number">2</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 深度组合</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dstack((a,b))</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line">        [ <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">        [ <span class="number">2</span>,  <span class="number">4</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">3</span>,  <span class="number">6</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">8</span>],</span><br><span class="line">        [ <span class="number">5</span>, <span class="number">10</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">6</span>, <span class="number">12</span>],</span><br><span class="line">        [ <span class="number">7</span>, <span class="number">14</span>],</span><br><span class="line">        [ <span class="number">8</span>, <span class="number">16</span>]]])</span><br></pre></td></tr></table></figure>
<h2 id="数组分割"><a href="#数组分割" class="headerlink" title="数组分割"></a>数组分割</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> a</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">6</span> <span class="number">7</span> <span class="number">8</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 水平分割</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hsplit(a,<span class="number">3</span>)</span><br><span class="line">[array([[<span class="number">0</span>],</span><br><span class="line">       [<span class="number">3</span>],</span><br><span class="line">       [<span class="number">6</span>]]), array([[<span class="number">1</span>],</span><br><span class="line">       [<span class="number">4</span>],</span><br><span class="line">       [<span class="number">7</span>]]), array([[<span class="number">2</span>],</span><br><span class="line">       [<span class="number">5</span>],</span><br><span class="line">       [<span class="number">8</span>]])]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 垂直分割</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vsplit(a,<span class="number">3</span>)</span><br><span class="line">[array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]]), array([[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]]), array([[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过split 指定轴进行分割</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>split(a,<span class="number">3</span>,axis=<span class="number">1</span>)</span><br><span class="line">[array([[<span class="number">0</span>],</span><br><span class="line">       [<span class="number">3</span>],</span><br><span class="line">       [<span class="number">6</span>]]), array([[<span class="number">1</span>],</span><br><span class="line">       [<span class="number">4</span>],</span><br><span class="line">       [<span class="number">7</span>]]), array([[<span class="number">2</span>],</span><br><span class="line">       [<span class="number">5</span>],</span><br><span class="line">       [<span class="number">8</span>]])]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 深度分割</span></span><br><span class="line"><span class="comment"># 必须三个维度以上的数组，</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = arange(<span class="number">24</span>).reshape(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dsplit(a,<span class="number">2</span>)</span><br><span class="line">[array([[[ <span class="number">0</span>,  <span class="number">1</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">9</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">12</span>, <span class="number">13</span>],</span><br><span class="line">        [<span class="number">16</span>, <span class="number">17</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">21</span>]]]), array([[[ <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">11</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">        [<span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">        [<span class="number">22</span>, <span class="number">23</span>]]])]</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python 基本数据结构]]></title>
      <url>http://keyunluo.github.io/2016/07/18/2016-07-18-python-datastructure.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>本篇博文学习并总结Python的基本数据结构常用用法，包括基本数据类型和四个比较重要的基本数据结构：列表，元组，字典，集合。
<a id="more"></a></p>
</blockquote>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ul>
<li>数字：数字数据类型用于存储数值。他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。
Python支持四种不同的数字类型：<ul>
<li>int（有符号整型）</li>
<li>long（长整型[也可以代表八进制和十六进制]）</li>
<li>float（浮点型）</li>
<li>complex（复数）</li>
</ul>
</li>
<li>布尔型：True和False</li>
<li>字符串：字符串或串(String)是由数字、字母、下划线组成的一串字符。从左到右索引默认0开始的，最大范围是字符串长度少1，从右到左索引默认-1开始的，最大范围是字符串开头。</li>
</ul>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><ul>
<li>基本方法</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>list.append(x)</td>
<td>把一个元素添加到列表的结尾，相当于 a[len(a):] = [x]。</td>
</tr>
<tr>
<td>list.extend(L)</td>
<td>通过添加指定列表的所有元素来扩充列表，相当于 a[len(a):] = L。</td>
</tr>
<tr>
<td>list.insert(i, x)</td>
<td>在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 a.insert(0, x) 会插入到整个列表之前，而 a.insert(len(a), x) 相当于 a.append(x) 。</td>
</tr>
<tr>
<td>list.remove(x)</td>
<td>删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。</td>
</tr>
<tr>
<td>list.pop([i])</td>
<td>从列表的指定位置删除元素，并将其返回。如果没有指定索引，a.pop()返回最后一个元素。元素随即从列表中被删除。（方法中 i 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号，你会经常在 Python 库参考手册中遇到这样的标记。）</td>
</tr>
<tr>
<td>list.clear()</td>
<td>移除列表中的所有项，等于del a[:]。</td>
</tr>
<tr>
<td>list.index(x)</td>
<td>返回列表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。</td>
</tr>
<tr>
<td>list.count(x)</td>
<td>返回 x 在列表中出现的次数。</td>
</tr>
<tr>
<td>list.sort()</td>
<td>对列表中的元素进行排序。</td>
</tr>
<tr>
<td>list.reverse()</td>
<td>倒排列表中的元素。</td>
</tr>
<tr>
<td>list.copy()</td>
<td>返回列表的浅复制，等于a[:]。</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">66.25</span>, <span class="number">333</span>, <span class="number">333</span>, <span class="number">1</span>, <span class="number">1234.5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a.count(<span class="number">333</span>), a.count(<span class="number">66.25</span>), a.count(<span class="string">'x'</span>))</span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.insert(<span class="number">2</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">333</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">66.25</span>, <span class="number">333</span>, <span class="number">-1</span>, <span class="number">333</span>, <span class="number">1</span>, <span class="number">1234.5</span>, <span class="number">333</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.index(<span class="number">333</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.remove(<span class="number">333</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">66.25</span>, <span class="number">-1</span>, <span class="number">333</span>, <span class="number">1</span>, <span class="number">1234.5</span>, <span class="number">333</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.reverse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">333</span>, <span class="number">1234.5</span>, <span class="number">1</span>, <span class="number">333</span>, <span class="number">-1</span>, <span class="number">66.25</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">-1</span>, <span class="number">1</span>, <span class="number">66.25</span>, <span class="number">333</span>, <span class="number">333</span>, <span class="number">1234.5</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>列表推导式</li>
</ul>
<p>列表推导式提供了从序列创建列表的简单途径。通常应用程序将一些操作应用于某个序列的每个元素，用其获得的结果作为生成新列表的元素，或者根据确定的判定条件创建子序列。
每个列表推导式都在 for 之后跟一个表达式，然后有零到多个 for 或 if 子句。返回结果是一个根据表达从其后的 for 和 if 上下文环境中生成出来的列表。如果希望表达式推导出一个元组，就必须使用括号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, range(<span class="number">10</span>)))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>] <span class="keyword">if</span> x != y]</span><br><span class="line">[(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">4</span>)]</span><br></pre></td></tr></table></figure>
<h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>元组由若干逗号分隔的值组成，里面的值是不可改变的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="number">12345</span>, <span class="number">54321</span>, <span class="string">'hello!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">0</span>]</span><br><span class="line"><span class="number">12345</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">12345</span>, <span class="number">54321</span>, <span class="string">'hello!'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Tuples may be nested:</span></span><br><span class="line"><span class="meta">... </span>u = t, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u</span><br><span class="line">((<span class="number">12345</span>, <span class="number">54321</span>, <span class="string">'hello!'</span>), (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Tuples are immutable:</span></span><br><span class="line"><span class="meta">... </span>t[<span class="number">0</span>] = <span class="number">88888</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># but they can contain mutable objects:</span></span><br><span class="line"><span class="meta">... </span>v = ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h2 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h2><p>另一个非常有用的 Python 内建数据类型是字典。列表是以连续的整数为索引，与此不同的是，字典以关键字为索引，关键字可以是任意不可变类型，通常用字符串或数值。
理解字典的最佳方式是把它看做无序的键=&gt;值对集合。在同一个字典之内，关键字必须是互不相同。一对大括号创建一个空的字典：{}。</p>
<p>字典的主要操作是依据键来存储和析取值。也可以用 del来删除键：值对（key:value）。如果你用一个已经存在的关键字存储值，以前为该关键字分配的值就会被遗忘。试图从一个不存在的键中取值会导致错误。</p>
<p>对一个字典执行 list(d.keys()) 将返回一个字典中所有关键字组成的无序列表（如果你想要排序，只需使用 sorted(d.keys()) ）。使用 in 关键字（指Python语法）可以检查字典中是否存在某个关键字（指字典）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel = &#123;<span class="string">'jack'</span>: <span class="number">4098</span>, <span class="string">'sape'</span>: <span class="number">4139</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel[<span class="string">'guido'</span>] = <span class="number">4127</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel</span><br><span class="line">&#123;<span class="string">'sape'</span>: <span class="number">4139</span>, <span class="string">'guido'</span>: <span class="number">4127</span>, <span class="string">'jack'</span>: <span class="number">4098</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel[<span class="string">'jack'</span>]</span><br><span class="line"><span class="number">4098</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> tel[<span class="string">'sape'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel[<span class="string">'irv'</span>] = <span class="number">4127</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tel</span><br><span class="line">&#123;<span class="string">'guido'</span>: <span class="number">4127</span>, <span class="string">'irv'</span>: <span class="number">4127</span>, <span class="string">'jack'</span>: <span class="number">4098</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(tel.keys())</span><br><span class="line">[<span class="string">'irv'</span>, <span class="string">'guido'</span>, <span class="string">'jack'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(tel.keys())</span><br><span class="line">[<span class="string">'guido'</span>, <span class="string">'irv'</span>, <span class="string">'jack'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'guido'</span> <span class="keyword">in</span> tel</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'jack'</span> <span class="keyword">not</span> <span class="keyword">in</span> tel</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>dict() 构造函数可以直接从 key-value 对中创建字典:
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict([(<span class="string">'sape'</span>, <span class="number">4139</span>), (<span class="string">'guido'</span>, <span class="number">4127</span>), (<span class="string">'jack'</span>, <span class="number">4098</span>)])</span><br><span class="line">&#123;<span class="string">'sape'</span>: <span class="number">4139</span>, <span class="string">'jack'</span>: <span class="number">4098</span>, <span class="string">'guido'</span>: <span class="number">4127</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>此外，字典推导式可以从任意的键值表达式中创建字典:
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x: x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)&#125;</span><br><span class="line">&#123;<span class="number">2</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">6</span>: <span class="number">36</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果关键字都是简单的字符串，有时通过关键字参数指定 key-value 对更为方便:
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict(sape=<span class="number">4139</span>, guido=<span class="number">4127</span>, jack=<span class="number">4098</span>)</span><br><span class="line">&#123;<span class="string">'sape'</span>: <span class="number">4139</span>, <span class="string">'jack'</span>: <span class="number">4098</span>, <span class="string">'guido'</span>: <span class="number">4127</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>Python 还包含了一个数据类型 —— set （集合）。集合是一个无序不重复元素的集。基本功能包括关系测试和消除重复元素。集合对象还支持 union（联合），intersection（交），difference（差）和 sysmmetric difference（对称差集）等数学运算。</p>
<p>大括号或 set() 函数可以用来创建集合。注意：想要创建空集合，你必须使用 set() 而不是 {},后者用于创建空字典。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = &#123;<span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'apple'</span>, <span class="string">'pear'</span>, <span class="string">'orange'</span>, <span class="string">'banana'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(basket)                      <span class="comment"># show that duplicates have been removed</span></span><br><span class="line">&#123;<span class="string">'orange'</span>, <span class="string">'banana'</span>, <span class="string">'pear'</span>, <span class="string">'apple'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'orange'</span> <span class="keyword">in</span> basket                 <span class="comment"># fast membership testing</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'crabgrass'</span> <span class="keyword">in</span> basket</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Demonstrate set operations on unique letters from two words</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = set(<span class="string">'abracadabra'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = set(<span class="string">'alacazam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a                                  <span class="comment"># unique letters in a</span></span><br><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'r'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a - b                              <span class="comment"># letters in a but not in b</span></span><br><span class="line">&#123;<span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'b'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a | b                              <span class="comment"># letters in either a or b</span></span><br><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'m'</span>, <span class="string">'z'</span>, <span class="string">'l'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a &amp; b                              <span class="comment"># letters in both a and b</span></span><br><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'c'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a ^ b                              <span class="comment"># letters in a or b but not both</span></span><br><span class="line">&#123;<span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'m'</span>, <span class="string">'z'</span>, <span class="string">'l'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'abracadabra'</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">'abc'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&#123;<span class="string">'r'</span>, <span class="string">'d'</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历技巧"><a href="#遍历技巧" class="headerlink" title="遍历技巧"></a>遍历技巧</h2><ul>
<li>在字典中遍历时，关键字和对应的值可以使用 items() 方法同时解读出来：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>knights = &#123;<span class="string">'gallahad'</span>: <span class="string">'the pure'</span>, <span class="string">'robin'</span>: <span class="string">'the brave'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> knights.items():</span><br><span class="line"><span class="meta">... </span>    print(k, v)</span><br><span class="line">...</span><br><span class="line">gallahad the pure</span><br><span class="line">robin the brave</span><br></pre></td></tr></table></figure>
<ul>
<li>在序列中遍历时，索引位置和对应值可以使用 enumerate() 函数同时得到：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate([<span class="string">'tic'</span>, <span class="string">'tac'</span>, <span class="string">'toe'</span>]):</span><br><span class="line"><span class="meta">... </span>    print(i, v)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> tic</span><br><span class="line"><span class="number">1</span> tac</span><br><span class="line"><span class="number">2</span> toe</span><br></pre></td></tr></table></figure>
<ul>
<li>同时循环两个或更多的序列，可以使用 zip() 整体打包:</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; questions = ['name', 'quest', 'favorite color']</span><br><span class="line">&gt;&gt;&gt; answers = ['lancelot', 'the holy grail', 'blue']</span><br><span class="line">&gt;&gt;&gt; for q, a in zip(questions, answers):</span><br><span class="line">...     print('What is your &#123;0&#125;?  It is &#123;1&#125;.'.format(q, a))</span><br><span class="line">...</span><br><span class="line">What is your name?  It is lancelot.</span><br><span class="line">What is your quest?  It is the holy grail.</span><br><span class="line">What is your favorite color?  It is blue.</span><br></pre></td></tr></table></figure>
<ul>
<li>需要逆向循环序列的话，先正向定位序列，然后调用 reversed() 函数:</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)):</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line">...</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>要按排序后的顺序循环序列的话，使用 sorted() 函数，它不改动原序列，而是生成一个新的已排序的序列:</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = [<span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'apple'</span>, <span class="string">'pear'</span>, <span class="string">'orange'</span>, <span class="string">'banana'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> f <span class="keyword">in</span> sorted(set(basket)):</span><br><span class="line"><span class="meta">... </span>    print(f)</span><br><span class="line">...</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">pear</span><br></pre></td></tr></table></figure>
<ul>
<li>若要在循环内部修改正在遍历的序列（例如复制某些元素），建议您首先制作副本。在序列上循环不会隐式地创建副本。切片表示法使这尤其方便:</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>words = [<span class="string">'cat'</span>, <span class="string">'window'</span>, <span class="string">'defenestrate'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> w <span class="keyword">in</span> words[:]:  <span class="comment"># Loop over a slice copy of the entire list.</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> len(w) &gt; <span class="number">6</span>:</span><br><span class="line"><span class="meta">... </span>        words.insert(<span class="number">0</span>, w)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>words</span><br><span class="line">[<span class="string">'defenestrate'</span>, <span class="string">'cat'</span>, <span class="string">'window'</span>, <span class="string">'defenestrate'</span>]</span><br></pre></td></tr></table></figure>
<h2 id="Python数据类型转换"><a href="#Python数据类型转换" class="headerlink" title="Python数据类型转换"></a>Python数据类型转换</h2><p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。
以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>int(x [,base])</td>
<td>将x转换为一个整数。</td>
</tr>
<tr>
<td>long(x [,base] )</td>
<td>将x转换为一个长整数。</td>
</tr>
<tr>
<td>float(x)</td>
<td>将x转换到一个浮点数。</td>
</tr>
<tr>
<td>complex(real [,imag])</td>
<td>创建一个复数。</td>
</tr>
<tr>
<td>str(x)</td>
<td>将对象 x 转换为字符串。</td>
</tr>
<tr>
<td>repr(x)</td>
<td>将对象 x 转换为表达式字符串。</td>
</tr>
<tr>
<td>eval(str)</td>
<td>用来计算在字符串中的有效Python表达式,并返回一个对象。</td>
</tr>
<tr>
<td>tuple(s)</td>
<td>将序列 s 转换为一个元组。</td>
</tr>
<tr>
<td>list(s)</td>
<td>将序列 s 转换为一个列表。</td>
</tr>
<tr>
<td>set(s)</td>
<td>转换为可变集合。</td>
</tr>
<tr>
<td>dict(d)</td>
<td>创建一个字典。d 必须是一个序列 (key,value)元组。</td>
</tr>
<tr>
<td>frozenset(s)</td>
<td>转换为不可变集合。</td>
</tr>
<tr>
<td>chr(x)</td>
<td>将一个整数转换为一个字符。</td>
</tr>
<tr>
<td>unichr(x)</td>
<td>将一个整数转换为Unicode字符。</td>
</tr>
<tr>
<td>ord(x)</td>
<td>将一个字符转换为它的整数值。</td>
</tr>
<tr>
<td>hex(x)</td>
<td>将一个整数转换为一个十六进制字符串。</td>
</tr>
<tr>
<td>oct(x)</td>
<td>将一个整数转换为一个八进制字符串。</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用Anaconda Python科学计算包]]></title>
      <url>http://keyunluo.github.io/2016/07/17/2016-07-17-anaconda-python.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>本篇博文记录在Ubuntu16.04上配置Python的科学计算环境包，使用anaconda发行版和清华大学的镜像服务。</p>
</blockquote>
<a id="more"></a>
<h2 id="Anaconda下载与安装"><a href="#Anaconda下载与安装" class="headerlink" title="Anaconda下载与安装"></a>Anaconda下载与安装</h2><p>由于使用教育网，便可以很方便的使用IPV6资源，其中就包括镜像服务。Anaconda 是一个用于科学计算的 Python 发行版，支持 Linux, Mac, Windows, 包含了众多流行的科学计算、数据分析的 Python 包。</p>
<p><code>Anaconda</code> 安装包可以到 <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="external">清华大学镜像站</a> 下载，本文使用了<code>Anaconda3-4.1.1-Linux-x86_64.sh</code>。</p>
<p>安装完成后，默认是已经添加了环境变量的，这里在Ubuntu16.04上安装的，会与系统的Python3版本冲突，因此需要修改环境，为了不影响系统的Python3，将Anaconda的Python路径放至PATH的最后，即在<code>/etc/profile</code>的最后一行添加<code>export PATH=$PATH:/usr/local/anaconda3/bin</code>。同时为了抛弃系统的Python3，一个解决方案是使用软链将Anaconda的<code>python</code>指向<code>/usr/local/bin/python3</code>,具体入下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/anaconda3/bin/python /usr/local/bin/python3</span><br></pre></td></tr></table></figure>
<h2 id="镜像源与PyPi配置"><a href="#镜像源与PyPi配置" class="headerlink" title="镜像源与PyPi配置"></a>镜像源与PyPi配置</h2><p>通常Anaconda的官方源速度无法忍受，因此需要更改为国内的源，这里可以清华大学的镜像源：Anaconda Python 免费仓库。</p>
<p>Linux下在终端中输入：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels <span class="string">'https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/'</span></span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure>
<p>Windows下在CMD中输入：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure>
<p>一般我们使用PyPi的安装大部分的Python组件，同理，官方速度也很够呛，因此在这里配置国内的源。
编辑<code>~/.pip/pip.conf</code>(没有就创建一个)，里面改为清华源：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">global</span>]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>
<p>或中科大源，速度都很给力</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">global</span>]</span><br><span class="line">index-url = https://pypi.mirrors.ustc.edu.cn/simple</span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>由于安装了Anaconda Python3，所以安装软件时可以用<code>conda install XXX</code>安装或<code>conda update XXX</code>来更新，当然也可以用<code>pip3</code>。</p>
<p>当要为系统的Python2版本安装Numpy时，先安装一些编译依赖项,如果直接用pip安装最新的numpy时会编译错误，原因是缺少必要的库，因此需要先安装这些库，一个简单的做法是使用Ubuntu的build-dep命令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt build-dep python-numpy python-scipy python-matplotlib</span><br></pre></td></tr></table></figure>
<p>然后就可以直接安装了：<code>sudo -H pip install -U numpy</code>.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu16.04配置L2TP-VPN]]></title>
      <url>http://keyunluo.github.io/2016/07/17/2016-07-17-ubuntu16-l2tp-vpn.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>本篇博文记录在Ubuntu16.04上安装L2TP插件,之前记录了在<a href="/2016/03/20/2016-03-20-ubuntu14-l2tp-vpn.html">Ubuntu14.04</a>上安装L2TP插件，但ppa上还没有更新这个软件包，故只有手动从源代码编译安装。</p>
</blockquote>
<a id="more"></a>
<h2 id="安装依赖软件"><a href="#安装依赖软件" class="headerlink" title="安装依赖软件"></a>安装依赖软件</h2><p>从源代码编译时需要很多第三方软件，因此首先需要在系统中安装这些库，具体如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt  install git libtool automake libglib2.0-dev  intltool ppp-dev libgtk+-3-dev libnma-dev libsecret-1-dev libnm-gtk-dev libnm-glib-dev  libnm-glib-vpn-dev xl2tpd</span><br></pre></td></tr></table></figure>
<p>安装好这些库后便可以从<code>github</code>上<code>clone</code>最新的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/nm-l2tp/network-manager-l2tp</span><br></pre></td></tr></table></figure>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>使用终端进入源代码目录<code>network-manager-l2tp</code>，运行如下的<code>configure</code>命令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./configure \</span><br><span class="line">  --prefix=/usr --localstatedir=/var --sysconfdir=/etc \</span><br><span class="line">  --libexecdir=/usr/lib/NetworkManager \</span><br><span class="line">  --<span class="keyword">with</span>-pppd-plugin-dir=/usr/lib/pppd/<span class="number">2.4</span><span class="number">.7</span> \</span><br><span class="line">  --enable-absolute-paths</span><br></pre></td></tr></table></figure>
<p>没有报错后，接着便<code>make</code>和<code>make install</code> :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>安装完成后，还不能直接使用，需要关闭<code>xl2tp</code>，然后机器重新启动:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service xl2tpd stop</span><br><span class="line">sudo update-rc.d xl2tpd disable</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
<p>此时，通过<code>网络-编辑连接-增加-第二层隧道协议</code>便可以配置L2TP-VPN了。</p>
<p><img src="/resource/blog/2016-07/L2TP.png" alt="L2TP-VPN"></p>
<p>配置好用户名，密码，地址后，基本上就OK了。不过由于笔者实验室配置的L2TP貌似有问题，导致部分网页打不开，比如微博。。。然而却能Ping的通，经过一番摸索后，发现是VPN的<code>PPP</code>设置中的<code>MTU</code>值过大，于是将其改到了一个较小的数值，便可以愉快的玩耍了。</p>
<p><img src="/resource/blog/2016-07/PPP设置.png" alt="PPP设置"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[正当毕业时]]></title>
      <url>http://keyunluo.github.io/2016/06/21/2016-06-21-graduation.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>就算新的开始依旧美丽，而此刻的心情也必然暗淡。</p>
</blockquote>
<a id="more"></a>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=109864&auto=0&height=66"></iframe>



<h2 id="时光缝隙里的记忆"><a href="#时光缝隙里的记忆" class="headerlink" title="时光缝隙里的记忆"></a>时光缝隙里的记忆</h2><p>&nbsp;&nbsp;紧张的毕业答辩之后，整个人顿时轻松了不少，收拾好东西和搬家后，不知不觉间感到些许失落和无所事事。毕业典礼上全院三百多人集体煽情了一把，毕竟这一别很有可能好多人将很难再见上一面。毕业典礼一结束，顺便吃了个学校发的毕业纪念餐，意味着这将是在这个学校的最后一天了。虽然宿舍有些破旧并且并不宽敞，但我依然记得刚开始入学时第一次躺在这张床上的感觉。我是个随遇而安的人，也许在中学时代的羁畔太多，刚入大学的我对这一切新鲜的生活感到异常兴奋和温馨。而如今，生活了四年，严格来说大概三年多一点的日子，依然感到舒适。此时此刻，用白驹过隙、时光荏苒这些曾经“为赋新词强说愁”的词汇来表达此时的心境却感到越发真实贴切。</p>
<p>&nbsp;&nbsp;曾经以为，我的大学不值得留恋，既没有轰轰烈烈的爱情，也没有叱咤风云的专业技能，日子过得平平淡淡甚至很Dull，所谓的星辰大海依旧虚无缥缈，总体的感觉就是不会玩，也不会学习。然而一路走来，细细回想，在稀里糊涂地走过的四年的青春时光里，越想经历的越多，感悟的更多，到头来才发现虽然没有他人过的精彩，却也在不断地探索前行，在发现一个更大的世界的旅程中磕磕碰碰，所有惯常的令人感动的场景也会让我潸然。</p>
<h2 id="间歇性踌躇满志，持续性混吃等死"><a href="#间歇性踌躇满志，持续性混吃等死" class="headerlink" title="间歇性踌躇满志，持续性混吃等死"></a>间歇性踌躇满志，持续性混吃等死</h2><p>&nbsp;&nbsp;那时虽然天气炎热，寝室也没有空调，却满腔热情，早起早睡，精神饱满，而后渐渐地越起越晚，到大一下基本上就有起床困难症了。刚入大学那会，由于上的课主要是数学基础课，做习题花费的时间比较多，总体感觉不是很吃力，但也不是特别用功钻研，并且对程序设计语言课不太感兴趣，归结起来就是很浮躁，这种状态一直延续了整个大学四年。大二时开始上专业基础课，各种实验课搞得我很是困倦，几门硬件相关的课程学习得很是吃力，这也直接导致我对这一方向失去兴趣，后来又参加科创，学习一些数字图像处理的课程，课外花了不少时间，但总感觉收获有限，这一年算过得比较失败。大三开始真正上专业课，对学科开始有了一个初步的了解，下学期就开始考虑保研和实习的事，开始是准备去华为这样的公司实习的，奈何内推时填写实习时间三个月后直接没有了下文，一个偶然的机会就去了中科院电子所苏州研究院，这样暑假就奔波于北京、苏州了。大四开学后就面临着保研的问题，机试不是很好，但凭着底子厚还是有惊无险的获得了保研资格，继续读书。在苏州实习四个月后，十一月底回到学校，后来联系导师，导师让过去做毕设，这样大四后半年就在南大度过的，直到毕设论文答辩前夕。</p>
<p>&nbsp;&nbsp;归结起来，大学前三年几乎宅在学校，大四到处奔波，从北京、苏州往返于南京，整个大学的状态是“三分钟热度”，“浅尝辄止”成为常态。每次都想在图书馆坐下来好好学习一番，可是不到半小时便注意力分散，看一些技术书籍，常痴迷于各种计算机新技术，常纠结于各种术语之间，最喜欢瞎折腾，装系统编译软件，浪费了好多时间，做不了极客，却积攒了不少吹牛的资本。大学里面的专业课就从来没有认真上过，平时也没有什么预习复习，基本上上课听多少就多少，考前开始认真预习刷试卷，保持着一个伪学霸的状态，成绩不是最好，但也说得过去。</p>
<h2 id="努力学习的意义"><a href="#努力学习的意义" class="headerlink" title="努力学习的意义"></a>努力学习的意义</h2><p>&nbsp;&nbsp;<code>谁没有不切实际的梦想，把未来的人生精彩的幻想 常常一个人悄悄的描绘，欣赏那种假设的辉煌</code></p>
<p>&nbsp;&nbsp;以前一直没有认真考虑过这个问题，直到大四这一年东奔西走，渐渐领悟到努力学习的意义。努力和有钱的意义差不多，让你在未来的生活中有更多选择。努力的最大动力，在于你可以选择你想要的生活，而不是被生活选择。努力就意味着掌握了主动权，掌握了改变自身状态的能力，在一个更大的世界里过自己想要的生活。为此，现在的我懊悔不已，既然学习技术，就要做那个最厉害的一个，大多数人都很弱，你只要稍微精通某些方面的知识就会脱颖而出。</p>
<p>&nbsp;&nbsp;我一直认为我很幸运，从上大学一开始就进入计算机软件培优班到科创获得一等奖，从保研到南大到最终毕设成绩优秀。虽然我不是足够优秀，但运气不会太差。我坚信越努力，越幸运，积极乐观，用努力学习使当初的选择变得正确，一直做个幸运的人。</p>
<h2 id="向着自由的未来前行"><a href="#向着自由的未来前行" class="headerlink" title="向着自由的未来前行"></a>向着自由的未来前行</h2><p>&nbsp;&nbsp;<code>我飞出五行之内三界之外，我心头无牵无挂无限自在，我知道生亦何苦死亦何哀，如来如不来一样死性不改。</code></p>
<p>&nbsp;&nbsp;大学毕业，既是终点，也是起点，以后的路也越走越宽。现在的我，希望自己能放下手机，能做一个努力上进，能掌控我的未来的人。积极锻炼身体，保持一个健康的体魄；玩就玩个痛快，尽情释放自我；读书做事不贪图多，唯求精益求精。通往卓越的路只有一条，就是静下心来积累，天下武功，唯快不破。</p>
<p>&nbsp;&nbsp;我不想被束缚，我希望自由自在的活着，我想看世间最美的一切。</p>
<p>&nbsp;&nbsp;祝所有在意我的人和我在意的人，人生的道路越走越宽，后会有期。</p>
<p><img src="/resource/blog/2016-06/学位证.jpg" alt="学位照"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elasticsearch入门学习(3)——查询]]></title>
      <url>http://keyunluo.github.io/2016/05/27/2016-05-27-elasticsearch-3.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>ElasticSearch</strong>提供了丰富的REST风格的API来满足不同的场景需求，本篇介绍Elasticsearch的查询相关的基础和高级操作。</p>
</blockquote>
<a id="more"></a>
<h2 id="检索文档"><a href="#检索文档" class="headerlink" title="检索文档"></a>检索文档</h2><ul>
<li><strong>通过ID直接查询</strong>
执行<code>HTTP GET</code>请求，通过<code>索引-类型-ID</code>便可以返回原始的JSON格式的文档，原始的JSON文档在<code>_source</code>字段里。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dislab@server:~$ curl -XGET <span class="string">'http://server:9200/gps_data/20160205/3201000061%2010:20:54?pretty'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"_index"</span> : <span class="string">"gps_data"</span>,</span><br><span class="line">  <span class="string">"_type"</span> : <span class="string">"20160205"</span>,</span><br><span class="line">  <span class="string">"_id"</span> : <span class="string">"3201000061 10:20:54"</span>,</span><br><span class="line">  <span class="string">"_version"</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="string">"found"</span> : true,</span><br><span class="line">  <span class="string">"_source"</span> : &#123;</span><br><span class="line">    <span class="string">"ZDBH"</span> : <span class="string">"3201000061"</span>,</span><br><span class="line">    <span class="string">"ROWKEY"</span> : <span class="string">"3201000061 10:20:54"</span>,</span><br><span class="line">    <span class="string">"GPSSJ"</span> : <span class="string">"2016-02-05 10:20:54"</span>,</span><br><span class="line">    <span class="string">"XLMC"</span> : <span class="string">"80路"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>ID</code>字段插入了<code>%20</code>的字段，这是因为<code>curl</code>命令中不能有空格，若有空格则必须替换掉。</p>
<ul>
<li><strong>简单搜索</strong>
简单搜索不需要指定<code>ID</code>,需要指定查询字符串，格式为<code>_search?q=key:value</code></li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dislab@server:~$ curl -XGET  http://server:9200/gps_data/20160205/_search?q=GPSSJ:“2016-02-05 10:20:54”</span><br><span class="line">&#123;"took":695,"timed_out":false,"_shards":&#123;"total":5,"successful":5,"failed":0&#125;,"hits":&#123;"total":10093722,"max_score":0.3666257,"hits":[&#123;"_index":"gps_data","_type":"20160205","_id":"3201000158 05:05:05","_score":0.3666257,"_source":&#123;"ZDBH":"3201000158","ROWKEY":"3201000158 05:05:05","GPSSJ":"2016-02-05 05:05:05","XLMC":"13路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201200106 05:05:05","_score":0.3666257,"_source":&#123;"ZDBH":"3201200106","ROWKEY":"3201200106 05:05:05","GPSSJ":"2016-02-05 05:05:05","XLMC":"170路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201200154 05:05:05","_score":0.3666257,"_source":&#123;"ZDBH":"3201200154","ROWKEY":"3201200154 05:05:05","GPSSJ":"2016-02-05 05:05:05","XLMC":"125路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201200126 05:05:05","_score":0.3666257,"_source":&#123;"ZDBH":"3201200126","ROWKEY":"3201200126 05:05:05","GPSSJ":"2016-02-05 05:05:05","XLMC":"8路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201300190 05:05:05","_score":0.3666257,"_source":&#123;"ZDBH":"3201300190","ROWKEY":"3201300190 05:05:05","GPSSJ":"2016-02-05 05:05:05","XLMC":"48路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201300169 05:05:05","_score":0.3666257,"_source":&#123;"ZDBH":"3201300169","ROWKEY":"3201300169 05:05:05","GPSSJ":"2016-02-05 05:05:05","XLMC":"48路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100008 05:05:05","_score":0.3666257,"_source":&#123;"ZDBH":"3201100008","ROWKEY":"3201100008 05:05:05","GPSSJ":"2016-02-05 05:05:05","XLMC":"306路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201000166 05:05:05","_score":0.36632675,"_source":&#123;"ZDBH":"3201000166","ROWKEY":"3201000166 05:05:05","GPSSJ":"2016-02-05 05:05:05","XLMC":"13路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201000179 05:05:05","_score":0.36632675,"_source":&#123;"ZDBH":"3201000179","ROWKEY":"3201000179 05:05:05","GPSSJ":"2016-02-05 05:05:05","XLMC":"13路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201000019 05:05:05","_score":0.36632675,"_source":&#123;"ZDBH":"3201000019","ROWKEY":"3201000019 05:05:05","GPSSJ":"2016-02-05 05:05:05","XLMC":"166路"&#125;&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>DSL语句查询</strong>
DSL(Domain Specific Language特定领域语言)以JSON请求体的形式出现，可以构建复杂的查询。
上述查询可写成如下的<code>DSL</code>查询方式</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dislab@server:~$ curl -XGET 'http://server:9200/gps_data/20160205/_search' -d '</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;     "query" : &#123;</span><br><span class="line">&gt;         "match" : &#123;</span><br><span class="line">&gt;             "GPSSJ" : "2016-02-05 10:20:54"</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; '</span><br><span class="line">&#123;"took":854,"timed_out":false,"_shards":&#123;"total":5,"successful":5,"failed":0&#125;,"hits":&#123;"total":10093722,"max_score":2.7672434,"hits":[&#123;"_index":"gps_data","_type":"20160205","_id":"3201200801 20:54:10","_score":2.7672434,"_source":&#123;"ZDBH":"3201200801","ROWKEY":"3201200801 20:54:10","GPSSJ":"2016-02-05 20:54:10","XLMC":"170路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201300063 20:54:10","_score":2.7672434,"_source":&#123;"ZDBH":"3201300063","ROWKEY":"3201300063 20:54:10","GPSSJ":"2016-02-05 20:54:10","XLMC":"D9路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201000027 20:10:54","_score":2.7672434,"_source":&#123;"ZDBH":"3201000027","ROWKEY":"3201000027 20:10:54","GPSSJ":"2016-02-05 20:10:54","XLMC":"7路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201000193 10:54:20","_score":2.7672434,"_source":&#123;"ZDBH":"3201000193","ROWKEY":"3201000193 10:54:20","GPSSJ":"2016-02-05 10:54:20","XLMC":"13路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201000115 20:10:54","_score":2.7672434,"_source":&#123;"ZDBH":"3201000115","ROWKEY":"3201000115 20:10:54","GPSSJ":"2016-02-05 20:10:54","XLMC":"13路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 10:54:20","_score":2.7672434,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 10:54:20","GPSSJ":"2016-02-05 10:54:20","XLMC":"57路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201200163 10:20:54","_score":2.7672434,"_source":&#123;"ZDBH":"3201200163","ROWKEY":"3201200163 10:20:54","GPSSJ":"2016-02-05 10:20:54","XLMC":"201路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201200200 20:10:54","_score":2.7672434,"_source":&#123;"ZDBH":"3201200200","ROWKEY":"3201200200 20:10:54","GPSSJ":"2016-02-05 20:10:54","XLMC":"170路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201200127 10:20:54","_score":2.7672434,"_source":&#123;"ZDBH":"3201200127","ROWKEY":"3201200127 10:20:54","GPSSJ":"2016-02-05 10:20:54","XLMC":"125路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201200127 10:54:20","_score":2.7672434,"_source":&#123;"ZDBH":"3201200127","ROWKEY":"3201200127 10:54:20","GPSSJ":"2016-02-05 10:54:20","XLMC":"125路"&#125;&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>复杂DSL语句查询</strong>
<code>DSL</code>查询可嵌套多种条件形成复杂查询。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">dislab@server:~$ curl -XGET 'http://server:9200/gps_data/20160205/_search' -d '</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;     "query" : &#123;</span><br><span class="line">&gt;         "filtered" : &#123;</span><br><span class="line">&gt;             "filter" : &#123;</span><br><span class="line">&gt;                 "range" : &#123;</span><br><span class="line">&gt;                     "ZDBH" : &#123; "gt" : 3201300108 &#125;</span><br><span class="line">&gt;                 &#125;</span><br><span class="line">&gt;             &#125;,</span><br><span class="line">&gt;             "query" : &#123;</span><br><span class="line">&gt;                 "match" : &#123;</span><br><span class="line">&gt;                     "GPSSJ" : "2016-02-05 10:20:54"</span><br><span class="line">&gt;                 &#125;</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; '</span><br><span class="line">&#123;"took":657,"timed_out":false,"_shards":&#123;"total":5,"successful":5,"failed":0&#125;,"hits":&#123;"total":645657,"max_score":2.7672434,"hits":[&#123;"_index":"gps_data","_type":"20160205","_id":"3201300120 20:10:54","_score":2.7672434,"_source":&#123;"ZDBH":"3201300120","ROWKEY":"3201300120 20:10:54","GPSSJ":"2016-02-05 20:10:54","XLMC":"41路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201300220 10:20:54","_score":2.7672434,"_source":&#123;"ZDBH":"3201300220","ROWKEY":"3201300220 10:20:54","GPSSJ":"2016-02-05 10:20:54","XLMC":"306路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201300131 10:20:54","_score":2.7672434,"_source":&#123;"ZDBH":"3201300131","ROWKEY":"3201300131 10:20:54","GPSSJ":"2016-02-05 10:20:54","XLMC":"48路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201300162 10:54:20","_score":2.7672434,"_source":&#123;"ZDBH":"3201300162","ROWKEY":"3201300162 10:54:20","GPSSJ":"2016-02-05 10:54:20","XLMC":"182路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201300177 20:54:10","_score":2.7672434,"_source":&#123;"ZDBH":"3201300177","ROWKEY":"3201300177 20:54:10","GPSSJ":"2016-02-05 20:54:10","XLMC":"56路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201300165 10:54:20","_score":2.7672434,"_source":&#123;"ZDBH":"3201300165","ROWKEY":"3201300165 10:54:20","GPSSJ":"2016-02-05 10:54:20","XLMC":"48路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201300115 20:54:10","_score":2.7672434,"_source":&#123;"ZDBH":"3201300115","ROWKEY":"3201300115 20:54:10","GPSSJ":"2016-02-05 20:54:10","XLMC":"48路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201300120 20:54:10","_score":2.7672434,"_source":&#123;"ZDBH":"3201300120","ROWKEY":"3201300120 20:54:10","GPSSJ":"2016-02-05 20:54:10","XLMC":"41路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201300171 10:20:54","_score":2.7672434,"_source":&#123;"ZDBH":"3201300171","ROWKEY":"3201300171 10:20:54","GPSSJ":"2016-02-05 10:20:54","XLMC":"56路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201300200 10:20:54","_score":2.7672434,"_source":&#123;"ZDBH":"3201300200","ROWKEY":"3201300200 10:20:54","GPSSJ":"2016-02-05 10:20:54","XLMC":"306路"&#125;&#125;]&#125;&#125;dislab@server:~$</span><br></pre></td></tr></table></figure>
<p>上述查询主要包括一个区间过滤器和match语句。</p>
<ul>
<li><strong>全文搜索</strong>
使用<code>match</code>匹配计算相关性，根据结果相关性评分来对结果集进行排序。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dislab@server:~$ curl -XGET 'http://server:9200/gps_data/20160205/_search' -d '</span><br><span class="line">&#123;</span><br><span class="line">     "query" : &#123;</span><br><span class="line">         "match" : &#123;</span><br><span class="line">             "XLMC" : "57"</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">'</span><br><span class="line">&#123;"took":146,"timed_out":false,"_shards":&#123;"total":5,"successful":5,"failed":0&#125;,"hits":&#123;"total":143481,"max_score":2.9686642,"hits":[&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 07:17:12","_score":2.9686642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 07:17:12","GPSSJ":"2016-02-05 07:17:12","XLMC":"57路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 07:17:38","_score":2.9686642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 07:17:38","GPSSJ":"2016-02-05 07:17:38","XLMC":"57路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 07:17:42","_score":2.9686642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 07:17:42","GPSSJ":"2016-02-05 07:17:42","XLMC":"57路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 07:18:01","_score":2.9686642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 07:18:01","GPSSJ":"2016-02-05 07:18:01","XLMC":"57路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 07:18:15","_score":2.9686642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 07:18:15","GPSSJ":"2016-02-05 07:18:15","XLMC":"57路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 07:18:17","_score":2.9686642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 07:18:17","GPSSJ":"2016-02-05 07:18:17","XLMC":"57路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 07:18:23","_score":2.9686642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 07:18:23","GPSSJ":"2016-02-05 07:18:23","XLMC":"57路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 07:18:30","_score":2.9686642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 07:18:30","GPSSJ":"2016-02-05 07:18:30","XLMC":"57路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 07:18:48","_score":2.9686642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 07:18:48","GPSSJ":"2016-02-05 07:18:48","XLMC":"57路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 07:18:49","_score":2.9686642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 07:18:49","GPSSJ":"2016-02-05 07:18:49","XLMC":"57路"&#125;&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>短语搜索</strong>
关键字之间是<code>与</code>关系的短语搜素，要求在搜索过程中关键字是相邻的。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET 'http://server:9200/gps_data/20160205/_search' -d '</span><br><span class="line">&#123;</span><br><span class="line">    "query" : &#123;</span><br><span class="line">        "match_phrase" : &#123;</span><br><span class="line">            "XLMC" : "57 路"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br><span class="line">&#123;"took":236,"timed_out":false,"_shards":&#123;"total":5,"successful":5,"failed":0&#125;,"hits":&#123;"total":143481,"max_score":3.5936642,"hits":[&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 14:22:40","_score":3.5936642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 14:22:40","GPSSJ":"2016-02-05 14:22:40","XLMC":"57路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 14:22:52","_score":3.5936642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 14:22:52","GPSSJ":"2016-02-05 14:22:52","XLMC":"57路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 14:23:06","_score":3.5936642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 14:23:06","GPSSJ":"2016-02-05 14:23:06","XLMC":"57路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 14:23:37","_score":3.5936642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 14:23:37","GPSSJ":"2016-02-05 14:23:37","XLMC":"57路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 14:23:39","_score":3.5936642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 14:23:39","GPSSJ":"2016-02-05 14:23:39","XLMC":"57路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 14:23:47","_score":3.5936642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 14:23:47","GPSSJ":"2016-02-05 14:23:47","XLMC":"57路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 14:23:58","_score":3.5936642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 14:23:58","GPSSJ":"2016-02-05 14:23:58","XLMC":"57路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 14:24:31","_score":3.5936642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 14:24:31","GPSSJ":"2016-02-05 14:24:31","XLMC":"57路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 14:24:35","_score":3.5936642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 14:24:35","GPSSJ":"2016-02-05 14:24:35","XLMC":"57路"&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 14:25:15","_score":3.5936642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 14:25:15","GPSSJ":"2016-02-05 14:25:15","XLMC":"57路"&#125;&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>搜索结果高亮</strong>
使用<code>highlight</code>高亮搜索到的匹配关键字。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET 'http://server:9200/gps_data/20160205/_search' -d '</span><br><span class="line">&#123;</span><br><span class="line">    "query" : &#123;</span><br><span class="line">        "match_phrase" : &#123;</span><br><span class="line">            "XLMC" : "57 路"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "highlight": &#123;</span><br><span class="line">        "fields" : &#123;</span><br><span class="line">            "XLMC" : &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br><span class="line">&#123;"took":375,"timed_out":false,"_shards":&#123;"total":5,"successful":5,"failed":0&#125;,"hits":&#123;"total":143481,"max_score":3.5936642,"hits":[&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 07:17:12","_score":3.5936642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 07:17:12","GPSSJ":"2016-02-05 07:17:12","XLMC":"57路"&#125;,"highlight":&#123;"XLMC":["&lt;em&gt;57&lt;/em&gt;&lt;em&gt;路&lt;/em&gt;"]&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 07:17:38","_score":3.5936642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 07:17:38","GPSSJ":"2016-02-05 07:17:38","XLMC":"57路"&#125;,"highlight":&#123;"XLMC":["&lt;em&gt;57&lt;/em&gt;&lt;em&gt;路&lt;/em&gt;"]&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 07:17:42","_score":3.5936642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 07:17:42","GPSSJ":"2016-02-05 07:17:42","XLMC":"57路"&#125;,"highlight":&#123;"XLMC":["&lt;em&gt;57&lt;/em&gt;&lt;em&gt;路&lt;/em&gt;"]&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 07:18:01","_score":3.5936642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 07:18:01","GPSSJ":"2016-02-05 07:18:01","XLMC":"57路"&#125;,"highlight":&#123;"XLMC":["&lt;em&gt;57&lt;/em&gt;&lt;em&gt;路&lt;/em&gt;"]&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 07:18:15","_score":3.5936642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 07:18:15","GPSSJ":"2016-02-05 07:18:15","XLMC":"57路"&#125;,"highlight":&#123;"XLMC":["&lt;em&gt;57&lt;/em&gt;&lt;em&gt;路&lt;/em&gt;"]&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 07:18:17","_score":3.5936642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 07:18:17","GPSSJ":"2016-02-05 07:18:17","XLMC":"57路"&#125;,"highlight":&#123;"XLMC":["&lt;em&gt;57&lt;/em&gt;&lt;em&gt;路&lt;/em&gt;"]&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 07:18:23","_score":3.5936642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 07:18:23","GPSSJ":"2016-02-05 07:18:23","XLMC":"57路"&#125;,"highlight":&#123;"XLMC":["&lt;em&gt;57&lt;/em&gt;&lt;em&gt;路&lt;/em&gt;"]&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 07:18:30","_score":3.5936642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 07:18:30","GPSSJ":"2016-02-05 07:18:30","XLMC":"57路"&#125;,"highlight":&#123;"XLMC":["&lt;em&gt;57&lt;/em&gt;&lt;em&gt;路&lt;/em&gt;"]&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 07:18:48","_score":3.5936642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 07:18:48","GPSSJ":"2016-02-05 07:18:48","XLMC":"57路"&#125;,"highlight":&#123;"XLMC":["&lt;em&gt;57&lt;/em&gt;&lt;em&gt;路&lt;/em&gt;"]&#125;&#125;,&#123;"_index":"gps_data","_type":"20160205","_id":"3201100090 07:18:49","_score":3.5936642,"_source":&#123;"ZDBH":"3201100090","ROWKEY":"3201100090 07:18:49","GPSSJ":"2016-02-05 07:18:49","XLMC":"57路"&#125;,"highlight":&#123;"XLMC":["&lt;em&gt;57&lt;/em&gt;&lt;em&gt;路&lt;/em&gt;"]&#125;&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elasticsearch入门学习(2)——服务URL]]></title>
      <url>http://keyunluo.github.io/2016/04/11/2016-04-11-elasticsearch-2.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>ElasticSearch</strong> 将各种功能、配置、服务都以API的形式暴露，这也是elasticsearch区别于其他搜索引擎框架的一个特征，本文将ES中常用的URL整理以供查询。</p>
</blockquote>
<a id="more"></a>
<h2 id="与Elasticsearch交互"><a href="#与Elasticsearch交互" class="headerlink" title="与Elasticsearch交互"></a>与Elasticsearch交互</h2><p>如何与Elasticsearch交互取决于你是否使用Java，可以分为<code>Java API交互</code>和<code>基于HTTP协议，以JSON为数据交互格式的RESTful API</code>两种，本文主要讲解使用RESTful API，通过9200端口的与Elasticsearch进行通信。使用java则端口为9300.</p>
<p>向Elasticsearch发出的请求的组成部分与其它普通的HTTP请求是一样的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X&lt;VERB&gt; '&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;' -d '&lt;BODY&gt;'</span><br></pre></td></tr></table></figure>
<ul>
<li>VERB HTTP方法：GET, POST, PUT, HEAD, DELETE</li>
<li>PROTOCOL http或者https协议（只有在Elasticsearch前面有https代理的时候可用）</li>
<li>HOST Elasticsearch集群中的任何一个节点的主机名，如果是在本地的节点，那么就叫localhost</li>
<li>PORT Elasticsearch HTTP服务所在的端口，默认为9200</li>
<li>PATH API路径（例如_count将返回集群中文档的数量），PATH可以包含多个组件，例如_cluster/stats或者_nodes/stats/jvm</li>
<li>QUERY_STRING 一些可选的查询请求参数，例如?pretty参数将使请求返回更加美观易读的JSON数据</li>
<li>BODY 一个JSON格式的请求主体（如果请求需要的话）</li>
</ul>
<p>例如，为了计算集群中的文档数量，我们可以这样做：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@slave01 ~]$ curl -XGET 'http://localhost:9200/_count?pretty' -d '</span><br><span class="line">&#123;</span><br><span class="line">    "query": &#123;</span><br><span class="line">        "match_all": &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br><span class="line">&#123;</span><br><span class="line">  "count" : 3498781,</span><br><span class="line">  "_shards" : &#123;</span><br><span class="line">    "total" : 37,</span><br><span class="line">    "successful" : 37,</span><br><span class="line">    "failed" : 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Elasticsearch返回一个类似200 OK的HTTP状态码和JSON格式的响应主体（除了HEAD请求）。</p>
<h2 id="Elasticsearch常见服务URL"><a href="#Elasticsearch常见服务URL" class="headerlink" title="Elasticsearch常见服务URL"></a>Elasticsearch常见服务URL</h2><ul>
<li><p>HTTP方法: POST新增，PUT更新，GET获取，DELETE删除，HEAD判断是否存在</p>
</li>
<li><p>集群健康查看:<code>curl  &#39;http://server:9200/_cat/health?v&#39;</code></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">epoch      timestamp cluster       status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent</span><br><span class="line"><span class="number">1460378717</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">17</span>  Elasticsearch green           <span class="number">3</span>         <span class="number">3</span>     <span class="number">74</span>  <span class="number">37</span>    <span class="number">0</span>    <span class="number">0</span>        <span class="number">0</span>             <span class="number">0</span>                  -                <span class="number">100.0</span>%</span><br></pre></td></tr></table></figure>
<ul>
<li>节点健康查看:<code>curl  &#39;http://server:9200/_cat/nodes?v&#39;</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">host            ip              heap.percent ram.percent load node.role master name</span><br><span class="line"><span class="number">192.168</span><span class="number">.100</span><span class="number">.107</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.107</span>           <span class="number">30</span>          <span class="number">22</span> <span class="number">0.00</span> d         -      ES-Hadoop-Spark-Node1</span><br><span class="line"><span class="number">192.168</span><span class="number">.100</span><span class="number">.110</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.110</span>           <span class="number">11</span>          <span class="number">23</span> <span class="number">0.01</span> d         -      ES-Hadoop-Spark-Node2</span><br><span class="line"><span class="number">192.168</span><span class="number">.100</span><span class="number">.101</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.101</span>           <span class="number">19</span>          <span class="number">27</span> <span class="number">1.80</span> d         *      ES-Hadoop-Spark-Master</span><br></pre></td></tr></table></figure>
<ul>
<li>列出集群索引:<code>curl  &#39;http://server:9200/_cat/indices?v&#39;</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">health status index                 pri rep docs.count docs.deleted store.size pri.store.size</span><br><span class="line">green  open   demo                    <span class="number">5</span>   <span class="number">1</span>          <span class="number">1</span>            <span class="number">0</span>      <span class="number">7.9</span>kb          <span class="number">3.9</span>kb</span><br><span class="line">green  open   my_index                <span class="number">5</span>   <span class="number">1</span>         <span class="number">11</span>            <span class="number">0</span>     <span class="number">53.4</span>kb         <span class="number">26.7</span>kb</span><br><span class="line">green  open   .marvel-es<span class="number">-2016.03</span><span class="number">.29</span>   <span class="number">1</span>   <span class="number">1</span>     <span class="number">162773</span>           <span class="number">54</span>     <span class="number">94.6</span>mb         <span class="number">47.3</span>mb</span><br></pre></td></tr></table></figure>
<ul>
<li>创建customer索引,pretty表示打印json响应:<code>curl -XPUT &#39;http://server:9200/customer?pretty&#39;</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"acknowledged"</span> : <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>索引数据：<code>curl -XPUT &#39;http://server:9200/customer/external/1?pretty&#39; &#39;-d { &quot;name&quot;:&quot;JOhn Doe&quot;}&#39;</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"_index"</span> : <span class="string">"customer"</span>,</span><br><span class="line">  <span class="string">"_type"</span> : <span class="string">"external"</span>,</span><br><span class="line">  <span class="string">"_id"</span> : <span class="string">"1"</span>,</span><br><span class="line">  <span class="string">"_version"</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="string">"_shards"</span> : &#123;</span><br><span class="line">    <span class="string">"total"</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="string">"successful"</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="string">"failed"</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"created"</span> : <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>查询数据：<code>curl -XGET &#39;http://server:9200/customer/external/1?pretty&#39;</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"_index"</span> : <span class="string">"customer"</span>,</span><br><span class="line">  <span class="string">"_type"</span> : <span class="string">"external"</span>,</span><br><span class="line">  <span class="string">"_id"</span> : <span class="string">"1"</span>,</span><br><span class="line">  <span class="string">"_version"</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="string">"found"</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"_source"</span> : &#123;</span><br><span class="line">    <span class="string">"name"</span> : <span class="string">"JOhn Doe"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>删除索引:<code>curl -XDELETE &#39;http://server:9200/customer?pretty</code> `</p>
</li>
<li><p>通过id更新索引数据:<code>curl -XPUT &#39;http://server:9200/customer/external/1?pretty&#39; &#39;-d { &quot;name&quot;:&quot;JOhn Doe&quot;}&#39;</code></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"_index"</span> : <span class="string">"customer"</span>,</span><br><span class="line">  <span class="string">"_type"</span> : <span class="string">"external"</span>,</span><br><span class="line">  <span class="string">"_id"</span> : <span class="string">"1"</span>,</span><br><span class="line">  <span class="string">"_version"</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="string">"_shards"</span> : &#123;</span><br><span class="line">    <span class="string">"total"</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="string">"successful"</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="string">"failed"</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"created"</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加索引数据随机id:<code>curl -XPOST &#39;http://server:9200/customer/external?pretty&#39; &#39;-d { &quot;name&quot;:&quot;JOhn Doe&quot;}&#39;</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"_index"</span> : <span class="string">"customer"</span>,</span><br><span class="line">  <span class="string">"_type"</span> : <span class="string">"external"</span>,</span><br><span class="line">  <span class="string">"_id"</span> : <span class="string">"AVQFbXxylcDfhGhMoLpJ"</span>,</span><br><span class="line">  <span class="string">"_version"</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="string">"_shards"</span> : &#123;</span><br><span class="line">    <span class="string">"total"</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="string">"successful"</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="string">"failed"</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"created"</span> : <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>通过id删除：<code>curl -XDELETE &#39;http://server:9200/customer/external/2?pretty&#39;</code></p>
</li>
<li><p>通过查询删除:</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -XDELETE 'http://server:9200/customer/external/_query?pretty' -d '</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123; "match": &#123; "name": "John" &#125; &#125;</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure>
<ul>
<li>批量新增</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST 'http://server:9200/customer/external/_bulk?pretty' -d '</span><br><span class="line">&#123;"index":&#123;"_id":"1"&#125;&#125;</span><br><span class="line">&#123;"name": "John Doe" &#125;</span><br><span class="line">&#123;"index":&#123;"_id":"2"&#125;&#125;</span><br><span class="line">&#123;"name": "Jane Doe" &#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure>
<ul>
<li>批量更新/删除</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST 'http://server:9200/customer/external/_bulk?pretty' -d '</span><br><span class="line">&#123;"update":&#123;"_id":"1"&#125;&#125;</span><br><span class="line">&#123;"doc": &#123; "name": "John Doe becomes Jane Doe" &#125; &#125;</span><br><span class="line">&#123;"delete":&#123;"_id":"2"&#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>读文件批量索引</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST 'http://server:9200/bank/account/_bulk?pretty' --data-binary @accounts.json</span><br></pre></td></tr></table></figure>
<ul>
<li>批量索引操作</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST 'http://server:9200/bank/_search?pretty' -d '</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "must": [</span><br><span class="line">        &#123; "match": &#123; "address": "mill" &#125; &#125;,</span><br><span class="line">        &#123; "match": &#123; "address": "lane" &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure>
<ul>
<li>查看进程信息，包括打开文件数，是否锁定内存等:<code>curl &#39;http://server:9200/_nodes/process?pretty&#39;</code></li>
</ul>
<h2 id="索引相关"><a href="#索引相关" class="headerlink" title="索引相关"></a>索引相关</h2><table>
<thead>
<tr>
<th style="text-align:left">URL</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">/index/_search</td>
<td style="text-align:left">不解释</td>
</tr>
<tr>
<td style="text-align:left">/_aliases</td>
<td style="text-align:left">获取或操作索引的别名</td>
</tr>
<tr>
<td style="text-align:left">/index/</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">/index/type/</td>
<td style="text-align:left">创建或操作类型</td>
</tr>
<tr>
<td style="text-align:left">/index/_mapping</td>
<td style="text-align:left">创建或操作mapping</td>
</tr>
<tr>
<td style="text-align:left">/index/_settings</td>
<td style="text-align:left">创建或操作设置(number_of_shards是不可更改的)</td>
</tr>
<tr>
<td style="text-align:left">/index/_open</td>
<td style="text-align:left">打开被关闭的索引</td>
</tr>
<tr>
<td style="text-align:left">/index/_close</td>
<td style="text-align:left">关闭索引</td>
</tr>
<tr>
<td style="text-align:left">/index/_refresh</td>
<td style="text-align:left">刷新索引（使新加内容对搜索可见）</td>
</tr>
<tr>
<td style="text-align:left">/index/_flush</td>
<td style="text-align:left">刷新索引，将变动提交到lucene索引文件中，并清空elasticsearch的transaction log</td>
</tr>
<tr>
<td style="text-align:left">/index/_optimize</td>
<td style="text-align:left">优化segement，个人认为主要是对segement进行合并</td>
</tr>
<tr>
<td style="text-align:left">/index/_status</td>
<td style="text-align:left">获得索引的状态信息</td>
</tr>
<tr>
<td style="text-align:left">/index/_segments</td>
<td style="text-align:left">获得索引的segments的状态信息</td>
</tr>
<tr>
<td style="text-align:left">/index/_explain</td>
<td style="text-align:left">不执行实际搜索，而返回解释信息</td>
</tr>
<tr>
<td style="text-align:left">/index/_analyze</td>
<td style="text-align:left">不执行实际搜索，根据输入的参数进行文本分析</td>
</tr>
<tr>
<td style="text-align:left">/index/type/id</td>
<td style="text-align:left">操作指定文档，不解释</td>
</tr>
<tr>
<td style="text-align:left">/index/type/id/_create</td>
<td style="text-align:left">创建一个文档，如果该文件已经存在，则返回失败</td>
</tr>
<tr>
<td style="text-align:left">/index/type/id/_update</td>
<td style="text-align:left">更新一个文件，如果改文件不存在，则返回失败</td>
</tr>
</tbody>
</table>
<h2 id="集群相关"><a href="#集群相关" class="headerlink" title="集群相关"></a>集群相关</h2><table>
<thead>
<tr>
<th style="text-align:left">URL</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">/_cluster/nodes</td>
<td style="text-align:left">获得集群中的节点列表和信息</td>
</tr>
<tr>
<td style="text-align:left">/_cluster/health</td>
<td style="text-align:left">获得集群信息</td>
</tr>
<tr>
<td style="text-align:left">/_cluster/state</td>
<td style="text-align:left">获得集群里的所有信息（集群信息、节点信息、mapping信息等）</td>
</tr>
</tbody>
</table>
<h2 id="节点相关"><a href="#节点相关" class="headerlink" title="节点相关"></a>节点相关</h2><table>
<thead>
<tr>
<th style="text-align:left">URL</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">/_nodes/process</td>
<td style="text-align:left">主要看file descriptor 这个信息</td>
</tr>
<tr>
<td style="text-align:left">/_nodes/process/stats</td>
<td style="text-align:left">统计信息（内存、CPU等）</td>
</tr>
<tr>
<td style="text-align:left">/_nodes/jvm</td>
<td style="text-align:left">获得各节点的虚拟机统计和配置信息</td>
</tr>
<tr>
<td style="text-align:left">/_nodes/jvm/stats</td>
<td style="text-align:left">更详细的虚拟机信息</td>
</tr>
<tr>
<td style="text-align:left">/_nodes/http</td>
<td style="text-align:left">获得各个节点的http信息（如ip地址）</td>
</tr>
<tr>
<td style="text-align:left">/_nodes/http/stats</td>
<td style="text-align:left">获得各个节点处理http请求的统计情况</td>
</tr>
<tr>
<td style="text-align:left">/_nodes/thread_pool</td>
<td style="text-align:left">获得各种类型的线程池，（elasticsearch分别对不同的操作提供不同的线程池）的配置信息</td>
</tr>
<tr>
<td style="text-align:left">/_nodes/thread_pool/stats</td>
<td style="text-align:left">获得各种类型的线程池的统计信息</td>
</tr>
</tbody>
</table>
<p>以上这些操作可以通过如：</p>
<p><code>/_nodes/${nodeId}/jvm/stats</code>，<code>/_nodes/${nodeip}/jvm/stats</code>，<code>/_nodes/${nodeattribute}/jvm/stats</code>的形式针对指定节点的操作。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Elasticsearch入门学习(1)——安装]]></title>
      <url>http://keyunluo.github.io/2016/04/11/2016-04-11-elasticsearch-1.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>ElasticSearch</strong>是一个基于Lucene的接近实时的搜索平台。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口，是当前流行的企业级搜索引擎。本文先从安装Elasticsearch开始，一步一步探索。</p>
</blockquote>
<a id="more"></a>
<h2 id="ES下载和安装"><a href="#ES下载和安装" class="headerlink" title="ES下载和安装"></a>ES下载和安装</h2><ul>
<li><p>es(官方下载地址)[<a href="https://www.elastic.co/downloads/elasticsearch]，最新版本为2.3.1。不过github上有一个更好的选择(ElasticSearch-RTF)[https://github.com/medcl/elasticsearch-rtf.git],这个版本中已经集成了中文分词插件等，并且已经将插件配置好了，最新版本为2.2.1" target="_blank" rel="external">https://www.elastic.co/downloads/elasticsearch]，最新版本为2.3.1。不过github上有一个更好的选择(ElasticSearch-RTF)[https://github.com/medcl/elasticsearch-rtf.git],这个版本中已经集成了中文分词插件等，并且已经将插件配置好了，最新版本为2.2.1</a> ，非常适合初学者。安装时注意了，不要使用root权限用户安装es，否则es启动会报错，应该创建一个普通的用户安装es。</p>
</li>
<li><p>运行环境</p>
<ul>
<li>Linux和windows均可</li>
<li>jdk7+</li>
<li>32位/64位</li>
</ul>
</li>
<li><p>配置文件</p>
</li>
</ul>
<p>本文将Elasticsearch安装在<code>/opt/bigdata/elasticsearch</code>目录下，版本为<code>2.2.0</code>，集群为<code>Redhat7</code>，配置文件为<code>/opt/bigdata/elasticsearch/config/elasticsearch.yml</code>，下面贴上配置文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"># ======================== Elasticsearch Configuration =========================</span><br><span class="line">#</span><br><span class="line"># NOTE: Elasticsearch comes with reasonable defaults <span class="keyword">for</span> most settings.</span><br><span class="line">#       Before you <span class="built_in">set</span> out to tweak and tune the configuration, make sure you</span><br><span class="line">#       understand what are you trying to accomplish and the consequences.</span><br><span class="line">#</span><br><span class="line"># The primary way of configuring a node is via <span class="keyword">this</span> file. This <span class="keyword">template</span> lists</span><br><span class="line"># the most important settings you may want to configure <span class="keyword">for</span> a production cluster.</span><br><span class="line">#</span><br><span class="line"># Please see the documentation <span class="keyword">for</span> further information on configuration options:</span><br><span class="line"># &lt;http:<span class="comment">//www.elastic.co/guide/en/elasticsearch/reference/current/setup-configuration.html&gt;</span></span><br><span class="line">#</span><br><span class="line"># ---------------------------------- Cluster -----------------------------------</span><br><span class="line">#</span><br><span class="line"># Use a descriptive name <span class="keyword">for</span> your cluster:</span><br><span class="line"># 集群名称</span><br><span class="line"> cluster.name: Elasticsearch</span><br><span class="line">#</span><br><span class="line"># ------------------------------------ Node ------------------------------------</span><br><span class="line">#</span><br><span class="line"># Use a descriptive name <span class="keyword">for</span> the node:</span><br><span class="line"># 节点信息</span><br><span class="line"> node.name: ES-Hadoop-Spark-Master</span><br><span class="line"> node.master: <span class="literal">true</span></span><br><span class="line"> node.data: <span class="literal">true</span></span><br><span class="line"> index.number_of_replicas: <span class="number">1</span></span><br><span class="line">#</span><br><span class="line"># Add custom attributes to the node:</span><br><span class="line">#</span><br><span class="line"># node.rack: r1</span><br><span class="line">#</span><br><span class="line"># ----------------------------------- Paths ------------------------------------</span><br><span class="line">#</span><br><span class="line"># Path to directory where to store the data (separate multiple locations by comma):</span><br><span class="line"># 数据路径</span><br><span class="line"> path.data: /opt/elasticsearch/data</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Path to <span class="built_in">log</span> files:</span><br><span class="line">#</span><br><span class="line"># path.logs: /path/to/logs</span><br><span class="line"> path.logs: /opt/elasticsearch/logs</span><br><span class="line"> path.work: /opt/elasticsearch/work</span><br><span class="line"># ----------------------------------- Memory -----------------------------------</span><br><span class="line">#</span><br><span class="line"># Lock the memory on startup:</span><br><span class="line">#</span><br><span class="line"># bootstrap.mlockall: <span class="literal">true</span></span><br><span class="line">#</span><br><span class="line"># Make sure that the `ES_HEAP_SIZE` environment variable is <span class="built_in">set</span> to about half the memory</span><br><span class="line"># available on the system and that the owner of the process is allowed to use <span class="keyword">this</span> limit.</span><br><span class="line">#</span><br><span class="line"># Elasticsearch performs poorly when the system is swapping the memory.</span><br><span class="line">#</span><br><span class="line"># ---------------------------------- Network -----------------------------------</span><br><span class="line">#</span><br><span class="line"># Set the bind address to a specific IP (IPv4 or IPv6):</span><br><span class="line"># 网络，设置为外网可以访问</span><br><span class="line"> network.host: <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">#</span><br><span class="line"># Set a custom port <span class="keyword">for</span> HTTP:</span><br><span class="line"># 端口，默认<span class="number">9200</span></span><br><span class="line"> http.port: <span class="number">9200</span></span><br><span class="line">#</span><br><span class="line"># For more information, see the documentation at:</span><br><span class="line"># &lt;http:<span class="comment">//www.elastic.co/guide/en/elasticsearch/reference/current/modules-network.html&gt;</span></span><br><span class="line">#</span><br><span class="line"># --------------------------------- Discovery ----------------------------------</span><br><span class="line">#</span><br><span class="line"># Pass an initial <span class="built_in">list</span> of hosts to perform discovery when <span class="keyword">new</span> node is started:</span><br><span class="line"># The <span class="keyword">default</span> <span class="built_in">list</span> of hosts is [<span class="string">"127.0.0.1"</span>, <span class="string">"[::1]"</span>]</span><br><span class="line">#</span><br><span class="line"># discovery.zen.ping.unicast.hosts: [<span class="string">"host1"</span>, <span class="string">"host2"</span>]</span><br><span class="line">#</span><br><span class="line"># Prevent the <span class="string">"split brain"</span> by configuring the majority of nodes (total number of nodes / <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">#</span><br><span class="line"># discovery.zen.minimum_master_nodes: <span class="number">3</span></span><br><span class="line">#</span><br><span class="line"># For more information, see the documentation at:</span><br><span class="line"># &lt;http:<span class="comment">//www.elastic.co/guide/en/elasticsearch/reference/current/modules-discovery.html&gt;</span></span><br><span class="line"># 设置节点自动发现</span><br><span class="line"> discovery.zen.minimum_master_nodes: <span class="number">1</span></span><br><span class="line"> discovery.zen.ping.timeout: <span class="number">3</span>s    ##节点间自动发现的响应时间</span><br><span class="line"> discovery.zen.ping.unicast.hosts: [<span class="string">"192.168.100.101"</span>]</span><br><span class="line"># ---------------------------------- Gateway -----------------------------------</span><br><span class="line">#</span><br><span class="line"># Block initial recovery after a full cluster restart until N nodes are started:</span><br><span class="line">#</span><br><span class="line"># gateway.recover_after_nodes: <span class="number">3</span></span><br><span class="line">#</span><br><span class="line"># For more information, see the documentation at:</span><br><span class="line"># &lt;http:<span class="comment">//www.elastic.co/guide/en/elasticsearch/reference/current/modules-gateway.html&gt;</span></span><br><span class="line">#</span><br><span class="line"># ---------------------------------- Various -----------------------------------</span><br><span class="line">#</span><br><span class="line"># Disable starting multiple nodes on a single system:</span><br><span class="line">#</span><br><span class="line"># node.max_local_storage_nodes: <span class="number">1</span></span><br><span class="line">#</span><br><span class="line"># Require <span class="keyword">explicit</span> names when deleting indices:</span><br><span class="line">#</span><br><span class="line"># action.destructive_requires_name: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>在上述配置中，已经设置主节点为<code>192.168.100.101</code>，还有两个从节点<code>192.168.100.107</code>以及<code>192.168.100.110</code>，它们的配置不同点在于<code>Node</code>的设置，从节点中设置如下：<code>node.name: ES-Hadoop-Spark-Node1</code>，<code>node.master: false</code>,因为设置了节点的自动发现机制，所以在启动Elasticsearch后，集群会自动根据<code>cluster.name: Elasticsearch</code>来添加数据节点。</p>
<ul>
<li>启动集群
进入<code>/opt/bigdata/elasticsearch</code>，运行<code>bin/elasticsearch</code>,便可以启动<code>elasticsearch</code>，如果想当shell关闭时任然要在后台运行elasticsearch服务，可以运行命令<code>nohub bin/elasticsearch &amp;</code>,这样当shell关闭时，仍可访问服务。分别进入到两个数据节点，运行同样的命令，这样，集群便搭建好了。
当然我们也可以在启动的时候修改集群的名称和节点的名称。例如：
<code>bin/elasticsearch --cluster.name my_cluster_name --node.name my_node_name</code>来指定集群名字和主节点。</li>
</ul>
<h2 id="ES插件安装"><a href="#ES插件安装" class="headerlink" title="ES插件安装"></a>ES插件安装</h2><p><code>head</code>插件可以很方便的查询数据和监控集群健康状况，下面以<code>head</code>插件安装为例，介绍下ES2.x下插件安装的一般步骤。</p>
<p>进入<code>/opt/bigdata/elasticsearch</code>目录，运行<code>bin/plugin install mobz/elasticsearch-head</code>, 下载完成后，访问网址<code>http://server:9200/_plugin/head/</code>，便可以看到如下界面，说明安装成功。
<img src="/resource/blog/2016-04/elasticsearch-head.png" alt="head"></p>
<p>插件可以分为核心插件和非核心插件，核心插件是官方提供的，可以直接安装，例如<code>bin/plugin install analysis-icu</code>，这样就会下载合适的版本安装到Elasticsearch中。非核心插件可以是官方提供的，也可以是社区提供的，可以从官方，Maven或者GitHub中下载安装：<code>bin/plugin install [org]/[user|component]/[version]</code>。</p>
<p>例如，安装github上的插件，<code>plugin install lmenezes/elasticsearch-kopf</code>，插件会尝试先到官方去下载，如果没有找到会到maven.com中去下载，如果在没有找到回到github中去下载。脚本还是非常智能的。当我们从直接maven中央库中安装时可以直接使用下面的方式，最后的版本号是必须要写的。
<code>plugin install org.elasticsearch.plugin/mapper-attachments/3.0.0</code>
从自定义网址或者本地安装：<code>plugin install [url]</code>，例如，在本地文件系统中安装一个插件，可以运行：<code>plugin install file:///path/to/plugin.zip</code>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用Sqoop从Oracle中导入数据到hadoop]]></title>
      <url>http://keyunluo.github.io/2016/04/09/2016-04-09-using-sqoop2-oracledb-hadoop.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>本篇博文记录从Oracle12c导入数据到Hadoop中的流程，使用Sqoop2工具,目前Sqoop2只支持将oracle/mysql数据库中的数据与HDFS中数据相互导入导出，目前并不支持导入到HBase/Hive中，因此在实际业务中并不好用，后面介绍使用Sqoop1导入数据到Hbase的流程。</p>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="Sqoop2安装过程"><a href="#Sqoop2安装过程" class="headerlink" title="Sqoop2安装过程"></a>Sqoop2安装过程</h2><ul>
<li><em>1</em>: 下载最新版本的sqoop2:sqoop1.99.6</li>
</ul>
<p><code>wget http://mirrors.ustc.edu.cn/apache/sqoop/1.99.6/sqoop-1.99.6-bin-hadoop200.tar.gz</code></p>
<p>本人将其安装在服务器<code>slave01</code>中的<code>/opt/bigdata/sqoop</code>目录下。</p>
<ul>
<li><em>2</em>:配置环境变量:在<code>/etc/profile</code>中配置环境变量</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export SQOOP2_HOME=/opt/bigdata/sqoop</span><br><span class="line">export PATH=$PATH:$SQOOP2_HOME/bin</span><br><span class="line">export CATALINA_BASE=$SQOOP2_HOME/server</span><br><span class="line">export LOGDIR=$SQOOP2_HOME/logs</span><br></pre></td></tr></table></figure>
<p>在Bash中运行<code>source /etc/profile</code>使环境变量立即生效。</p>
<ul>
<li><em>3</em>: Sqoop服务端配置</li>
</ul>
<p>编辑<code>$SQOOP2_HOME/server/conf/catalina.properties</code>文件，修改<code>common.loader</code>配置，将Hadoop路径下的jar包全部包括进去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">common.loader=$&#123;catalina.base&#125;/lib/*.jar,$&#123;catalina.base&#125;/lib/*.jar,$&#123;catalina.home&#125;/lib/*.jar,$&#123;catalina.home&#125;/lib/*.jar,$&#123;catalina.home&#125;/../lib/*.jar,/opt/bigdata/sqoop/server/lib/*.jar,/opt/hadoop-2.7.1/etc/hadoop,/opt/hadoop-2.7.1/share/hadoop/common/lib/*.jar,/opt/hadoop-2.7.1/share/hadoop/common/*.jar,/opt/hadoop-2.7.1/share/hadoop/hdfs/*.jar,/opt/hadoop-2.7.1/share/hadoop/hdfs/lib/*.jar,/opt/hadoop-2.7.1/share/hadoop/hdfs/*.jar,/opt/hadoop-2.7.1/share/hadoop/yarn/lib/*.jar,/opt/hadoop-2.7.1/share/hadoop/yarn/*.jar,/opt/hadoop-2.7.1/share/hadoop/mapreduce/lib/*.jar,/opt/hadoop-2.7.1/share/hadoop/mapreduce/*.jar,/opt/bigdata/hbase/lib/*.jar</span><br></pre></td></tr></table></figure>
<p>编辑<code>$SQOOP2_HOME/server/conf/sqoop.properties</code>文件，修改Hadoop安装的配置目录:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.sqoop.submission.engine.mapreduce.configuration.directory=/opt/hadoop-2.7.1/etc/hadoop/</span><br></pre></td></tr></table></figure>
<p>找到这行<code>org.apache.sqoop.repository.jdbc.url=jdbc:derby:@BASEDIR@/repository/db;create=true</code>,修改<code>@BASEDIR@</code>为<code>sqoop2</code>安装目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.sqoop.repository.jdbc.url=jdbc:derby:/opt/bigdata/sqoop/repository/db;create=true</span><br></pre></td></tr></table></figure>
<ul>
<li><em>4</em>:下载数据库驱动</li>
</ul>
<p>必备驱动：Mysql数据取驱动是必须使用的，这里使用的是<code>mysql-connector-java-5.1.37-bin.jar</code></p>
<p>Oracle驱动：因为要连接Oracle数据库，所以还要使用oracle的驱动：<code>ojdbc7.jar</code></p>
<p>将上述两个驱动复制到<code>$SQOOP2_HOME/server/lib</code>目录下，至此，配置完成。</p>
<h2 id="验证sqoop2安装"><a href="#验证sqoop2安装" class="headerlink" title="验证sqoop2安装"></a>验证sqoop2安装</h2><p>使用<code>sqoop2-tool verify</code>验证Sqoo2是否安装成功：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@slave01 sqoop]$ sqoop2-tool verify</span><br><span class="line">Sqoop home directory: /opt/bigdata/sqoop</span><br><span class="line">Setting SQOOP_HTTP_PORT:     12000</span><br><span class="line">Setting SQOOP_ADMIN_PORT:     12001</span><br><span class="line">Using   CATALINA_OPTS:</span><br><span class="line">Adding to CATALINA_OPTS:    -Dsqoop.http.port=12000 -Dsqoop.admin.port=12001</span><br><span class="line">Apr 09, 2016 4:13:03 PM org.apache.catalina.startup.ClassLoaderFactory validateFile</span><br><span class="line">WARNING: Problem with directory [/opt/bigdata/sqoop/lib], exists: [false], isDirectory: [false], canRead: [false]</span><br><span class="line">Sqoop tool executor:</span><br><span class="line">	Version: 1.99.6</span><br><span class="line">	Revision: 07244c3915975f26f03d9e1edf09ab7d06619bb8</span><br><span class="line">	Compiled on Wed Apr 29 10:40:43 CST 2015 by root</span><br><span class="line">Running tool: class org.apache.sqoop.tools.tool.VerifyTool</span><br><span class="line">16/04/09 16:13:03 INFO core.SqoopServer: Booting up Sqoop server</span><br><span class="line">16/04/09 16:13:03 INFO core.PropertiesConfigurationProvider: Starting config file poller thread</span><br><span class="line">log4j: Parsing for [root] with value=[WARN, file].</span><br><span class="line">log4j: Level token is [WARN].</span><br><span class="line">log4j: Category root set to WARN</span><br><span class="line">log4j: Parsing appender named "file".</span><br><span class="line">log4j: Parsing layout options for "file".</span><br><span class="line">log4j: Setting property [conversionPattern] to [%d&#123;ISO8601&#125; %-5p %c&#123;2&#125; [%l] %m%n].</span><br><span class="line">log4j: End of parsing for "file".</span><br><span class="line">log4j: Setting property [file] to [@LOGDIR@/sqoop.log].</span><br><span class="line">log4j: Setting property [maxBackupIndex] to [5].</span><br><span class="line">log4j: Setting property [maxFileSize] to [25MB].</span><br><span class="line">log4j: setFile called: @LOGDIR@/sqoop.log, true</span><br><span class="line">log4j: setFile ended</span><br><span class="line">log4j: Parsed "file" options.</span><br><span class="line">log4j: Parsing for [org.apache.sqoop] with value=[DEBUG].</span><br><span class="line">log4j: Level token is [DEBUG].</span><br><span class="line">log4j: Category org.apache.sqoop set to DEBUG</span><br><span class="line">log4j: Handling log4j.additivity.org.apache.sqoop=[null]</span><br><span class="line">log4j: Parsing for [org.apache.derby] with value=[INFO].</span><br><span class="line">log4j: Level token is [INFO].</span><br><span class="line">log4j: Category org.apache.derby set to INFO</span><br><span class="line">log4j: Handling log4j.additivity.org.apache.derby=[null]</span><br><span class="line">log4j: Finished configuring.</span><br><span class="line">SLF4J: Class path contains multiple SLF4J bindings.</span><br><span class="line">SLF4J: Found binding in [jar:file:/opt/hadoop-2.7.1/share/hadoop/common/lib/slf4j-log4j12-1.7.10.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: Found binding in [jar:file:/opt/bigdata/hbase/lib/slf4j-log4j12-1.7.10.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.</span><br><span class="line">SLF4J: Actual binding is of type [org.slf4j.impl.Log4jLoggerFactory]</span><br><span class="line">log4j: Could not find root logger information. Is this OK?</span><br><span class="line">log4j: Parsing for [default] with value=[INFO,defaultAppender].</span><br><span class="line">log4j: Level token is [INFO].</span><br><span class="line">log4j: Category default set to INFO</span><br><span class="line">log4j: Parsing appender named "defaultAppender".</span><br><span class="line">log4j: Parsing layout options for "defaultAppender".</span><br><span class="line">log4j: Setting property [conversionPattern] to [%d %-5p %c: %m%n].</span><br><span class="line">log4j: End of parsing for "defaultAppender".</span><br><span class="line">log4j: Setting property [file] to [@LOGDIR@/default.audit].</span><br><span class="line">log4j: setFile called: @LOGDIR@/default.audit, true</span><br><span class="line">log4j: setFile ended</span><br><span class="line">log4j: Parsed "defaultAppender" options.</span><br><span class="line">log4j: Handling log4j.additivity.default=[null]</span><br><span class="line">log4j: Finished configuring.</span><br><span class="line">log4j: Finalizing appender named [EventCounter].</span><br><span class="line">Exception in thread "PurgeThread" org.apache.sqoop.common.SqoopException: JDBCREPO_0009:Failed to finalize transaction</span><br><span class="line">	at org.apache.sqoop.repository.JdbcRepositoryTransaction.close(JdbcRepositoryTransaction.java:115)</span><br><span class="line">	at org.apache.sqoop.repository.JdbcRepository.doWithConnection(JdbcRepository.java:111)</span><br><span class="line">	at org.apache.sqoop.repository.JdbcRepository.doWithConnection(JdbcRepository.java:63)</span><br><span class="line">	at org.apache.sqoop.repository.JdbcRepository.purgeSubmissions(JdbcRepository.java:591)</span><br><span class="line">	at org.apache.sqoop.driver.JobManager$PurgeThread.run(JobManager.java:660)</span><br><span class="line">Caused by: java.sql.SQLNonTransientConnectionException: No current connection.</span><br><span class="line">	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(Unknown Source)</span><br><span class="line">	at org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Unknown Source)</span><br><span class="line">	at org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Unknown Source)</span><br><span class="line">	at org.apache.derby.impl.jdbc.Util.noCurrentConnection(Unknown Source)</span><br><span class="line">	at org.apache.derby.impl.jdbc.EmbedConnection.checkIfClosed(Unknown Source)</span><br><span class="line">	at org.apache.derby.impl.jdbc.EmbedConnection.setupContextStack(Unknown Source)</span><br><span class="line">	at org.apache.derby.impl.jdbc.EmbedConnection.commit(Unknown Source)</span><br><span class="line">	at org.apache.commons.dbcp.DelegatingConnection.commit(DelegatingConnection.java:334)</span><br><span class="line">	at org.apache.commons.dbcp.DelegatingConnection.commit(DelegatingConnection.java:334)</span><br><span class="line">	at org.apache.commons.dbcp.PoolingDataSource$PoolGuardConnectionWrapper.commit(PoolingDataSource.java:211)</span><br><span class="line">	at org.apache.sqoop.repository.JdbcRepositoryTransaction.close(JdbcRepositoryTransaction.java:112)</span><br><span class="line">	... 4 more</span><br><span class="line">Caused by: java.sql.SQLException: No current connection.</span><br><span class="line">	at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(Unknown Source)</span><br><span class="line">	at org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(Unknown Source)</span><br><span class="line">	... 15 more</span><br><span class="line">Verification was successful.</span><br><span class="line">Tool class org.apache.sqoop.tools.tool.VerifyTool has finished correctly.</span><br><span class="line">[hadoop@slave01 sqoop]$</span><br></pre></td></tr></table></figure>
<p>忽略<code>JDBCREPO_0009</code>异常，出现<code>Verification was successful</code>则说明安装是没有问题的。</p>
<h2 id="连接Oracle数据库"><a href="#连接Oracle数据库" class="headerlink" title="连接Oracle数据库"></a>连接Oracle数据库</h2><ul>
<li>1 启动sqoop</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@slave01 sqoop]$ sqoop.sh server start</span><br><span class="line">Sqoop home directory: /opt/bigdata/sqoop</span><br><span class="line">Setting SQOOP_HTTP_PORT:     <span class="number">12000</span></span><br><span class="line">Setting SQOOP_ADMIN_PORT:     <span class="number">12001</span></span><br><span class="line">Using   CATALINA_OPTS:</span><br><span class="line">Adding to CATALINA_OPTS:    -Dsqoop.http.port=<span class="number">12000</span> -Dsqoop.admin.port=<span class="number">12001</span></span><br><span class="line">Using CATALINA_BASE:   /opt/bigdata/sqoop/server</span><br><span class="line">Using CATALINA_HOME:   /opt/bigdata/sqoop/server</span><br><span class="line">Using CATALINA_TMPDIR: /opt/bigdata/sqoop/server/temp</span><br><span class="line">Using JRE_HOME:        /opt/oracle_jdk_1<span class="number">.7</span></span><br><span class="line">Using CLASSPATH:       /opt/bigdata/sqoop/server/bin/bootstrap.jar</span><br></pre></td></tr></table></figure>
<ul>
<li>2 使用<code>sqoop2-shell</code>操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@slave01 sqoop]$ sqoop2-shell</span><br><span class="line">Sqoop home directory: /opt/bigdata/sqoop</span><br><span class="line">Sqoop Shell: Type <span class="string">'help'</span> <span class="keyword">or</span> <span class="string">'\h'</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line">sqoop:<span class="number">000</span>&gt; show version --all</span><br><span class="line">client version:</span><br><span class="line">  Sqoop <span class="number">1.99</span><span class="number">.6</span> source revision <span class="number">07244</span>c3915975f26f03d9e1edf09ab7d06619bb8</span><br><span class="line">  Compiled by root on Wed Apr <span class="number">29</span> <span class="number">10</span>:<span class="number">40</span>:<span class="number">43</span> CST <span class="number">2015</span></span><br><span class="line">SLF4J: Class path contains multiple SLF4J bindings.</span><br><span class="line">SLF4J: Found binding <span class="keyword">in</span> [jar:file:/opt/hadoop<span class="number">-2.7</span><span class="number">.1</span>/share/hadoop/common/lib/slf4j-log4j12<span class="number">-1.7</span><span class="number">.10</span>.jar!/org/slf4j/impl/StaticLoggerBinder.<span class="keyword">class</span>]</span><br><span class="line">SLF4J: Found binding <span class="keyword">in</span> [jar:file:/opt/bigdata/sqoop/shell/lib/slf4j-log4j12<span class="number">-1.6</span><span class="number">.1</span>.jar!/org/slf4j/impl/StaticLoggerBinder.<span class="keyword">class</span>]</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html<span class="comment">#multiple_bindings for an explanation.</span></span><br><span class="line">SLF4J: Actual binding <span class="keyword">is</span> of type [org.slf4j.impl.Log4jLoggerFactory]</span><br><span class="line"><span class="number">16</span>/<span class="number">04</span>/<span class="number">09</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">50</span> WARN util.NativeCodeLoader: Unable to load native-hadoop library <span class="keyword">for</span> your platform... using builtin-java classes where applicable</span><br><span class="line">server version:</span><br><span class="line">  Sqoop <span class="number">1.99</span><span class="number">.6</span> source revision <span class="number">07244</span>c3915975f26f03d9e1edf09ab7d06619bb8</span><br><span class="line">  Compiled by root on Wed Apr <span class="number">29</span> <span class="number">10</span>:<span class="number">40</span>:<span class="number">43</span> CST <span class="number">2015</span></span><br><span class="line">API versions:</span><br><span class="line">  [v1]</span><br><span class="line">sqoop:<span class="number">000</span>&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>3 查看可用的connectors</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sqoop:<span class="number">000</span>&gt; show connector</span><br><span class="line">+----+------------------------+---------+------------------------------------------------------+----------------------+</span><br><span class="line">| Id |          Name          | Version |                        Class                         | Supported Directions |</span><br><span class="line">+----+------------------------+---------+------------------------------------------------------+----------------------+</span><br><span class="line">| <span class="number">1</span>  | kite-connector         | <span class="number">1.99</span><span class="number">.6</span>  | org.apache.sqoop.connector.kite.KiteConnector        | FROM/TO              |</span><br><span class="line">| <span class="number">2</span>  | kafka-connector        | <span class="number">1.99</span><span class="number">.6</span>  | org.apache.sqoop.connector.kafka.KafkaConnector      | TO                   |</span><br><span class="line">| <span class="number">3</span>  | hdfs-connector         | <span class="number">1.99</span><span class="number">.6</span>  | org.apache.sqoop.connector.hdfs.HdfsConnector        | FROM/TO              |</span><br><span class="line">| <span class="number">4</span>  | generic-jdbc-connector | <span class="number">1.99</span><span class="number">.6</span>  | org.apache.sqoop.connector.jdbc.GenericJdbcConnector | FROM/TO              |</span><br><span class="line">+----+------------------------+---------+------------------------------------------------------+----------------------+</span><br><span class="line">sqoop:<span class="number">000</span>&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们将要使用的是hdfs和jdbc连接。</p>
<ul>
<li>4 创建Oracle连接</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sqoop:<span class="number">000</span>&gt; create link -c <span class="number">4</span></span><br><span class="line">Creating link <span class="keyword">for</span> connector <span class="keyword">with</span> id <span class="number">4</span></span><br><span class="line">Please fill following values to create new link object</span><br><span class="line">Name: Oracle DB</span><br><span class="line"></span><br><span class="line">Link configuration</span><br><span class="line"></span><br><span class="line">JDBC Driver Class: oracle.jdbc.OracleDriver</span><br><span class="line">JDBC Connection String: jdbc:oracle:thin:@//<span class="number">192.168</span><span class="number">.100</span><span class="number">.108</span>/orcl</span><br><span class="line">Username: c<span class="comment">##hadoop</span></span><br><span class="line">Password: ******</span><br><span class="line">JDBC Connection Properties:</span><br><span class="line">There are currently <span class="number">0</span> values <span class="keyword">in</span> the map:</span><br><span class="line">entry<span class="comment">#</span></span><br><span class="line">New link was successfully created <span class="keyword">with</span> validation status OK <span class="keyword">and</span> persistent id <span class="number">6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>5 创建HDFS连接</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sqoop:<span class="number">000</span>&gt; create link -c <span class="number">3</span></span><br><span class="line">Creating link <span class="keyword">for</span> connector <span class="keyword">with</span> id <span class="number">3</span></span><br><span class="line">Please fill following values to create new link object</span><br><span class="line">Name: HDFS Link</span><br><span class="line"></span><br><span class="line">Link configuration</span><br><span class="line"></span><br><span class="line">HDFS URI: hdfs://slave01:<span class="number">9000</span>/</span><br><span class="line">Hadoop conf directory: /opt/hadoop<span class="number">-2.7</span><span class="number">.1</span>/etc/hadoop</span><br><span class="line">New link was successfully created <span class="keyword">with</span> validation status OK <span class="keyword">and</span> persistent id <span class="number">7</span></span><br></pre></td></tr></table></figure>
<ul>
<li>6 验证连接</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sqoop:<span class="number">000</span>&gt; show link</span><br><span class="line">+----+------------+--------------+------------------------+---------+</span><br><span class="line">| Id |    Name    | Connector Id |     Connector Name     | Enabled |</span><br><span class="line">+----+------------+--------------+------------------------+---------+</span><br><span class="line">| <span class="number">6</span>  | Oracle DB  | <span class="number">4</span>            | generic-jdbc-connector | true    |</span><br><span class="line">| <span class="number">7</span>  | HDFS Link  | <span class="number">3</span>            | hdfs-connector         | true    |</span><br><span class="line">+----+------------+--------------+------------------------+---------+</span><br></pre></td></tr></table></figure>
<ul>
<li>7 创建<code>Sqoop Job</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">sqoop:<span class="number">000</span>&gt; create job -f <span class="number">6</span> -t <span class="number">7</span></span><br><span class="line">Creating job <span class="keyword">for</span> links <span class="keyword">with</span> <span class="keyword">from</span> id <span class="number">6</span> <span class="keyword">and</span> to id <span class="number">7</span></span><br><span class="line">Please fill following values to create new job object</span><br><span class="line">Name: Oracle HDFS</span><br><span class="line"></span><br><span class="line">From database configuration</span><br><span class="line"></span><br><span class="line">Schema name: C<span class="comment">##hadoop</span></span><br><span class="line">Table name: T_DTXX_GPSXX20160317</span><br><span class="line">Table SQL statement:</span><br><span class="line">Table column names: ID,ZDBH,GPSSJ,JLSJ,CCSJ,JD,WD,WXSL,BZ</span><br><span class="line">Partition column name: ID</span><br><span class="line">Null value allowed <span class="keyword">for</span> the partition column:</span><br><span class="line">Boundary query:</span><br><span class="line"></span><br><span class="line">Incremental read</span><br><span class="line"></span><br><span class="line">Check column:</span><br><span class="line">Last value:</span><br><span class="line"></span><br><span class="line">To HDFS configuration</span><br><span class="line"></span><br><span class="line">Override null value:</span><br><span class="line">Null value:</span><br><span class="line">Output format:</span><br><span class="line">  <span class="number">0</span> : TEXT_FILE</span><br><span class="line">  <span class="number">1</span> : SEQUENCE_FILE</span><br><span class="line">Choose: <span class="number">0</span></span><br><span class="line">Compression format:</span><br><span class="line">  <span class="number">0</span> : NONE</span><br><span class="line">  <span class="number">1</span> : DEFAULT</span><br><span class="line">  <span class="number">2</span> : DEFLATE</span><br><span class="line">  <span class="number">3</span> : GZIP</span><br><span class="line">  <span class="number">4</span> : BZIP2</span><br><span class="line">  <span class="number">5</span> : LZO</span><br><span class="line">  <span class="number">6</span> : LZ4</span><br><span class="line">  <span class="number">7</span> : SNAPPY</span><br><span class="line">  <span class="number">8</span> : CUSTOM</span><br><span class="line">Choose: <span class="number">0</span></span><br><span class="line">Custom compression format:</span><br><span class="line">Output directory: /user/hadoop/oracledata</span><br><span class="line">Append mode:</span><br><span class="line"></span><br><span class="line">Throttling resources</span><br><span class="line"></span><br><span class="line">Extractors:</span><br><span class="line">Loaders:</span><br><span class="line">New job was successfully created <span class="keyword">with</span> validation status OK  <span class="keyword">and</span> persistent id <span class="number">3</span></span><br><span class="line">sqoop:<span class="number">000</span>&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>8 查看Job</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sqoop:<span class="number">000</span>&gt; show job</span><br><span class="line">+----+--------------+----------------+--------------+---------+</span><br><span class="line">| Id |     Name     | From Connector | To Connector | Enabled |</span><br><span class="line">+----+--------------+----------------+--------------+---------+</span><br><span class="line">| <span class="number">1</span>  | OH           | <span class="number">4</span>              | <span class="number">3</span>            | true    |</span><br><span class="line">| <span class="number">2</span>  | <span class="number">1519</span>         | <span class="number">4</span>              | <span class="number">3</span>            | true    |</span><br><span class="line">| <span class="number">3</span>  | Oracle HDFS  | <span class="number">4</span>              | <span class="number">3</span>            | true    |</span><br><span class="line">+----+--------------+----------------+--------------+---------+</span><br></pre></td></tr></table></figure>
<p>其中<code>3</code>就是我们刚刚创建的Job。</p>
<ul>
<li>9 启动Job</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sqoop:<span class="number">000</span>&gt; start job -j <span class="number">3</span></span><br><span class="line">Submission details</span><br><span class="line">Job ID: <span class="number">3</span></span><br><span class="line">Server URL: http://localhost:<span class="number">12000</span>/sqoop/</span><br><span class="line">Created by: hadoop</span><br><span class="line">Creation date: <span class="number">2016</span><span class="number">-04</span><span class="number">-09</span> <span class="number">16</span>:<span class="number">46</span>:<span class="number">57</span> CST</span><br><span class="line">Lastly updated by: hadoop</span><br><span class="line">External ID: job_1459172324738_0017</span><br><span class="line">	http://slave01:<span class="number">8088</span>/proxy/application_1459172324738_0017/</span><br><span class="line">Source Connector schema: Schema&#123;name=C<span class="comment">##hadoop.T_DTXX_GPSXX20160317,columns=[</span></span><br><span class="line">	Text&#123;name=ID,nullable=true,type=TEXT,charSize=null&#125;,</span><br><span class="line">	Text&#123;name=ZDBH,nullable=true,type=TEXT,charSize=null&#125;,</span><br><span class="line">	Date&#123;name=GPSSJ,nullable=true,type=DATE_TIME,hasFraction=true,hasTimezone=false&#125;,</span><br><span class="line">	Date&#123;name=JLSJ,nullable=true,type=DATE_TIME,hasFraction=true,hasTimezone=false&#125;,</span><br><span class="line">	Date&#123;name=CCSJ,nullable=true,type=DATE_TIME,hasFraction=true,hasTimezone=false&#125;,</span><br><span class="line">	Text&#123;name=JD,nullable=true,type=TEXT,charSize=null&#125;,</span><br><span class="line">	Text&#123;name=WD,nullable=true,type=TEXT,charSize=null&#125;,</span><br><span class="line">	Decimal&#123;name=WXSL,nullable=true,type=DECIMAL,precision=<span class="number">2</span>,scale=<span class="number">0</span>&#125;,</span><br><span class="line">	Text&#123;name=BZ,nullable=true,type=TEXT,charSize=null&#125;]&#125;</span><br><span class="line"><span class="number">2016</span><span class="number">-04</span><span class="number">-09</span> <span class="number">16</span>:<span class="number">46</span>:<span class="number">57</span> CST: BOOTING  - Progress <span class="keyword">is</span> <span class="keyword">not</span> available</span><br></pre></td></tr></table></figure>
<p>没有抛出异常后，sqoop就已经在后台开始运行了，这时候可以查看Hadoop JobServer,可以看到任务已经在运行了。</p>
<ul>
<li>10 查看HDFS上数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@slave01 sqoop]$ hdfs dfs -ls oracledata</span><br><span class="line">Found <span class="number">8</span> items</span><br><span class="line">-rw-r--r--   <span class="number">2</span> hadoop supergroup   <span class="number">46362076</span> <span class="number">2016</span><span class="number">-04</span><span class="number">-09</span> <span class="number">16</span>:<span class="number">47</span> oracledata/<span class="number">034</span>fd092-bd7a<span class="number">-462</span>a-a566<span class="number">-05</span>cd123d11ed.txt</span><br><span class="line">-rw-r--r--   <span class="number">2</span> hadoop supergroup   <span class="number">92831643</span> <span class="number">2016</span><span class="number">-04</span><span class="number">-09</span> <span class="number">16</span>:<span class="number">47</span> oracledata/<span class="number">0</span>b537981<span class="number">-1711</span><span class="number">-411</span>a-bb09-d304c83839ea.txt</span><br><span class="line">-rw-r--r--   <span class="number">2</span> hadoop supergroup   <span class="number">46547213</span> <span class="number">2016</span><span class="number">-04</span><span class="number">-09</span> <span class="number">16</span>:<span class="number">47</span> oracledata/<span class="number">1526e2</span>d2-b385<span class="number">-4</span>a45<span class="number">-9841</span>-f8001fc74a7e.txt</span><br><span class="line">-rw-r--r--   <span class="number">2</span> hadoop supergroup  <span class="number">185898348</span> <span class="number">2016</span><span class="number">-04</span><span class="number">-09</span> <span class="number">16</span>:<span class="number">48</span> oracledata/<span class="number">851645</span>db-b5a3<span class="number">-4265</span><span class="number">-8</span>ead<span class="number">-916</span>c8680dc11.txt</span><br><span class="line">-rw-r--r--   <span class="number">2</span> hadoop supergroup   <span class="number">92913401</span> <span class="number">2016</span><span class="number">-04</span><span class="number">-09</span> <span class="number">16</span>:<span class="number">47</span> oracledata/da722cf7<span class="number">-38</span>d9<span class="number">-41</span>c0-b17f-dcd5a19a69e6.txt</span><br><span class="line">-rw-r--r--   <span class="number">2</span> hadoop supergroup  <span class="number">139531748</span> <span class="number">2016</span><span class="number">-04</span><span class="number">-09</span> <span class="number">16</span>:<span class="number">48</span> oracledata/dacf1fc9-ca48<span class="number">-4058</span><span class="number">-837e-9380</span>aefc2dfe.txt</span><br><span class="line">-rw-r--r--   <span class="number">2</span> hadoop supergroup  <span class="number">139583915</span> <span class="number">2016</span><span class="number">-04</span><span class="number">-09</span> <span class="number">16</span>:<span class="number">48</span> oracledata/e393d0f5-f05a<span class="number">-4790</span>-bde0<span class="number">-9</span>d8d8d4a7b06.txt</span><br></pre></td></tr></table></figure>
<p>至此，数据已经导入了</p>
<h2 id="常用命令总结"><a href="#常用命令总结" class="headerlink" title="常用命令总结"></a>常用命令总结</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">set option --name verbose --value true 设置异常显示，便于查错</span><br><span class="line">sqoop.sh server start    启动</span><br><span class="line">sqoop.sh server stop     停止</span><br><span class="line">sqoop.sh client          进入客户端</span><br><span class="line">set server --host hadoopMaster --port <span class="number">12000</span> --webapp sqoop 设置服务器，注意hadoopMaster为hdfs主机名</span><br><span class="line">show connector --all    查看连接类型</span><br><span class="line">create link --cid <span class="number">1</span>    创建连接，cid为连接类型id</span><br><span class="line">show link 查看连接</span><br><span class="line">update link -l <span class="number">1</span> 修改id为<span class="number">1</span>的连接</span><br><span class="line">delete link -l <span class="number">1</span> 删除id为<span class="number">1</span>的连接</span><br><span class="line">create job -f <span class="number">1</span> -t <span class="number">2</span> 创建从连接<span class="number">1</span>到连接<span class="number">2</span>的job</span><br><span class="line">show job 查看job</span><br><span class="line">update job -jid <span class="number">1</span>    修改job</span><br><span class="line">delete job -jid <span class="number">1</span>    删除job</span><br><span class="line">status job -jid <span class="number">1</span>    看看job状态</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Oracle 12c 使用入门(1) ——SQL*Plus]]></title>
      <url>http://keyunluo.github.io/2016/03/25/2016-03-25-oracle-12c-using.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>本篇博文记录开始使用Oracle12c的一些步骤以及注意事项。</p>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="启动和关闭Oracle数据库"><a href="#启动和关闭Oracle数据库" class="headerlink" title="启动和关闭Oracle数据库"></a>启动和关闭Oracle数据库</h2><p>刚开始安装完Oracle数据库时，如果数据库未设置成自动启动，则启动服务后还需要启动数据库。启动数据库需要以<code>sys</code>用户在<code>SQL * PLUS</code>中执行<code>startup</code>命令。下面命令以操作系统验证的方式连接数据库，不需要输入账号和密码，连接数据库后，以sys用户执行各个操作：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@slave08 ~]$ sqlplus / as sysdba</span><br><span class="line"></span><br><span class="line">SQL*Plus: Release 12.1.0.2.0 Production on Sat Mar 26 15:43:16 2016</span><br><span class="line"></span><br><span class="line">Copyright (c) 1982, 2014, Oracle.  All rights reserved.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Connected to:</span><br><span class="line">Oracle Database 12c Enterprise Edition Release 12.1.0.2.0 - 64bit Production</span><br><span class="line">With the Partitioning, OLAP, Advanced Analytics and Real Application Testing options</span><br><span class="line"></span><br><span class="line">SQL&gt; startup</span><br><span class="line">ORA-01081: cannot start already-running ORACLE - shut it down first</span><br><span class="line">SQL&gt; shutdown immediate</span><br><span class="line">Database closed.</span><br><span class="line">Database dismounted.</span><br><span class="line">ORACLE instance shut down.</span><br><span class="line">SQL&gt; startup</span><br><span class="line">ORACLE instance started.</span><br><span class="line"></span><br><span class="line">Total System Global Area 4.0534E+10 bytes</span><br><span class="line">Fixed Size		    7653432 bytes</span><br><span class="line">Variable Size		 6308235208 bytes</span><br><span class="line">Database Buffers	 3.4091E+10 bytes</span><br><span class="line">Redo Buffers		  126562304 bytes</span><br><span class="line">Database mounted.</span><br><span class="line">Database opened.</span><br><span class="line">SQL&gt;</span><br></pre></td></tr></table></figure>
<p>关闭数据库使用shutdown命令，可以附加normal,transactional,immediate以及abort选项，默认选项为normal，会等待所有用户退出连接后再关闭数据库，一般使用<code>immediate</code>。</p>
<h2 id="常用SQL-PLus操作"><a href="#常用SQL-PLus操作" class="headerlink" title="常用SQL*PLus操作"></a>常用SQL*PLus操作</h2><p>Oracle数据库的客户端工具主要有SQL * Plus(字符界面数据库工具，面向应用开发人员以及数据库管理人员，用于执行SQL命令，编写存储过程，以及各种数据库管理任务) ,SQL Developer(Java编写的一个图形界面工具，面向对象主要是数据库应用开发人员) ,Enterprise Manager(OEM，使用浏览器管理数据，面向对象为数据库管理员)。</p>
<h4 id="使用SQL-Plus连接到本地数据库"><a href="#使用SQL-Plus连接到本地数据库" class="headerlink" title="使用SQL*Plus连接到本地数据库"></a>使用SQL*Plus连接到本地数据库</h4><p>要使用数据库，必须使用合法的用户及密码， 有以下三种方式:</p>
<ul>
<li>启动SQL*Plus的同时，输入用户名及密码。</li>
<li>使用 nolog选项，单独启动SQL*Plus，然后再输入用户名和密码。</li>
<li>单独启动SQL*Plus，根据提示输入用户名和密码。</li>
</ul>
<h4 id="切换连接用户"><a href="#切换连接用户" class="headerlink" title="切换连接用户"></a>切换连接用户</h4><p>SQL*Plus使用<code>connect</code>命令切换用户，<code>connect</code>关键字可以简写为<code>conn</code>,使用<code>show user</code>命令可以查看当前的数据库的用户名称。</p>
<h4 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h4><p>oracle的一个数据库对应一个服务，切换数据库也就是切换数据库服务。本地服务器如果创建了多个数据库，可以通过设置ORACLE_SID环境变量切换SQL*Plus默认连接的数据库。例如：<code>set oracle_sid=law12</code>便可以改变默认连接的数据库。</p>
<h4 id="执行SQL脚本文件"><a href="#执行SQL脚本文件" class="headerlink" title="执行SQL脚本文件"></a>执行SQL脚本文件</h4><p>可以在文本文件中编辑任意SQL命令，然后保存为sql脚本文件，便可以在SQL*Plus中执行该脚本，使用<code>Start</code>或<code>@</code> 该脚本。</p>
<h2 id="设置SQL-Plus环境"><a href="#设置SQL-Plus环境" class="headerlink" title="设置SQL*Plus环境"></a>设置SQL*Plus环境</h2><p>SQL*Plus在启动时，会自动执行<code>%ORACLE_HOME%\sqlplus\admin</code>目录下的<code>glogin.sql</code>文件，可以把经常使用的环境命令设置添加到次文件中。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define_editor=vim  #设置ED命令默认使用的编辑器</span><br><span class="line">set pagesize 100    #每页大小</span><br><span class="line">set linesize 300    #设置每行容纳的字符数量</span><br><span class="line">set sqlprompt `&amp;_user&amp;_connect_identifier&gt;`  #把SQL提示符修改为当前用户名称以及连接的字符串</span><br></pre></td></tr></table></figure>
<p>在SQL*Plus中，可以使用<code>column column_name format an</code>来设置字符串列的显示宽度，以避免显示结果因为换行而显得凌乱，其中的column以及format可以分别简写为col及for,a后面的数字用于指定字符的数量。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">col table_name for a8</span><br><span class="line">col file_name  for a60</span><br><span class="line">col segment_name for a8</span><br><span class="line">col tablespace_name for a8</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu14.04配置L2TP-VPN]]></title>
      <url>http://keyunluo.github.io/2016/03/20/2016-03-20-ubuntu14-l2tp-vpn.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>本节内容：</strong>本篇博文记录在Ubuntu14.04上安装L2TP插件。</p>
</blockquote>
<a id="more"></a>
<h2 id="添加PPA"><a href="#添加PPA" class="headerlink" title="添加PPA"></a>添加PPA</h2><p><code>sudo apt-add-repository ppa:seriy-pr/network-manager-l2tp</code></p>
<h2 id="刷新软件包缓存"><a href="#刷新软件包缓存" class="headerlink" title="刷新软件包缓存"></a>刷新软件包缓存</h2><p><code>sudo apt-get update</code></p>
<h2 id="安装network-manager-l2tp"><a href="#安装network-manager-l2tp" class="headerlink" title="安装network-manager-l2tp"></a>安装network-manager-l2tp</h2><p><code>sudo apt-get install network-manager-l2tp-gnome</code></p>
<h2 id="由于墙问题无法添加PPA"><a href="#由于墙问题无法添加PPA" class="headerlink" title="由于墙问题无法添加PPA"></a>由于墙问题无法添加PPA</h2><p> 若无法进行上述操作，则可以在<a href="https://launchpad.net/~seriy-pr/+archive/ubuntu/network-manager-l2tp/+packages" target="_blank" rel="external">网站</a>下载软件包<code>network-manager-l2tp</code>，<code>network-manager-l2tp-gnome</code>，根据系统是32位还是64位下载相应版本的<code>deb</code>包后先后安装(注意：需要联网下载一些依赖包，需要联网,注意顺序)。</p>
<h2 id="安装完之后需要运行下面命令"><a href="#安装完之后需要运行下面命令" class="headerlink" title="安装完之后需要运行下面命令"></a>安装完之后需要运行下面命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo service xl2tpd stop</span><br><span class="line">sudo update-rc.d xl2tpd disable</span><br></pre></td></tr></table></figure>
<h2 id="重启机器，新建VPN"><a href="#重启机器，新建VPN" class="headerlink" title="重启机器，新建VPN"></a>重启机器，新建VPN</h2><p>在<code>网络</code>-<code>编辑连接</code>-<code>添加</code>-<code>选择连接类型</code>-<code>VPN</code>-<code>L2TP</code>,然后配置网关，用户名密码，若需要共享密钥，则点击<code>ipses settings</code>,在<code>pre-shared key</code>内填入公司分配的共享密钥，否则就可以直接连接VPN了。</p>
<p>图：选择VPN类型</p>
<p><img src="/resource/blog/2016-03/L2TP-VPN.png" alt="L2TP-VPN"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[大数据二次排序]]></title>
      <url>http://keyunluo.github.io/2016/03/07/2016-03-07-hadoop-secondary-sort.html</url>
      <content type="html"><![CDATA[<h2 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h2><blockquote>
<p>在hadoop中每个reduce的输入的key都是有序的，而value则是无序的。而且同一个job运行多次，由于map完成顺序不同，reduce收到的value顺序是不固定的,为了使reduce收到有序的value,便产生了二次排序的概念。</p>
</blockquote>
<a id="more"></a>
<p><strong>二次排序实例</strong>
考虑到在科学实验中的温度数据，它们可能的格式如下，每一列分别为 <code>year</code>,<code>month</code>,<code>day</code>,<code>temperature</code>:
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2012</span>,<span class="number">01</span>,<span class="number">01</span>,<span class="number">5</span></span><br><span class="line"><span class="number">2012</span>,<span class="number">01</span>,<span class="number">02</span>,<span class="number">6</span></span><br><span class="line"><span class="number">2012</span>,<span class="number">01</span>,<span class="number">03</span>,<span class="number">2</span></span><br><span class="line"><span class="number">2012</span>,<span class="number">01</span>,<span class="number">04</span>,<span class="number">1</span></span><br><span class="line"><span class="number">2012</span>,<span class="number">01</span>,<span class="number">05</span>,<span class="number">10</span></span><br><span class="line"><span class="number">2012</span>,<span class="number">01</span>,<span class="number">06</span>,<span class="number">4</span></span><br><span class="line">...</span><br><span class="line"><span class="number">2001</span>,<span class="number">11</span>,<span class="number">01</span>,<span class="number">18</span></span><br><span class="line"><span class="number">2001</span>,<span class="number">11</span>,<span class="number">02</span>,<span class="number">19</span></span><br><span class="line"><span class="number">2001</span>,<span class="number">11</span>,<span class="number">03</span>,<span class="number">15</span></span><br><span class="line"><span class="number">2001</span>,<span class="number">11</span>,<span class="number">04</span>,<span class="number">12</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>我们想按照<code>year-month</code>对温度数据进行升序排序并输出，并且我们希望对<code>reducer</code>中的迭代值是已经排序的。因此，期望的输出为：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2012</span><span class="number">-01</span>: <span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">10.</span>..</span><br><span class="line"><span class="number">2001</span><span class="number">-11</span>: <span class="number">12</span>,<span class="number">15</span>,<span class="number">18</span>,<span class="number">19.</span>..</span><br></pre></td></tr></table></figure></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>为了使用MapReduce编程框架,当数据量很大时在reduce阶段在内存中对同一个key里面的值进行排序是不太可能的，因此<code>通过向原生key增加一部分或全部值(value)作为复合key来实现排序操作</code>。</p>
<p><strong>方法概要</strong>:</p>
<ul>
<li><em>1</em>:使用<code>Value-to-Key</code>设计模式：设计复合Key-Value,<code>(K，V1,V2)=&gt;(K1,V2)</code>，其中K是原生Key，V1是要排序的值，V2是其他值，K1是复合Key，显然K1=(K,V1)。</li>
<li><em>2</em>:使用MapReduce执行框架进行排序(注意：不是直接在内存中排序，而是利用集群节点进行排序)。</li>
<li><em>3</em>:在多个Key-Value键值对中保存状态来进行处理，可以通过原生键对mapper输出的中间结果进行partition操作。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git 常用命令整理]]></title>
      <url>http://keyunluo.github.io/2016/03/07/2016-03-07-git-common-command.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>Git</strong>简单记录Git的常用方法，以备查询。</p>
</blockquote>
<a id="more"></a>
<h2 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置使用git仓库的人员姓名</span></span><br><span class="line">git config --<span class="keyword">global</span> user.name <span class="string">"Your Name Comes Here"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置使用git仓库的人员email</span></span><br><span class="line">git config --<span class="keyword">global</span> user.email you@yourdomain.example.com</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置到缓存 默认15分钟</span></span><br><span class="line">git config --<span class="keyword">global</span> credential.helper cache</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改缓存时间</span></span><br><span class="line">git config --<span class="keyword">global</span> credential.helper <span class="string">'cache --timeout=3600'</span></span><br><span class="line"></span><br><span class="line">git config --<span class="keyword">global</span> color.ui true</span><br><span class="line">git config --<span class="keyword">global</span> alias.co checkout</span><br><span class="line">git config --<span class="keyword">global</span> alias.ci commit</span><br><span class="line">git config --<span class="keyword">global</span> alias.st status</span><br><span class="line">git config --<span class="keyword">global</span> alias.br branch</span><br><span class="line">git config --<span class="keyword">global</span> core.editor <span class="string">"mate -w"</span>    <span class="comment"># 设置Editor使用textmate</span></span><br><span class="line">git config <span class="number">-1</span> <span class="comment">#列举所有配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用户的git配置文件~/.gitconfig</span></span><br></pre></td></tr></table></figure>
<!-- more -->
<hr>
<h2 id="查看、添加、提交、删除、找回，重置修改文件"><a href="#查看、添加、提交、删除、找回，重置修改文件" class="headerlink" title="查看、添加、提交、删除、找回，重置修改文件"></a>查看、添加、提交、删除、找回，重置修改文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">git help &lt;command&gt;  <span class="comment"># 显示command的help</span></span><br><span class="line">git show            <span class="comment"># 显示某次提交的内容</span></span><br><span class="line">git show $id</span><br><span class="line"></span><br><span class="line">git co  -- &lt;file&gt;   <span class="comment"># 抛弃工作区修改</span></span><br><span class="line">git co  .           <span class="comment"># 抛弃工作区修改</span></span><br><span class="line"></span><br><span class="line">git add &lt;file&gt;      <span class="comment"># 将工作文件修改提交到本地暂存区</span></span><br><span class="line">git add .           <span class="comment"># 将所有修改过的工作文件提交暂存区</span></span><br><span class="line"></span><br><span class="line">git rm &lt;file&gt;       <span class="comment"># 从版本库中删除文件</span></span><br><span class="line">git rm &lt;file&gt; --cached  <span class="comment"># 从版本库中删除文件，但不删除文件</span></span><br><span class="line"></span><br><span class="line">git reset &lt;file&gt;    <span class="comment"># 从暂存区恢复到工作文件</span></span><br><span class="line">git reset -- .      <span class="comment"># 从暂存区恢复到工作文件</span></span><br><span class="line">git reset --hard    <span class="comment"># 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改</span></span><br><span class="line"></span><br><span class="line">git ci &lt;file&gt;</span><br><span class="line">git ci .</span><br><span class="line">git ci -a           <span class="comment"># 将git add, git rm和git ci等操作都合并在一起做</span></span><br><span class="line">git ci -am <span class="string">"some comments"</span></span><br><span class="line">git ci --amend      <span class="comment"># 修改最后一次提交记录</span></span><br><span class="line"></span><br><span class="line">git revert &lt;$id&gt;    <span class="comment"># 恢复某次提交的状态，恢复动作本身也创建了一次提交对象</span></span><br><span class="line">git revert HEAD     <span class="comment"># 恢复最后一次提交的状态</span></span><br><span class="line"><span class="comment">#恢复</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="查看文件diff"><a href="#查看文件diff" class="headerlink" title="查看文件diff"></a>查看文件diff</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;file&gt;     <span class="comment"># 比较当前文件和暂存区文件差异</span></span><br><span class="line">git diff</span><br><span class="line">git diff &lt;$id1&gt; &lt;$id2&gt;   <span class="comment"># 比较两次提交之间的差异</span></span><br><span class="line">git diff &lt;branch1&gt;..&lt;branch2&gt; <span class="comment"># 在两个分支之间比较</span></span><br><span class="line">git diff --staged   <span class="comment"># 比较暂存区和版本库差异</span></span><br><span class="line">git diff --cached   <span class="comment"># 比较暂存区和版本库差异</span></span><br><span class="line">git diff --stat     <span class="comment"># 仅仅比较统计信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#退出diff查看状态直接输入Q即可.</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br><span class="line">git log &lt;file&gt;      <span class="comment"># 查看该文件每次提交记录</span></span><br><span class="line">git log -p &lt;file&gt;   <span class="comment"># 查看每次详细修改内容的diff</span></span><br><span class="line">git log -p <span class="number">-2</span>       <span class="comment"># 查看最近两次详细修改内容的diff</span></span><br><span class="line">git log --stat      <span class="comment">#查看提交统计信息</span></span><br></pre></td></tr></table></figure>
<p> tig
Mac上可以使用tig代替diff和log，brew install tig</p>
<hr>
<h2 id="取得Git仓库"><a href="#取得Git仓库" class="headerlink" title="取得Git仓库"></a>取得Git仓库</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#初始化一个版本仓库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment">#Clone远程版本库</span></span><br><span class="line">git clone git@xbc.me:wordpress.gi</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加远程版本库origin，语法为 git remote add [shortname] [url]</span></span><br><span class="line">git remote add origin git@xbc.me:wordpress.git</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看远程仓库</span></span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示远程信息</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="提交你的修改"><a href="#提交你的修改" class="headerlink" title="提交你的修改"></a>提交你的修改</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加当前修改的文件到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果你自动追踪文件，包括你已经手动删除的，状态为Deleted的文件</span></span><br><span class="line">git add -u</span><br><span class="line"></span><br><span class="line"><span class="comment">#提交你的修改</span></span><br><span class="line">git commit –m <span class="string">"你的注释"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#推送你的更新到远程服务器,语法为 git push [远程名] [本地分支]:[远程分支]</span></span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看文件状态</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment">#跟踪新文件</span></span><br><span class="line">git add readme.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#从当前跟踪列表移除文件，并完全删除</span></span><br><span class="line">git rm readme.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#仅在暂存区删除，保留文件在当前目录，不再跟踪</span></span><br><span class="line">git rm –cached readme.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#重命名文件</span></span><br><span class="line">git mv reademe.txt readme</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看提交的历史记录</span></span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改最后一次提交注释的，利用–amend参数</span></span><br><span class="line">git commit --amend</span><br><span class="line"></span><br><span class="line"><span class="comment">#忘记提交某些修改，下面的三条命令只会得到一个提交。</span></span><br><span class="line">git commit –m &amp;quot;add readme.txt&amp;quot;</span><br><span class="line">git add readme_forgotten</span><br><span class="line">git commit –amend</span><br><span class="line"></span><br><span class="line"><span class="comment">#假设你已经使用git add .，将修改过的文件a、b加到暂存区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#现在你只想提交a文件，不想提交b文件，应该这样</span></span><br><span class="line">git reset HEAD b</span><br><span class="line"></span><br><span class="line"><span class="comment">#取消对文件的修改</span></span><br><span class="line">git checkout –- readme.txt</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="查看、切换、创建和删除分支"><a href="#查看、切换、创建和删除分支" class="headerlink" title="查看、切换、创建和删除分支"></a>查看、切换、创建和删除分支</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git br -r           <span class="comment"># 查看远程分支</span></span><br><span class="line">git br &lt;new_branch&gt; <span class="comment"># 创建新的分支</span></span><br><span class="line">git br -v           <span class="comment"># 查看各个分支最后提交信息</span></span><br><span class="line">git br --merged     <span class="comment"># 查看已经被合并到当前分支的分支</span></span><br><span class="line">git br --no-merged  <span class="comment"># 查看尚未被合并到当前分支的分支</span></span><br><span class="line"></span><br><span class="line">git co &lt;branch&gt;     <span class="comment"># 切换到某个分支</span></span><br><span class="line">git co -b &lt;new_branch&gt; <span class="comment"># 创建新的分支，并且切换过去</span></span><br><span class="line">git co -b &lt;new_branch&gt; &lt;branch&gt;  <span class="comment"># 基于branch创建新的new_branch</span></span><br><span class="line"></span><br><span class="line">git co $id          <span class="comment"># 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除</span></span><br><span class="line">git co $id -b &lt;new_branch&gt;  <span class="comment"># 把某次历史提交记录checkout出来，创建成一个分支</span></span><br><span class="line"></span><br><span class="line">git br -d &lt;branch&gt;  <span class="comment"># 删除某个分支</span></span><br><span class="line">git br -D &lt;branch&gt;  <span class="comment"># 强制删除某个分支（未被合并的分支被删除的时候需要强制）</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="分支合并和rebase"><a href="#分支合并和rebase" class="headerlink" title="分支合并和rebase"></a>分支合并和rebase</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch&gt;               <span class="comment"># 将branch分支合并到当前分支</span></span><br><span class="line">git merge origin/master --no-ff  <span class="comment"># 不要Fast-Foward合并，这样可以生成merge提交</span></span><br><span class="line"></span><br><span class="line">git rebase master &lt;branch&gt;       <span class="comment"># 将master rebase到branch，相当于：</span></span><br><span class="line">git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Git补丁管理-方便在多台机器上开发同步时用"><a href="#Git补丁管理-方便在多台机器上开发同步时用" class="headerlink" title="Git补丁管理(方便在多台机器上开发同步时用)"></a>Git补丁管理(方便在多台机器上开发同步时用)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff &gt; ../sync.patch         <span class="comment"># 生成补丁</span></span><br><span class="line">git apply ../sync.patch          <span class="comment"># 打补丁</span></span><br><span class="line">git apply --check ../sync.patch  <span class="comment">#测试补丁能否成功</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Git暂存管理"><a href="#Git暂存管理" class="headerlink" title="Git暂存管理"></a>Git暂存管理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash                        <span class="comment"># 暂存</span></span><br><span class="line">git stash list                   <span class="comment"># 列所有stash</span></span><br><span class="line">git stash apply                  <span class="comment"># 恢复暂存的内容</span></span><br><span class="line">git stash drop                   <span class="comment"># 删除暂存区</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Git远程分支管理"><a href="#Git远程分支管理" class="headerlink" title="Git远程分支管理"></a>Git远程分支管理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git pull                         <span class="comment"># 抓取远程仓库所有分支更新并合并到本地</span></span><br><span class="line">git pull --no-ff                 <span class="comment"># 抓取远程仓库所有分支更新并合并到本地，不要快进合并</span></span><br><span class="line">git fetch origin                 <span class="comment"># 抓取远程仓库更新</span></span><br><span class="line">git merge origin/master          <span class="comment"># 将远程主分支合并到本地当前分支</span></span><br><span class="line">git co --track origin/branch     <span class="comment"># 跟踪某个远程分支创建相应的本地分支</span></span><br><span class="line">git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt;  <span class="comment"># 基于远程分支创建本地分支，功能同上</span></span><br><span class="line"></span><br><span class="line">git push                         <span class="comment"># push所有分支</span></span><br><span class="line">git push origin master           <span class="comment"># 将本地主分支推到远程主分支</span></span><br><span class="line">git push -u origin master        <span class="comment"># 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)</span></span><br><span class="line">git push origin &lt;local_branch&gt;   <span class="comment"># 创建远程分支， origin是远程仓库名</span></span><br><span class="line">git push origin &lt;local_branch&gt;:&lt;remote_branch&gt;  <span class="comment"># 创建远程分支</span></span><br><span class="line">git push origin :&lt;remote_branch&gt;  <span class="comment">#先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="基本的分支管理"><a href="#基本的分支管理" class="headerlink" title="基本的分支管理"></a>基本的分支管理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个分支</span></span><br><span class="line">git branch iss53</span><br><span class="line"></span><br><span class="line"><span class="comment">#切换工作目录到iss53</span></span><br><span class="line">git chekcout iss53</span><br><span class="line"></span><br><span class="line"><span class="comment">#将上面的命令合在一起，创建iss53分支并切换到iss53</span></span><br><span class="line">git chekcout –b iss53</span><br><span class="line"></span><br><span class="line"><span class="comment">#合并iss53分支，当前工作目录为master</span></span><br><span class="line">git merge iss53</span><br><span class="line"></span><br><span class="line"><span class="comment">#合并完成后，没有出现冲突，删除iss53分支</span></span><br><span class="line">git branch –d iss53</span><br><span class="line"></span><br><span class="line"><span class="comment">#拉去远程仓库的数据，语法为 git fetch [remote-name]</span></span><br><span class="line">git fetch</span><br><span class="line"></span><br><span class="line"><span class="comment">#fetch 会拉去最新的远程仓库数据，但不会自动到当前目录下，要自动合并</span></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看远程仓库的信息</span></span><br><span class="line">git remote show origin</span><br><span class="line"></span><br><span class="line"><span class="comment">#建立本地的dev分支追踪远程仓库的develop分支</span></span><br><span class="line">git checkout –b dev origin/develop</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Git远程仓库管理"><a href="#Git远程仓库管理" class="headerlink" title="Git远程仓库管理"></a>Git远程仓库管理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote -v                    <span class="comment"># 查看远程服务器地址和仓库名称</span></span><br><span class="line">git remote show origin           <span class="comment"># 查看远程服务器仓库状态</span></span><br><span class="line">git remote add origin git@ github:robbin/robbin_site.git         <span class="comment"># 添加远程仓库地址</span></span><br><span class="line">git remote set-url origin git@ github.com:robbin/robbin_site.git <span class="comment"># 设置远程仓库地址(用于修改远程仓库地址)</span></span><br><span class="line">git remote rm &lt;repository&gt;       <span class="comment"># 删除远程仓库</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone --bare robbin_site robbin_site.git  <span class="comment"># 用带版本的项目创建纯版本仓库</span></span><br><span class="line">scp -r my_project.git git@ git.csdn.net:~      <span class="comment"># 将纯仓库上传到服务器上</span></span><br><span class="line"></span><br><span class="line">mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init <span class="comment"># 在服务器创建纯仓库</span></span><br><span class="line">git remote add origin git@ github.com:robbin/robbin_site.git    <span class="comment"># 设置远程仓库地址</span></span><br><span class="line">git push -u origin master                                      <span class="comment"># 客户端首次提交</span></span><br><span class="line">git push -u origin develop  <span class="comment"># 首次将本地develop分支提交到远程develop分支，并且track</span></span><br><span class="line"></span><br><span class="line">git remote set-head origin master   <span class="comment"># 设置远程仓库的HEAD指向master分支</span></span><br></pre></td></tr></table></figure>
<p>也可以命令设置跟踪远程库和本地库</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream master origin/master</span><br><span class="line">git branch --set-upstream develop origin/develop</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Github协同流程："><a href="#Github协同流程：" class="headerlink" title="Github协同流程："></a>Github协同流程：</h2><p>fork给自己 → clone到本地 → coding → push回自己 → github上提出Pull Request即可
之后，本地添加fork源为远端源 → 工作前先pull下fork源保持代码较新 → coding → …</p>
<hr>
<h2 id="GitHub更新fork的版本实践"><a href="#GitHub更新fork的版本实践" class="headerlink" title="GitHub更新fork的版本实践:"></a>GitHub更新fork的版本实践:</h2><p>前提
你已经在github上fork了别人的分支，并且弄好了跟github的ssh连接。(如果没有ssh连接可使用HTTP,操作的时候会多一个输入用户名密码操作)
相关配置详情参考：<a href="https://help.github.com" target="_blank" rel="external">https://help.github.com</a></p>
<p>详细操作:</p>
<p>1.检出自己在github上fork别人的分支</p>
<pre><code>git clone git@github.com:streamers/hadoop.git
</code></pre><p>2.然后增加远程分支（也就是你fork那个人的分支）名为atcic（这个名字任意）到你本地。</p>
<pre><code>git remote add atcic git@github.com:apache/hadoop.git
</code></pre><p>如果你运行命令：git remote -v你会发现多出来了一个Bob的远程分支。如下：</p>
<pre><code>atcic   git@github.com:apache/hadoop.git   (fetch)
atcic   git@github.com:apache/hadoop.git   (push)
origin  git@github.com:apache/hadoop.git   (fetch)
origin  git@github.com:apache/hadoop.git   (push)
</code></pre><p>3.然后，把对方的代码拉到你本地。</p>
<pre><code>git fetch atcic
</code></pre><p>4.最后，合并对方的代码。</p>
<pre><code>git merge atcic/master
</code></pre><p>5.最最后，把最新的代码推送到你的github上。</p>
<pre><code>git push origin master
</code></pre><p>这样就完成了自己的代码更新。</p>
<hr>
<p>Git版本控制大全:</p>
<p><a href="http://git-scm.com/book/zh/v1" target="_blank" rel="external">http://git-scm.com/book/zh/v1</a></p>
]]></content>
    </entry>
    
  
  
</search>
